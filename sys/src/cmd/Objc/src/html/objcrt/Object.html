<HTML>
<TITLE>Object Specification Sheet</TITLE>
<H1>Object Specification Sheet</H1>

<HR>
Portable Object Compiler (c) 1997,2023.  All Rights Reserved.<P>
<H1>Object</H1>
None.  (Object is the root class).<P>
<H2>Class Description</H2>
<B>Object</B> is the superclass of all classes.  Methods implemented here are inherited by all Objective C classes.<P>
<H2>Indexed Variables</H2>
The Portable Object Compiler does not support indexed variables (variable sized objects).  It is best to store data of variable size, by using a pointer to the data, instead of placing the data in the object itself.<P>
<H2>Limits </H2>
The Portable Object Compiler stores the size of instances of subclasses of <B>Object</B> in a <I>short</I> C integer, so it's better to use a pointer to large blocks of data, as opposed to placing the data in the object itself (as an instance variable).<P>
The number of instance methods and class methods that a class can have, is also limited by the size of C <I>short</I> integer (depends on the target platform).<P>
<H2>Method types</H2>
<H3><B>Factory Initialization</B></H3>
<UL>
<LI><A HREF="#0">initialize</A></LI>
</UL>
<H3><B>Creating, Copying and Freeing</B></H3>
<UL>
<LI><A HREF="#3">new</A></LI>
<LI><A HREF="#6">copy</A></LI>
<LI><A HREF="#7">deepCopy</A></LI>
<LI><A HREF="#8">free</A></LI>
<LI><A HREF="#10">release</A></LI>
</UL>
<H3><B>Identity</B></H3>
<UL>
<LI><A HREF="#13">self</A></LI>
<LI><A HREF="#14">yourself</A></LI>
<LI><A HREF="#15">class</A></LI>
<LI><A HREF="#16">superclass</A></LI>
<LI><A HREF="#17">superClass</A></LI>
<LI><A HREF="#18">class</A></LI>
<LI><A HREF="#19">superclass</A></LI>
<LI><A HREF="#20">superClass</A></LI>
<LI><A HREF="#22">name</A></LI>
<LI><A HREF="#23">name</A></LI>
<LI><A HREF="#24">findClass:</A></LI>
<LI><A HREF="#25">findSel:</A></LI>
<LI><A HREF="#26">selOfSTR:</A></LI>
<LI><A HREF="#27">idOfSTR:</A></LI>
</UL>
<H3><B>Comparing</B></H3>
<UL>
<LI><A HREF="#28">hash</A></LI>
<LI><A HREF="#29">isEqual:</A></LI>
<LI><A HREF="#30">str</A></LI>
<LI><A HREF="#31">size</A></LI>
<LI><A HREF="#32">isEqual:</A></LI>
<LI><A HREF="#33">isSame:</A></LI>
<LI><A HREF="#34">notEqual:</A></LI>
<LI><A HREF="#35">notSame:</A></LI>
<LI><A HREF="#36">compare:</A></LI>
<LI><A HREF="#37">invertCompare:</A></LI>
</UL>
<H3><B>Responding to Methods</B></H3>
<UL>
<LI><A HREF="#38">respondsTo:</A></LI>
<LI><A HREF="#39">isMemberOf:</A></LI>
<LI><A HREF="#40">isKindOf:</A></LI>
</UL>
<H3><B>Object Tables</B></H3>
<UL>
<LI><A HREF="#41">someInstance</A></LI>
<LI><A HREF="#42">nextInstance</A></LI>
<LI><A HREF="#43">become:</A></LI>
</UL>
<H3><B>Class Management</B></H3>
<UL>
<LI><A HREF="#45">subclasses</A></LI>
<LI><A HREF="#46">poseAs:</A></LI>
<LI><A HREF="#47">addMethodsTo:</A></LI>
<LI><A HREF="#48">subclass:</A></LI>
<LI><A HREF="#49">subclass:::</A></LI>
<LI><A HREF="#50">load</A></LI>
<LI><A HREF="#51">unload</A></LI>
<LI><A HREF="#52">inheritsFrom:</A></LI>
<LI><A HREF="#53">isSubclassOf:</A></LI>
</UL>
<H3><B>Error Handling</B></H3>
<UL>
<LI><A HREF="#54">subclassResponsibility</A></LI>
<LI><A HREF="#55">subclassResponsibility:</A></LI>
<LI><A HREF="#56">notImplemented</A></LI>
<LI><A HREF="#57">notImplemented:</A></LI>
<LI><A HREF="#58">shouldNotImplement</A></LI>
<LI><A HREF="#59">shouldNotImplement:</A></LI>
<LI><A HREF="#60">shouldNotImplement:from:</A></LI>
<LI><A HREF="#62">error:</A></LI>
<LI><A HREF="#63">halt:</A></LI>
</UL>
<H3><B>Unknown Messages</B></H3>
<UL>
<LI><A HREF="#64">doesNotRecognize:</A></LI>
<LI><A HREF="#65">doesNotUnderstand:</A></LI>
</UL>
<H3><B>Method Lookup</B></H3>
<UL>
<LI><A HREF="#66">methodFor:</A></LI>
<LI><A HREF="#67">instanceMethodFor:</A></LI>
</UL>
<H3><B>Method Performing</B></H3>
<UL>
<LI><A HREF="#68">perform:</A></LI>
<LI><A HREF="#69">perform:with:</A></LI>
<LI><A HREF="#70">perform:with:with:</A></LI>
<LI><A HREF="#71">perform:with:with:with:</A></LI>
</UL>
<H3><B>Printing</B></H3>
<UL>
<LI><A HREF="#72">print</A></LI>
<LI><A HREF="#73">print</A></LI>
<LI><A HREF="#74">printLine</A></LI>
<LI><A HREF="#75">show</A></LI>
<LI><A HREF="#77">printOn:</A></LI>
</UL>
<H3><B>Version</B></H3>
<UL>
<LI><A HREF="#78">objcrtRevision</A></LI>
</UL>
<H3><B>Archiving</B></H3>
<UL>
<LI><A HREF="#79">readFrom:</A></LI>
<LI><A HREF="#80">storeOn:</A></LI>
</UL>
<H3><B>AsciiFiler Methods</B></H3>
<UL>
<LI><A HREF="#85">fileOutOn:</A></LI>
<LI><A HREF="#86">fileInFrom:</A></LI>
<LI><A HREF="#87">fileInFrom:</A></LI>
<LI><A HREF="#88">fileOut:type:</A></LI>
<LI><A HREF="#89">fileIn:type:</A></LI>
<LI><A HREF="#90">awake</A></LI>
<LI><A HREF="#91">awakeFrom:</A></LI>
</UL>
<H2>Methods</H2>
<H3><A NAME="0">initialize</A></H3>
<BLOCKQUOTE>+<B>initialize</B></BLOCKQUOTE>
Every class in the application, receives an <B>initialize</B> message when the program starts.  By default this method doesn't do anything.  It can be overridden to do class initialization.<P>
Note that all classes are guarantueed to receive <B>initialize</B>, before any other message is sent.  Other runtimes differ with ours in this respect, that <B>initialize</B> is sometimes sent to a class, just before an instance of that particular class is being used (as opposed to all classes receiving <B>initialize</B>, before any instance receives a message).<P>
<B>Note:</B> In some runtimes, the equivalent functionality is called <B>+load</B> instead of <B>+initialize</B>.<P>
<H3><A NAME="3">new</A></H3>
<BLOCKQUOTE>+<B>new</B></BLOCKQUOTE>
Factory method to create and return a new instance of the class.  The default implementation clears (zeroes) the memory for instance variables and initializes the <I>isa</I> pointer.<P>
On systems that allow to recover from a failed memory allocation call, <B>new</B> might raise an exception that can be handled with <B>ifOutOfMemory:</B>.  The default handler for this exception aborts the process.<P>
<H3><A NAME="6">copy</A></H3>
<BLOCKQUOTE>-<B>copy</B></BLOCKQUOTE>
Should return a copy of the object.  The difference with <B>deepCopy</B> is, that this copy might share pointers etc. with the receiver of the message.  By default, <B>copy</B> just makes a byte copy of the memory for instance variables.<P>
<H3><A NAME="7">deepCopy</A></H3>
<BLOCKQUOTE>-<B>deepCopy</B></BLOCKQUOTE>
Should return a <I>deep copy</I> of the object.  Usually this means a copy that doesn't share objects with the original object and that can be <B>free</B>'ed independently.  By default, <B>deepCopy</B> just makes a byte copy of the memory for instance variables.<P>
<H3><A NAME="8">free</A></H3>
<BLOCKQUOTE>-<B>free</B></BLOCKQUOTE>
Sets the <B>isa</B> pointer for this instance to <B>nil</B>, frees the memory for the instance, and returns <B>nil</B>.<P>
When compiling with the -gc option, the memory for the instance is not being freed.  The garbage collector takes cares of this.<P>
<B>Note:</B> This method is implemented as <B>shouldNotImplement</B> when using reference counted memory management.  This is so that the user doesn't accidentally sends <B>free</B> messages that interfere with the reference counted memory management.<P>
<H3><A NAME="10">release</A></H3>
<BLOCKQUOTE>-<B>release</B></BLOCKQUOTE>
Message that is automatically sent to object when using the reference count compiler option.  Should free the memory for the instance, and returns <B>nil</B>.<P>
<H3><A NAME="13">self</A></H3>
<BLOCKQUOTE>-<B>self</B></BLOCKQUOTE>
Method that does nothing, except for returning <B>self</B>.<P>
<H3><A NAME="14">yourself</A></H3>
<BLOCKQUOTE>-<B>yourself</B></BLOCKQUOTE>
Method that does nothing, except for returning <B>self</B>.<P>
<H3><A NAME="15">class</A></H3>
<BLOCKQUOTE>-<B>class</B></BLOCKQUOTE>
Returns the class object for the receiver's class.<P>
<B>See also:</B> + class<P>
<H3><A NAME="16">superclass</A></H3>
<BLOCKQUOTE>-<B>superclass</B></BLOCKQUOTE>
Returns the superclass object for the receiver's class.  For GNU compatibility.<P>
<B>See also:</B> + superclass<P>
<H3><A NAME="17">superClass</A></H3>
<BLOCKQUOTE>-<B>superClass</B></BLOCKQUOTE>
Same as <B>superclass</B>.  For Stepstone compatibility.<P>
<H3><A NAME="18">class</A></H3>
<BLOCKQUOTE>+<B>class</B></BLOCKQUOTE>
Traditionally, the <I>class</I> of a class does NOT return the metaclass, but rather <B>self</B> (that, it, the class itself).<P>
<H3><A NAME="19">superclass</A></H3>
<BLOCKQUOTE>+<B>superclass</B></BLOCKQUOTE>
For GNU compatibility.  Returns the superclass of this factory (which is another factory object), or <B>nil</B> for the root.<P>
<H3><A NAME="20">superClass</A></H3>
<BLOCKQUOTE>+<B>superClass</B></BLOCKQUOTE>
Same as <B>superclass</B>, but for Stepstone compatibility.  Returns the superclass of this factory (which is another factory object), or <B>nil</B> for the root.<P>
<H3><A NAME="22">name</A></H3>
<BLOCKQUOTE>- (STR)<B>name</B></BLOCKQUOTE>
Returns the name of the object; implemented by default to return the name of the object's class.<P>
<H3><A NAME="23">name</A></H3>
<BLOCKQUOTE>+ (STR)<B>name</B></BLOCKQUOTE>
Returns the name of the class.<P>
<H3><A NAME="24">findClass:</A></H3>
<BLOCKQUOTE>-<B>findClass</B>:(STR)<I>name</I></BLOCKQUOTE>
Returns the id of a Class name, if that class has been linked in this executable image, otherwise returns <B>nil</B>.<P>
<H3><A NAME="25">findSel:</A></H3>
<BLOCKQUOTE>- (SEL)<B>findSel</B>:(STR)<I>name</I></BLOCKQUOTE>
Returns the selector (uniqued string) of the string <I>name</I>.  Returns NULL if <I>name</I> is not in the selector table.<P>
<H3><A NAME="26">selOfSTR:</A></H3>
<BLOCKQUOTE>- (SEL)<B>selOfSTR</B>:(STR)<I>name</I></BLOCKQUOTE>
Same as <B>findSel:</B>, but raises an exception if the selector is not found.<P>
<H3><A NAME="27">idOfSTR:</A></H3>
<BLOCKQUOTE>-<B>idOfSTR</B>:(STR)<I>aClassName</I></BLOCKQUOTE>
Same as <B>findClass:</B> , but raises an exception if the class is not found.<P>
<H3><A NAME="28">hash</A></H3>
<BLOCKQUOTE>- (unsigned)<B>hash</B></BLOCKQUOTE>
Returns a small integer value derived from the object, that should be equal for two objects for which <B>isEqual:</B> returns YES.  By default, returns the pointer address of the object as an unsigned integer.<P>
<H3><A NAME="29">isEqual:</A></H3>
<BLOCKQUOTE>- (BOOL)<B>isEqual</B>:<I>anObject</I></BLOCKQUOTE>
Should return YES if the receiver is equal to <I>anObject</I>.  By default, compares the pointer addresses of the two objects.<P>
<H3><A NAME="30">str</A></H3>
<BLOCKQUOTE>- (STR)<B>str</B></BLOCKQUOTE>
Returns the name of the object; implemented by default to return the name of the object's class.  The String subclass overrides this method to return its contents.  The method <B>isEqual:</B> of the String class is implemented in terms of <B>str</B>, and String instances can therefore be compared with arbitrary objects.<P>
<H3><A NAME="31">size</A></H3>
<BLOCKQUOTE>- (unsigned)<B>size</B></BLOCKQUOTE>
Returns the number of other objects that this object contains.  Returns 0 by default, but the Collection subclasses override this method to return the size of their contents.<P>
<H3><A NAME="32">isEqual:</A></H3>
<BLOCKQUOTE>+ (BOOL)<B>isEqual</B>:<I>anObject</I></BLOCKQUOTE>
Tests whether two class objects are the same.<P>
<H3><A NAME="33">isSame:</A></H3>
<BLOCKQUOTE>- (BOOL)<B>isSame</B>:<I>anObject</I></BLOCKQUOTE>
Returns YES if the pointer addresses of the two objects are equal.<P>
<H3><A NAME="34">notEqual:</A></H3>
<BLOCKQUOTE>- (BOOL)<B>notEqual</B>:<I>anObject</I></BLOCKQUOTE>
Whether <B>isEqual:</B> returns NO.<P>
<H3><A NAME="35">notSame:</A></H3>
<BLOCKQUOTE>- (BOOL)<B>notSame</B>:<I>anObject</I></BLOCKQUOTE>
Whether <B>isSame:</B> returns NO.<P>
<H3><A NAME="36">compare:</A></H3>
<BLOCKQUOTE>- (int)<B>compare</B>:<I>anObject</I></BLOCKQUOTE>
Should return an integer which is less than, equal to, or greater than zero, if the receiver is less than, equal to, or greater than <I>anObject</I>.  The return value is called the method's comparison value.<P>
<H3><A NAME="37">invertCompare:</A></H3>
<BLOCKQUOTE>- (int)<B>invertCompare</B>:<I>anObject</I></BLOCKQUOTE>
This method simply inverts the return value of <B>compare:</B>.<P>
<H3><A NAME="38">respondsTo:</A></H3>
<BLOCKQUOTE>- (BOOL)<B>respondsTo</B>:(SEL)<I>aSelector</I></BLOCKQUOTE>
Test whether the class implements a certain method.  Returns YES if the class itself, or one of its superclasses, implements the method, otherwise NO.  The method does <I>not</I> generate an error if the class does not implement the method.<P>
<H3><A NAME="39">isMemberOf:</A></H3>
<BLOCKQUOTE>- (BOOL)<B>isMemberOf</B>:<I>aClass</I></BLOCKQUOTE>
Returns YES if the receiver is an instance of <I>aClass</I>, but NO if it's an instance of some subclass of <I>aClass</I>.<P>
<H3><A NAME="40">isKindOf:</A></H3>
<BLOCKQUOTE>- (BOOL)<B>isKindOf</B>:<I>aClass</I></BLOCKQUOTE>
Returns YES if the receiver is an instance of <I>aClass</I> or an instance from some subclass of <I>aClass</I>.  If the receiver is a class, returns YES if <I>aClass</I> is the rootclass (<B>Object</B>) and NO otherwise.<P>
<B>Note:</B> For portability, this method always needs to be used as follows:<P>
<BLOCKQUOTE><PRE>
[ foo isKindOf:(id) [Classname class] ];
</PRE></BLOCKQUOTE>
The reason is that some compilers do not allow class names as expressions, so the class must be obtained by sending a <B>class</B> message.   In addition, some compilers have a <B>isKindOf:</B> method that takes an <I>id</I> argument, but the return value of <B>self</B> or <B>class</B> can be SHR for those compilers.  Therefore, it's necessary to cast the return value to <I>id</I> (to avoid compiler warnings).<P>
<B>See also:</B> +inheritsFrom:, -isMemberOf:<P>
<H3><A NAME="41">someInstance</A></H3>
<BLOCKQUOTE>+<B>someInstance</B></BLOCKQUOTE>
Returns the first instance in an enumeration of instances, or <B>nil</B> when there is no instance.<P>
<B>Note:</B> Works only when using the -otb compiler switch.<P>
<H3><A NAME="42">nextInstance</A></H3>
<BLOCKQUOTE>-<B>nextInstance</B></BLOCKQUOTE>
Returns the next instance in the enumeration of instances of a class, or <B>nil</B> when there are no more instances.<P>
<B>Note:</B> Works only when using the -otb compiler switch.<P>
<H3><A NAME="43">become:</A></H3>
<BLOCKQUOTE>-<B>become</B>:<I>other</I></BLOCKQUOTE>
Swaps pointers for the receiver of the message and the argument.  All variables that used to point to the receiver, now point to the argument, and vice-versa.<P>
<B>Note:</B> Works only when using the -otb compiler switch.<P>
<H3><A NAME="45">subclasses</A></H3>
<BLOCKQUOTE>+<B>subclasses</B></BLOCKQUOTE>
Returns a <B>OrdCltn</B> of direct subclasses of the class that receives the message.  If the class has no subclasses, then this method returns an empty <B>OrdCltn</B> (not <B>nil</B>).  The class itself is not considered subclass of itself.<P>
<B>Note:</B> This method is Portable Object Compiler only.<P>
<B>See also:</B> +class, +superclass, +inheritsFrom:<P>
<H3><A NAME="46">poseAs:</A></H3>
<BLOCKQUOTE>+<B>poseAs</B>:<I>superClass</I></BLOCKQUOTE>
The <B>poseAs:</B> method permits to modify a supplied <I>superClass</I> (for which, for example, no source code is available) by substituting a direct subclass of <I>superClass</I>.  It is normally used inside <B>+initialize</B>, but the Portable Object Compiler allows <B>poseAs:</B> to be used anywhere in the program.<P>
<BLOCKQUOTE><PRE>
+ initialize { [self poseAs:[Set self]]; return self; }
</PRE></BLOCKQUOTE>
The example shows how the <B>initialize</B> of some subclass, called for example <B>SubSet</B>, can substitute <B>SubSet</B> for <B>Set</B>.  Methods defined in <B>SubSet</B> override those defined in the superclass, and new methods from <B>SubSet</B>, will appear to have come from the <B>Set</B> class.<P>
When performing a <B>poseAs:</B>, the following rules must be followed:<P>
<UL>
<LI>The posing class must be an immediate subclass of the class that it is to impersonate.</LI>
<LI>The posing class may define or redefine only methods.</LI>
<LI>Specifically, the posing class may NOT add any new instance variables.</LI>
</UL>
The Portable Object Compiler implementation of <B>poseAs:</B> differs from some other runtimes, since it allows <B>poseAs:</B> to happen, even after messages have been sent to instances of posing or impersonated class.<P>
Implementation details:<P>
<UL>
<LI>poseAs: patches the superclass pointer of all subclasses (other than the posing class) that inherit from <I>superClass</I></LI>
<LI>poseAs: changes the name of <I>superClass</I> by prefixing the name with  _%</LI>
<LI>findClass: for the name of <I>superClass</I> will return the posing subclass.</LI>
</UL>
<B>Note:</B> All Objective-C compilers provide this functionality (sometimes with restrictions on when the method can be called)<P>
<H3><A NAME="47">addMethodsTo:</A></H3>
<BLOCKQUOTE>+<B>addMethodsTo</B>:<I>superClass</I></BLOCKQUOTE>
The <B>addMethodsTo:</B> method permits to modify a supplied <I>superClass</I> (for which, for example, no source code is available) by adding the (instance and factory) methods of a direct subclass, to <I>superClass</I>.  It is normally used inside <B>+initialize</B>, but the Portable Object Compiler allows <B>addMethodsTo:</B> to be used anywhere in the program.<P>
The same restrictions apply as for <B>poseAs:</B> : the subclass needs to be a direct subclass of <I>superClass</I> and it may not add instance variables.  However, unlike <B>poseAs:</B>, the subclass will not be substituted for the <I>superClass</I> for purposes as <B>fileIn:</B> etc.  Also, (unlike <B>poseAs:</B>) when the subclass adds a method to the <I>superClass</I> that was overridden from the <I>superClass</I>, then this method will not replace the method of the <I>superClass</I>.<P>
<UL>
</UL>
<B>Note:</B> Portable Object Compiler only.<P>
<H3><A NAME="48">subclass:</A></H3>
<BLOCKQUOTE>+<B>subclass</B>:(STR)<I>name</I></BLOCKQUOTE>
Method to dynamically subclass a class.  Returns a new class object, which is still unregistered.  With the methods <B>load</B> and <B>unload</B>, one can add or remove the class to the runtime, such that methods like <B>findClass:</B> will also return this new class.<P>
<B>Note:</B> Portable Object Compiler only.<P>
<H3><A NAME="49">subclass:::</A></H3>
<BLOCKQUOTE>+<B>subclass</B>:(STR)<I>name</I>:(int)<I>ivars</I>:(int)<I>cvars</I></BLOCKQUOTE>
Method to dynamically subclass a class.  Returns a new class object, which is still unregistered.  With the methods <B>load</B> and <B>unload</B>, one can add or remove the class to the runtime, such that methods like <B>findClass:</B> will also return this new class.<P>
<B>Note:</B> Portable Object Compiler only.<P>
<H3><A NAME="50">load</A></H3>
<BLOCKQUOTE>+<B>load</B></BLOCKQUOTE>
This method adds a dynamically created class to the runtime.  The class will appear to methods such as <B>findClass:</B> or <B>findSel:</B> (for any selectors of methods of the class).<P>
<B>Note:</B> Portable Object Compiler only.<P>
<H3><A NAME="51">unload</A></H3>
<BLOCKQUOTE>+<B>unload</B></BLOCKQUOTE>
This method removes a dynamically created class from the runtime.  The class will appear to be unavailable to methods such as <B>findClass:</B>, after removing the class by an <B>unload</B> message.<P>
<B>Note:</B> Portable Object Compiler only.<P>
<H3><A NAME="52">inheritsFrom:</A></H3>
<BLOCKQUOTE>+ (BOOL)<B>inheritsFrom</B>:<I>aClass</I></BLOCKQUOTE>
Returns YES if the receiving class is a subclass (direct or not) from <I>aClass</I>.  Returns NO if the receiver is <I>aClass</I> itself, e.g. :<P>
<BLOCKQUOTE><PRE>
- (BOOL)isKindOf:c { return (isa==c) || [isa inheritsFrom:aClass]; }
</PRE></BLOCKQUOTE>
<B>Note:</B> For compatibility with Squeak.<P>
<H3><A NAME="53">isSubclassOf:</A></H3>
<BLOCKQUOTE>+ (BOOL)<B>isSubclassOf</B>:<I>aClass</I></BLOCKQUOTE>
Equivalent to <B>inheritsFrom:</B>.<P>
<H3><A NAME="54">subclassResponsibility</A></H3>
<BLOCKQUOTE>-<B>subclassResponsibility</B></BLOCKQUOTE>
Used in classes to indicate that the functionality is assumed to be implemented by a subclass, as in:<P>
<BLOCKQUOTE><PRE>
- foo { [self subclassResponsibility]; }
</PRE></BLOCKQUOTE>
If the subclass does not implement the method, then an error message is generated.<P>
<H3><A NAME="55">subclassResponsibility:</A></H3>
<BLOCKQUOTE>-<B>subclassResponsibility</B>:(SEL)<I>aSelector</I></BLOCKQUOTE>
For Stepstone compatibility.<P>
<H3><A NAME="56">notImplemented</A></H3>
<BLOCKQUOTE>-<B>notImplemented</B></BLOCKQUOTE>
Method to indicate that a method is temporarily not implemented : <P>
<BLOCKQUOTE><PRE>
-foo { [self notImplemented]; }
</PRE></BLOCKQUOTE>
When designing a class, the method <B>notImplemented</B> can be used to implement stubs for the methods that make up the class.  When the design phase is finished, the actual implementation can begin.  If later, by accident, not all functionality is properly implemented, the method <B>notImplemented</B> will help finding this.<P>
<H3><A NAME="57">notImplemented:</A></H3>
<BLOCKQUOTE>-<B>notImplemented</B>:(SEL)<I>aSelector</I></BLOCKQUOTE>
For Stepstone compatibility.<P>
<H3><A NAME="58">shouldNotImplement</A></H3>
<BLOCKQUOTE>-<B>shouldNotImplement</B></BLOCKQUOTE>
This is the opposite of <B>subclassResponsibility</B> and a stronger form of <B>notImplemented</B> : <B>shouldNotImplement</B> should be used, when the class is not supposed to implement some method, i.e. when the method is not appropriate for the class and its subclasses.<P>
An abstract superclass, called <I>MyClass</I> for example, can use this method to indicate that subclasses should not send (or be sent) a <B>new</B> message, but that they are supposed to send some other method (such as <B>foo:</B> perhaps) :<P>
<BLOCKQUOTE><PRE>
+new { [self shouldNotImplement]; }
+foo:aBar { self = [super new];bar = aBar; return self; }
</PRE></BLOCKQUOTE>
This announces that <B>new</B>, which would otherwise have been inherited from the root class, is not an appropriate way to create an instance of a subclass of MyClass.<P>
<H3><A NAME="59">shouldNotImplement:</A></H3>
<BLOCKQUOTE>-<B>shouldNotImplement</B>:(SEL)<I>aSelector</I></BLOCKQUOTE>
Method for Stepstone compatibility.<P>
<H3><A NAME="60">shouldNotImplement:from:</A></H3>
<BLOCKQUOTE>-<B>shouldNotImplement</B>:(SEL)<I>aSelector</I><B>from</B>:<I>superClass</I></BLOCKQUOTE>
Method for Stepstone compatibility.<P>
<H3><A NAME="62">error:</A></H3>
<BLOCKQUOTE>-<B>error</B>:(STR)<I>format,...</I></BLOCKQUOTE>
Generate an error message.  Takes a format string in the style of the C library function <I>printf</I>, with a variable number of arguments.  Returns <B>self</B>.<P>
This method is present in most runtimes, but it was reimplemented in the Portable Object Compiler, so that the error can be <I>caught</I>, using the Block instance method <B>ifError:</B>.  Traditionally, the method <B>error:</B> simply aborts the process, and the default error handler in our implementation does the same thing.<P>
<H3><A NAME="63">halt:</A></H3>
<BLOCKQUOTE>-<B>halt</B>:<I>message</I></BLOCKQUOTE>
This method is equivalent to the <B>error:</B> method but takes an object as argument.<P>
The halt method pops an error handler from the stack of handlers, as maintained by <B>ifError:</B>.  The handler is evaluated with the message and the receiver of the <B>halt:</B> message, as arguments.  If the handler returns, it is pushed again on the stack.  If there were no handlers on the stack, the default error handler is used instead, as returned by <B>errorHandler</B>.<P>
<B>Note:</B> Portable Object Compiler specific<P>
<H3><A NAME="64">doesNotRecognize:</A></H3>
<BLOCKQUOTE>-<B>doesNotRecognize</B>:(SEL)<I>aSelector</I></BLOCKQUOTE>
Automatically sent by the <I>runtime</I> when the class does not implement <I>aSelector</I>.<P>
<B>Note:</B> The Portable Object Compiler offers a generalization of this method, called <B>doesNotUnderstand:</B>.  The <B>doesNotRecognize:</B> method is sent <I>via</I> <B>doesNotUnderstand:</B> and not directly by the messenger.<P>
<B>See also:</B> doesNotUnderstand:<P>
<H3><A NAME="65">doesNotUnderstand:</A></H3>
<BLOCKQUOTE>-<B>doesNotUnderstand</B>:<I>aMessage</I></BLOCKQUOTE>
This method is sent by the messenger when a message is sent to an object, that is not implemented by that object.  The default implementation is,<P>
<BLOCKQUOTE><PRE>
[self doesNotRecognize:[aMessage selector]];
</PRE></BLOCKQUOTE>
which means that code that was overriding <B>doesNotRecognize:</B> to do forwarding of (unary) messages can continue to work.<P>
However, the new (Portable Object Compiler specific) <B>doesNotUnderstand:</B> method, together with the <B>Message</B> class,  provides a way of forwarding messages with arbitrary return values and arguments.<P>
<B>See also:</B> Message Class<P>
<H3><A NAME="66">methodFor:</A></H3>
<BLOCKQUOTE>- (IMP)<B>methodFor</B>:(SEL)<I>aSelector</I></BLOCKQUOTE>
Returns a function implementation pointer for <I>aSelector</I>.  Returns a pointer to an error handling function if the object does not respond to <I>aSelector</I>.<P>
Use of this method for reasons of performance, is not encouraged, because by repeatedly using the resulting function pointer, one is bypassing (the benefits of) dynamic binding.<P>
A good use of <B>methodFor:</B> however, is, because this method is supported by various runtimes, to send a message in a runtime independent, portable way, without using runtime specific functions (such as _imp(), _msg(), objc_msg_Send() etc. which have, unlike <B>methodFor:</B> non-standard names) :<P>
<BLOCKQUOTE><PRE>
((int (*) (id,id,BOOL))[object methodFor:selector])(object,arg,flag);
</PRE></BLOCKQUOTE>
The same thing can be achieved by using the _imp() function immediately but using the <B>methodFor:</B> message is the preferred API.<P>
<H3><A NAME="67">instanceMethodFor:</A></H3>
<BLOCKQUOTE>+ (IMP)<B>instanceMethodFor</B>:(SEL)<I>aSelector</I></BLOCKQUOTE>
Returns a function implementation pointer for <I>aSelector</I>.  Returns a pointer to an error handling function if the object does not respond to <I>aSelector</I>.<P>
Use of this method is not encouraged, because by using the resulting function pointer, one is bypassing (the benefits of) dynamic binding.<P>
<H3><A NAME="68">perform:</A></H3>
<BLOCKQUOTE>-<B>perform</B>:(SEL)<I>aSelector</I></BLOCKQUOTE>
Returns the value that would result when sending <I>aSelector</I> to the receiver.<P>
<H3><A NAME="69">perform:with:</A></H3>
<BLOCKQUOTE>-<B>perform</B>:(SEL)<I>aSelector</I><B>with</B>:<I>anObject</I></BLOCKQUOTE>
Returns the value that would result when sending <I>aSelector</I> to the receiver with a single argument <I>anObject</I>.  The following are equivalent :<P>
<BLOCKQUOTE><PRE>
[aReceiver perform:@selector(do:) with:anObject];
</PRE></BLOCKQUOTE>
and<P>
<BLOCKQUOTE><PRE>
[aReceiver do:anObject];
</PRE></BLOCKQUOTE>
<H3><A NAME="70">perform:with:with:</A></H3>
<BLOCKQUOTE>-<B>perform</B>:(SEL)<I>aSelector</I><B>with</B>:<I>anObject</I><B>with</B>:<I>otherObject</I></BLOCKQUOTE>
Returns the value that would result when sending <I>aSelector</I> to the receiver with arguments <I>anObject</I> and <I>otherObject</I>.<P>
<H3><A NAME="71">perform:with:with:with:</A></H3>
<BLOCKQUOTE>-<B>perform</B>:(SEL)<I>aSelector</I><B>with</B>:<I>anObject</I><B>with</B>:<I>otherObject</I><B>with</B>:<I>thirdObj</I></BLOCKQUOTE>
Returns the value that would result when sending <I>aSelector</I> to the receiver with arguments <I>anObject</I> and <I>otherObject</I>.<P>
<H3><A NAME="72">print</A></H3>
<BLOCKQUOTE>-<B>print</B></BLOCKQUOTE>
Prints the object to the <I>stdout</I> and returns <B>self</B>.  Implemented as,<P>
<BLOCKQUOTE><PRE>
return [self printOn:stdout]; 
</PRE></BLOCKQUOTE>
meaning that if you implement <B>printOn:</B>, then this method will work.<P>
<H3><A NAME="73">print</A></H3>
<BLOCKQUOTE>+<B>print</B></BLOCKQUOTE>
Factory method to print the name of the class to the <I>stdout</I> and to return <B>self</B>.  <P>
<H3><A NAME="74">printLine</A></H3>
<BLOCKQUOTE>-<B>printLine</B></BLOCKQUOTE>
Prints the object (in the sense of <B>print</B>) and then a newline.<P>
<H3><A NAME="75">show</A></H3>
<BLOCKQUOTE>-<B>show</B></BLOCKQUOTE>
Displays the object on the <I>stderr</I>, by using Filer code, and returns <B>self</B>.  Because it is implemented in terms of Filer code, this method is completely unrelated to the <B>print</B> method, although that the goal in both cases is to print a symbolic representation of the object.<P>
This method is extremely useful for debugging.  The compiler automatically implements Filer methods, so this method <I>dumps</I> instance variables of the object in a symbolic format, without the programmer having to implement debug/printing routines.<P>
Method for Stepstone compatibility.  Used in Producer code.<P>
<H3><A NAME="77">printOn:</A></H3>
<BLOCKQUOTE>-<B>printOn</B>:(IOD)<I>anIOD</I></BLOCKQUOTE>
Should print the object to <I>anIOD</I>, which is of type <B>IOD</B> (defined as an <I>input output device</I>, a <B>FILE</B> pointer, to be used with standard I/O).  Should return the receiver.  By default, the method prints nothing.<P>
This is the method to override in subclasses to make <B>print</B>, <B>printLine</B> etc. to work.<P>
<H3><A NAME="78">objcrtRevision</A></H3>
<BLOCKQUOTE>+ (STR)<B>objcrtRevision</B></BLOCKQUOTE>
Returns the version string of the runtime being used.<P>
<H3><A NAME="79">readFrom:</A></H3>
<BLOCKQUOTE>+<B>readFrom</B>:(STR)<I>aFileName</I></BLOCKQUOTE>
Activates the object stored in the file <I>aFileName</I>.  The object will in all respects be functional, as it was before being stored.  Works by indirectly calling <I>fileIn()</I>.  The class AsciiFiler must be linked into the application for this method to work.<P>
This message can be sent to any factory object without regard of the class of the object being read in.  In other words, if file <I>foo</I> contains a saved instance of a <B>OrdCltn</B>, then<P>
<BLOCKQUOTE><PRE>
id myCollection = [Object readFrom:"foo"];
</PRE></BLOCKQUOTE>
will work, ie. the receiver doesn't need to be <B>OrdCltn</B>.  Returns <B>nil</B> on failure.<P>
<H3><A NAME="80">storeOn:</A></H3>
<BLOCKQUOTE>- (BOOL)<B>storeOn</B>:(STR)<I>aFileName</I></BLOCKQUOTE>
Stores the receiver to a file named <I>aFileName</I>, in a format such that the object can then be activated later, using the <B>readFrom:</B> method.  Works by indirectly calling the function <I>storeOn()</I>.  The class AsciiFiler must be linked into the application for this method to work<P>
<H3><A NAME="85">fileOutOn:</A></H3>
<BLOCKQUOTE>-<B>fileOutOn</B>:<I>aFiler</I></BLOCKQUOTE>
Writes the receiver on <I>aFiler</I>. This is the method that a subclass will override to do it own processing, if the default implementation, which automatically writes out all instance variables of type <I>id</I>, does not suffice.<P>
This method will be invoked twice by the Filer class, during archiving.<P>
<H3><A NAME="86">fileInFrom:</A></H3>
<BLOCKQUOTE>+<B>fileInFrom</B>:<I>aFiler</I></BLOCKQUOTE>
Creates a new instance of the class, files in the instance from <I>aFiler</I> (by sending the new object a <B>fileInFrom:</B>) message, and returns the new object.<P>
<H3><A NAME="87">fileInFrom:</A></H3>
<BLOCKQUOTE>-<B>fileInFrom</B>:<I>aFiler</I></BLOCKQUOTE>
Reads the receiver from <I>aFiler</I>. The default implementation automatically reads in instance variables of type <I>id</I>.  This method must be overridden to match <B>fileOutFor:</B>, if that method was implemented by the subclass.<P>
One should realize that, at the time this method is invoked, not all objects are guarantueed to be in a usable state.  This is only true once the filer starts sending <B>awakeFrom:</B> messages.<P>
<H3><A NAME="88">fileOut:type:</A></H3>
<BLOCKQUOTE>-<B>fileOut</B>:(void *)<I>value</I><B>type</B>:(char)<I>typeDesc</I></BLOCKQUOTE>
Method to be implemented by Filer class.<P>
<H3><A NAME="89">fileIn:type:</A></H3>
<BLOCKQUOTE>-<B>fileIn</B>:(void *)<I>value</I><B>type</B>:(char)<I>typeDesc</I></BLOCKQUOTE>
Method to be implemented by Filer class.<P>
<H3><A NAME="90">awake</A></H3>
<BLOCKQUOTE>-<B>awake</B></BLOCKQUOTE>
This message is sent to every object when it is filed in, after all the objects it references are in a usable state.  The default implementation simply returns self.<P>
<H3><A NAME="91">awakeFrom:</A></H3>
<BLOCKQUOTE>-<B>awakeFrom</B>:<I>aFiler</I></BLOCKQUOTE>
Allows the receiver to do some cleanup work after an object has been filed in.  It is a generalization of the old <B>-awake</B> method.  The difference is that this method passes <I>aFiler</I> as an argument.  The default implementation is to send the <B>awake</B> message.<P>

.TH bacon 1
.SH NAME
bacon 4.8 \- a free BASIC to C converter for Unix-based systems.
.SH "Introduction"
.SH ""
   BaCon is an acronym for BAsic CONverter. The BaCon BASIC converter is a
.br
   tool to convert programs written in BASIC syntax to C. The resulting C
.br
   code can be compiled using generic C compilers like GCC or CC. It can be
.br
   compiled using a C++ compiler as well.
.br
.SH ""
   BaCon intends to be a programming aid in creating small tools which can be
.br
   compiled on different Unix-based platforms. It tries to revive the days of
.br
   the good old BASIC.
.br
.SH ""
   The BaCon converter passes expressions and numeric assignments to the C
.br
   compiler without verification or modification. Therefore BaCon can be
.br
   considered a lazy converter: it relies on the expression parser of the C
.br
   compiler.
.br
.SH ""
.SH "BaCon usage and parameters"
.SH ""
   To use BaCon, download the converter package and run the installer. The
.br
   converter can be used as follows:
.br
.SH ""
       bash ./bacon.sh myprog.bac
.br
.SH ""
   Note that BASH 4.x or higher is required to execute the Shell script
.br
   version of BaCon.
.br
.SH ""
   By default, the converter will refer to '/bin/bash' by itself. It uses a
.br
   so-called 'shebang' which allows the program to run standalone provided
.br
   the executable rights are set correctly. This way there is no need to
.br
   execute BaCon with an explicit use of BASH. So this is valid:
.br
.SH ""
       ./bacon.sh myprog.bac
.br
.SH ""
   Alternatively, also Kornshell93 (releases after 2012) or Zshell (versions
.br
   higher than 4.x) can be used:
.br
.SH ""
       ksh ./bacon.sh myprog.bac
.br
.SH ""
       zsh ./bacon.sh myprog.bac
.br
.SH ""
   All BaCon programs should use the '.bac' extension. But it is not
.br
   necessary to provide this extension for conversion. So BaCon also
.br
   understands the following syntax:
.br
.SH ""
       ./bacon.sh myprog
.br
.SH ""
   Another possibility is to point to the URL of a BaCon program hosted by a
.br
   website. The program will then be downloaded automatically, after which it
.br
   is converted:
.br
.SH ""
       ./bacon.sh http://www.basic-converter.org/fetch.bac
.br
.SH ""
   The BaCon Basic Converter can be started with the following parameters.
.br
.SH ""
     * -c: determine which C compiler should create the binary (defaults to
.br
       'gcc')
.br
.SH ""
     * -l: pass a library to the C linker
.br
.SH ""
     * -o: pass a compiler option to the C compiler
.br
.SH ""
     * -i: the compilation will use an additional external C include file
.br
.SH ""
     * -d: determine the directory where BaCon should store the generated C
.br
       files (defaults to the current directory)
.br
.SH ""
     * -x: extract gettext strings from generated c sources
.br
.SH ""
     * -z: allow the usage of lowercase statements and functions
.br
.SH ""
     * -e: starts the embedded ASCII editor
.br
.SH ""
     * -f: create a shared object of the program
.br
.SH ""
     * -n: do not compile the C code automatically after conversion
.br
.SH ""
     * -y: suppress warning about temporary files if these exist
.br
.SH ""
     * -j: invoke C preprocessor to interpret C macros which were added to
.br
       BaCon source code
.br
.SH ""
     * -p: do not cleanup the generated C files (default behavior is to
.br
       delete all generated C files automatically)
.br
.SH ""
     * -q: suppress line counting during conversion and only show summary
.br
       after conversion
.br
.SH ""
     * -r: convert and execute the resulting program in one step
.br
.SH ""
     * -s: suppress warnings about semantic errors
.br
.SH ""
     * -t: tweak internal BaCon parameters for the string core engine and
.br
       memory pool:
.br
.SH ""
   pbc=<x>: set the Pool Block Count to <x> defaults to: 1024
.br
   pbs=<x>: set each individual Pool Block Size to <x> defaults to: 1024
.br
   hld=<x>: set the Hash Linear Depth probing to <x> defaults to: 16
.br
   hss=<x>: set the Hash String Store size to <x> defaults to: 0x100000
.br
   mrb=<x>: set the Maximum Return Buffers to <x> defaults to: 64
.br
.SH ""
     * -w: store command line settings in the configuration file
.br
       ~/.bacon/bacon.cfg. This file will be used in subsequent invocations
.br
       of BaCon (not applicable for the GUI version)
.br
.SH ""
     * -v: shows the current version of BaCon
.br
.SH ""
     * -h: shows an overview of all possible options on the prompt. Same as
.br
       the '-?' parameter
.br
.SH ""
   The shell script implementation can convert and compile the BaCon version
.br
   of BaCon. This will deliver the binary version of BaCon which has an
.br
   extremely high conversion performance. On newer systems, the average
.br
   conversion rate usually lies above 10.000 lines per second.
.br
.SH ""
   This documentation refers both to the shell script and binary
.br
   implementation of BaCon.
.br
.SH ""
   Here are a few examples showing the usage of command line parameters:
.br
.SH ""
     * Convert and compile program with debug symbols: bacon -o -g
.br
       program.bac
.br
.SH ""
     * Convert and compile program, optimize and strip: bacon -o -O2 -o -s
.br
       program.bac
.br
.SH ""
     * Convert and compile program and export functions as symbols: bacon -o
.br
       -export-dynamic yourprogram.bac
.br
.SH ""
     * Convert and compile program using TCC and export functions as symbols:
.br
       bacon -c tcc -o -rdynamic yourprogram.bac
.br
.SH ""
     * Convert and compile program forcing 32bit and optimize for current
.br
       platform: bacon -o -m32 -o -mtune=native yourprogram.bac
.br
.SH ""
     * Convert and compile program linking to a particular library: bacon -l
.br
       somelib program.bac
.br
.SH ""
     * Convert and compile program including an additional C header file:
.br
       bacon -i header.h yourprogram.bac
.br
.SH ""
     * Store compile options permanently: bacon -w -l tcmalloc -o -O2
.br
       program.bac (subsequent invocations of BaCon will now always use the
.br
       mentioned options)
.br
.SH ""
   Most of the aforementioned options also can be used programmatically by
.br
   use of the PRAGMA keyword.
.br
.SH ""
.SH "General syntax"
.SH ""
   BaCon consists of statements, functions and expressions. Each line should
.br
   begin with a statement. A line may continue onto the next line by using a
.br
   space and the '\\' symbol at the end of the line. The LET statement may be
.br
   omitted, so a line may contain an assignment only. Expressions are not
.br
   converted, but are passed unchanged to the C compiler (lazy conversion).
.br
.SH ""
   BaCon does not require line numbers. More statements per line are
.br
   accepted. These should be separated by the colon symbol ':'.
.br
.SH ""
   All keywords must be written in capitals to avoid name clashes with
.br
   existing C keywords or functions from libc. Keywords in small letters are
.br
   considered to be variables unless the '-z' command line option is
.br
   specified, in which case BaCon tries to parse lowercase keywords as if
.br
   they were written in capitals. Note that this may lead to unexpected
.br
   results, for example if the program uses variable names which happen to be
.br
   BaCon keywords.
.br
.SH ""
   Statements are always written without using brackets. Functions however
.br
   must use brackets to enclose their arguments. Functions always return a
.br
   value or string, contrary to subs. Functions created in the BaCon program
.br
   can be invoked standalone, meaning that they do not need to appear in an
.br
   assignment.
.br
.SH ""
   Subroutines may be defined using SUB/ENDSUB and do not return a value.
.br
   With the FUNCTION/ENDFUNCTION statements a function can be defined which
.br
   does return a value. The return value must be explicitly stated with the
.br
   statement RETURN.
.br
.SH ""
   The three main variable types in BaCon are defined as STRING, NUMBER and
.br
   FLOATING. These are translated to char*, long and double.
.br
.SH ""
   A variable will be declared implicitly when the variable is used in an
.br
   assignment (e.g. LET) or in a statement which assigns a value to a
.br
   variable. By default, implicitly declared variables are of 'long' type.
.br
   This default can be changed by using the OPTION VARTYPE statement. Note
.br
   that implicitly declared variables always have a global scope, meaning
.br
   that they are visible to all functions and routines in the whole program.
.br
   Variables which are used and implicitly declared within a SUB or FUNCTION
.br
   also by default have a global scope. When declared with the LOCAL
.br
   statement variables will have a scope local to the FUNCTION or SUB.
.br
.SH ""
   In case of implicit assignments, BaCon assumes numeric variables to be of
.br
   long type, unless specified otherwise with OPTION VARTYPE. Also, it is
.br
   possible to define a variable to any other C-type explicitly using the
.br
   DECLARE and LOCAL statements.
.br
.SH ""
   Next to this, BaCon accepts type suffixes as well. For example, if a
.br
   variable name ends with the '$' symbol, a string variable is assumed. If a
.br
   variable name ends with the '#' symbol, a float variable is assumed. If a
.br
   variable name ends with the '%' symbol, it is considered to be an integer
.br
   variable. The type suffixes also can be used when defining a function
.br
   name.
.br
.SH ""
.SH "Mathematics, variables"
.SH ""
   The standard C operators for mathematics can be used, like '+' for
.br
   addition, '-' for subtraction, '/' for division and '*' for
.br
   multiplication. For the binary 'and', the '&' symbol must be used, and for
.br
   the binary 'or' use the pipe symbol '|'. Binary shifts are possible with
.br
   '>>' and '<<'.
.br
.SH ""
      C operator     Meaning              C Operator    Meaning               
.br
           +         Addition                 |         Inclusive or          
.br
           -         Subtraction              ^         Exclusive or          
.br
           *         Multiplication           >>        Binary shift right    
.br
           /         Division                 <<        Binary shift left     
.br
           &         Binary and         
.br
.SH ""
   Variable names may be of any length but may not start with a number or an
.br
   underscore symbol.
.br
.SH ""
.SH "Equations"
.SH ""
   Equations are used in statements like IF...THEN, WHILE...WEND, and
.br
   REPEAT...UNTIL. In BaCon the following symbols for equations can be used:
.br
.SH ""
        Symbol      Meaning               Type                                
.br
          0         Equal to              String, numeric                     
.br
        !=, <>      Not equal to          String, numeric                     
.br
          >         Greater than          String, numeric also allows GT      
.br
          <         Less than             String, numeric also allows LT      
.br
          >=        Greater or equal      String, numeric also allows GE      
.br
          <=        Less or equal         String, numeric also allows LE      
.br
        EQ, IS      Equal to              Numeric                             
.br
      NE, ISNOT     Not equal to          Numeric                             
.br
       AND, OR      Logical and,or        String, numeric                     
.br
       BETWEEN      In between            String, numeric                     
.br
        BEYOND      Outside               String, numeric                     
.br
       EQUAL()      Equal to              String                              
.br
.SH ""
.SH "The BETWEEN and BEYOND keywords"
.SH ""
   When using equations in WHILE, IF, REPEAT, IIF or IIF$ it often happens
.br
   that a check needs to be performed to see if a certain value lies within a
.br
   range. For this purpose, BaCon accepts the BETWEEN comparison keyword. For
.br
   example:
.br
.SH ""
   IF 5 BETWEEN 0;10 THEN PRINT "Found"
.br
.SH ""
   This comparison will return TRUE in case the value 5 lies within 0 and 10.
.br
   The comparison will include the lower and upper boundary value during
.br
   evaluation. Note that the lower and upper values are being separated by a
.br
   semicolon. Alternatively, the keyword AND may be used here as well:
.br
.SH ""
   IF 5 BETWEEN 0 AND 10 THEN PRINT "Found"
.br
.SH ""
   Note that this may lead to confusing constructs when adding more logical
.br
   requirements to the same equation.
.br
.SH ""
   The BETWEEN comparison also accepts strings:
.br
.SH ""
   IF "C" BETWEEN "Basic" AND "Pascal" THEN PRINT "This is C"
.br
.SH ""
   The order of the mentioned range does not matter, the following code will
.br
   deliver the exact same result:
.br
.SH ""
   IF "C" BETWEEN "Pascal" AND "Basic" THEN PRINT "This is C"
.br
.SH ""
   In case the boundary values should be excluded, BaCon accepts the optional
.br
   EXCL keyword:
.br
.SH ""
   IF variable BETWEEN 7 AND 3 EXCL THEN PRINT "Found"
.br
.SH ""
   The last example will print "Found" in case the variable lies within 3 and
.br
   7, values which themselves are excluded.
.br
.SH ""
   Similarly, to check if a value lies outside a certain range, the keyword
.br
   BEYOND can be used:
.br
.SH ""
   IF 5 BEYOND 1 AND 3 THEN PRINT "Outside"
.br
.SH ""
   Note that in case of the BEYOND keyword the boundary values themselves are
.br
   considered to be part of the outside range. The same EXCL keyword can be
.br
   used to exclude them.
.br
.SH ""
.SH "Indexed arrays"
.SH ""
.SS "  Declaration of static arrays"
.SH ""
   An array will never be declared implicitly by BaCon, so arrays must be
.br
   declared explicitly. This can be done by using the keyword GLOBAL or
.br
   DECLARE for arrays which should be globally visible, or LOCAL for local
.br
   array variables.
.br
.SH ""
   Arrays must be declared in the C syntax, using square brackets for each
.br
   dimension. For example, a local string array must be declared like this:
.br
   'LOCAL array$[5]'. Two-dimensional arrays are written like 'array[5][5]',
.br
   three-dimensional arrays like 'array[5][5][5]' and so on.
.br
.SH ""
   In BaCon, static numeric arrays can have all dimensions, but static string
.br
   arrays cannot have more than one dimension.
.br
.SH ""
.SS "  Declaration of dynamic arrays"
.SH ""
   Also dynamic arrays must be declared explicitly. To declare a dynamic
.br
   array, the statements GLOBAL or LOCAL must be used together with the ARRAY
.br
   keyword, which determines the amount of elements. For example, to declare
.br
   a dynamic array of 5 integer elements: 'LOCAL array TYPE int ARRAY 5'.
.br
.SH ""
   The difference with a static array is that the size of a dynamic array can
.br
   declared using variables, and that their size can be redimensioned during
.br
   runtime. The latter can be achieved with the REDIM statement. This is only
.br
   possible for arrays with one dimension.
.br
.SH ""
   As with static numeric arrays, also dynamic numeric arrays can have all
.br
   dimensions, and dynamic string arrays cannot have more than one dimension.
.br
   The syntax to refer to elements in a dynamic array is the same as the
.br
   syntax for elements in a static array.
.br
.SH ""
.SS "  Dimensions"
.SH ""
   Static arrays must be declared with fixed dimensions, meaning that it is
.br
   not possible to determine the dimensions of an array using variables or
.br
   functions, so during program runtime. The reason for this is that the C
.br
   compiler needs to know the array dimensions during compile time. Therefore
.br
   the dimensions of an array must be defined with fixed numbers or with
.br
   CONST definitions. Also, the size of a static array cannot be changed
.br
   afterwards.
.br
.SH ""
   Dynamic arrays however can be declared with variable dimensions, meaning
.br
   that the size of such an array also can be expressed by a variable.
.br
   Furthermore, the size of a one dimensional dynamic array can be changed
.br
   afterwards with the REDIM statement. This statement also works for
.br
   implicitly created dynamic arrays in the SPLIT and LOOKUP statements.
.br
.SH ""
   By default, if an array is declared with 5 elements, then it means that
.br
   the array elements range from 0 to 4. Element 5 is not part of the array.
.br
   This behavior can be changed using the OPTION BASE statement. If OPTION
.br
   BASE is set to 1, an array declared with 5 elements will have a range from
.br
   1 to 5.
.br
.SH ""
   The UBOUND function returns the dimension of an array. In case of
.br
   multi-dimensional arrays the total amount of elements will be returned.
.br
   The UBOUND function works for static and dynamic arrays, but also for
.br
   associative arrays.
.br
.SH ""
.SS "  Passing arrays to functions or subs"
.SH ""
   In BaCon it is possible to pass one-dimensional arrays to a function or
.br
   sub. The caller should simply use the basename of the array (so without
.br
   mentioning the dimension of the array).
.br
.SH ""
   When the function or sub argument mentions the dimension, a local copy of
.br
   the array is created.
.br
.SH ""
   CONST dim = 2
.br
   DECLARE series[dim] TYPE NUMBER
.br
.SH ""
   SUB demo(NUMBER array[dim])
.br
       array[0] = 987
.br
       array[1] = 654
.br
   END SUB
.br
.SH ""
   series[0] = 123
.br
   series[1] = 456
.br
   demo(series)
.br
   FOR x = 0 TO dim - 1
.br
       PRINT series[x]
.br
   NEXT
.br
.SH ""
   This will print the values originally assigned. The sub does not change
.br
   the original assignments.
.br
.SH ""
   When the function or sub argument does not mention the dimension, but only
.br
   uses square brackets, the array is passed by reference.
.br
.SH ""
   CONST dim = 2
.br
   DECLARE series[dim] TYPE NUMBER
.br
.SH ""
   SUB demo(NUMBER array[])
.br
       array[0] = 987
.br
       array[1] = 654
.br
   END SUB
.br
.SH ""
   series[0] = 123
.br
   series[1] = 456
.br
   demo(series)
.br
   FOR x = 0 TO dim - 1
.br
       PRINT series[x]
.br
   NEXT
.br
.SH ""
   This will modify the original array and prints the values assigned in the
.br
   sub.
.br
.SH ""
.SS "  Returning arrays from functions"
.SH ""
   In BaCon, it is also possible to return a one dimensional array from a
.br
   function. This only works for dynamic arrays, as the static arrays always
.br
   use the stack memory assigned to a function. This means, that when a
.br
   function is finished, also the memory for that function is destroyed,
.br
   together with the variables and static arrays in that function. Therefore
.br
   only dynamic arrays can be returned.
.br
.SH ""
   The syntax to return a one dimensional dynamic array involves two steps:
.br
   the declaration of the array must contain the STATIC keyword, and the
.br
   RETURN argument should only contain the basename of the array without
.br
   mentioning the dimensions. For example:
.br
.SH ""
   FUNCTION demo
.br
       LOCAL array TYPE int ARRAY 10 STATIC
.br
       FOR x = 0 TO 9
.br
           array[x] = x
.br
       NEXT
.br
       RETURN array
.br
   END FUNCTION
.br
   DECLARE  my_array  TYPE int  ARRAY  10
.br
   my_array = demo()
.br
.SH ""
   This example will create a dynamic array and assign some initial values,
.br
   after which it is returned from the function. The target 'my_array' now
.br
   will contain the values assigned in the function.
.br
.SH ""
   The statements SPLIT, LOOKUP, COLLECT, PARSE and MAP also accept the
.br
   STATIC keyword, which allows the implicitly created dynamic array
.br
   containing results to be returned from a function.
.br
.SH ""
   Note that when returning arrays, the assigned array should have the same
.br
   dimensions in order to prevent memory errors.
.br
.SH ""
.SH "Associative arrays"
.SH ""
.SS "  Declaration"
.SH ""
   An associative array is an array of which the index is determined by a
.br
   string, instead of a number. Associative arrays use round brackets '(...)'
.br
   instead of the square brackets '[...]' used by normal arrays.
.br
.SH ""
   An associative array can use any kind of string for the index, and it can
.br
   have an unlimited amount of elements. The declaration of associative
.br
   arrays therefore never mentions the range.
.br
.SH ""
   To declare an associative array, the following syntax applies:
.br
.SH ""
   DECLARE info ASSOC  int
.br
.SH ""
   This declares an array containing integer values. To assign a value, using
.br
   a random string "abcd" as example:
.br
.SH ""
   info("abcd") = 1
.br
.SH ""
   Similarly, an associative array containing other types can be declared,
.br
   for example strings:
.br
.SH ""
   DECLARE txt$ ASSOC STRING
.br
.SH ""
   As with other variables, declaring associative arrays within a function
.br
   using LOCAL will ensure a local scope of the array.
.br
.SH ""
   An associative array can have any amount of dimension. The indexes in an
.br
   associative array should be separated by a comma. For example:
.br
.SH ""
   DECLARE demo$  ASSOC STRING
.br
   demo$("one") = "hello"
.br
   demo$("one", "two") = "world"
.br
.SH ""
   Alternatively, the indexes also can be specified in a delimited string
.br
   format, using a single space as delimiter:
.br
.SH ""
   demo$("one two") = "world"
.br
.SH ""
   Note that the OPTION BASE statement has no impact on associative arrays.
.br
   Also note that an associative array cannot be part of a RECORD structure.
.br
.SH ""
   For the index, it is also possible to use the STR$ function to convert
.br
   numbers or numerical variables to strings:
.br
.SH ""
   PRINT txt$(STR$(123))
.br
.SH ""
.SS "  Relations, lookups, keys"
.SH ""
   In BaCon, it is possible to setup relations between associative arrays of
.br
   the same type. This may be convenient when multiple arrays with the same
.br
   index need to be set at once. To setup a relation the RELATE keyword can
.br
   be used, e.g:
.br
.SH ""
   RELATE assoc TO other
.br
.SH ""
   Now for each index in the array 'assoc', the same index in the array
.br
   'other' is set. It also is possible to copy the contents of one
.br
   associative array to another. This can simply be done by using the
.br
   assignment operator, as follows:
.br
.SH ""
   array$() = other$()
.br
.SH ""
   Next to this, the actual index names in an associative array can be looked
.br
   up using the LOOKUP statement. This statement returns a dynamically
.br
   created array containing all string indexes. The size of the resulting
.br
   array is dynamically declared as it depends on the amount of available
.br
   elements. Instead of creating a dynamic array, it is also possible to
.br
   return the indexes of an associative array into a delimited string by
.br
   using the function OBTAIN$.
.br
.SH ""
   To find out if a key already was defined in the associative array, the
.br
   function ISKEY can be used. This function needs the array name and the
.br
   string containing the index name, and will return either TRUE or FALSE,
.br
   depending on whether the index is defined (TRUE) or not (FALSE).
.br
.SH ""
   The function NRKEYS will return the amount of members in an associative
.br
   array.
.br
.SH ""
   Deleting individual associative array members can be done by using the
.br
   FREE statement. This will leave the associative array insertion order
.br
   intact. The FREE statement also can be used to delete a full associative
.br
   array in one step.
.br
.SH ""
   The function INDEX$ allows looking up a specific key based on value. The
.br
   function INVERT can swap the keys and values of an associative array. The
.br
   SORT statement also can sort associative arrays based on their value,
.br
   effectively changing the insertion order in the underlying hash table.
.br
.SH ""
.SS "  Basic logic programming"
.SH ""
   With the current associative array commands it is possible to perform
.br
   basic logic programming. Consider the following Logic program which can be
.br
   executed with any Prolog implementation:
.br
.SH ""
   mortal(X) :- human(X).
.br
.SH ""
   human(socrates).
.br
   human(sappho).
.br
   human(august).
.br
.SH ""
   mortals_are:
.br
       write('Mortals are:'),
.br
       mortal(X),
.br
       write(X),
.br
       fail.
.br
.SH ""
   The following BaCon program does the same thing:
.br
.SH ""
   DECLARE human, mortal ASSOC int
.br
   RELATE human TO mortal
.br
.SH ""
   human("socrates") = TRUE
.br
   human("sappho") = TRUE
.br
   human("august") = TRUE
.br
.SH ""
   PRINT "Mortals are:"
.br
   LOOKUP mortal TO member$ SIZE amount
.br
   FOR x = 0 TO amount - 1
.br
       PRINT member$[x]
.br
   NEXT
.br
.SH ""
.SH "Records"
.SH ""
.SS "  Declaration"
.SH ""
   Records are collections of variables which belong together. A RECORD has a
.br
   name by itself and members of the record can be accessed by using the
.br
   <name>.<member> notation. The members should be declared using the LOCAL
.br
   statement. For example:
.br
.SH ""
   RECORD rec
.br
       LOCAL value
.br
       LOCAL nr[5]
.br
   END RECORD
.br
   rec.value = 99
.br
.SH ""
   As soon a record is created, it also exists as a type. The name of the
.br
   type always consists of the record name followed by the '_type' suffix.
.br
   From then on, it is possible to declare other variables as being of the
.br
   same type. To continue with the same example:
.br
.SH ""
   DECLARE var TYPE rec_type
.br
   var.value = 123
.br
.SH ""
.SS "  Arrays of records"
.SH ""
   Record definitions also can be created as static arrays or as dynamic
.br
   arrays. The size of the static array is determined during compile time and
.br
   the data will be stored in the stack frame of a SUB or FUNCTION. This
.br
   means that the array data is lost when the SUB or FUNCTION is ended.
.br
   Example of a static array definition:
.br
.SH ""
   RECORD data[10]
.br
       LOCAL info$
.br
   END RECORD
.br
.SH ""
   To declare a dynamic array of records, the keyword ARRAY must be used. The
.br
   size of a dynamic record array is determined during runtime, and
.br
   therefore, can be set with variables and functions. The data is stored in
.br
   the heap. The BaCon memory management will clean up the data when leaving
.br
   a FUNCTION or SUB. Example:
.br
.SH ""
   RECORD data ARRAY 10
.br
       LOCAL name$[5]
.br
       LOCAL age[5]
.br
   END RECORD
.br
.SH ""
   Note that dynamic arrays of records do not allow members which are dynamic
.br
   arrays themselves.
.br
.SH ""
.SS "  Passing records to functions or subs"
.SH ""
   To pass a record, simply declare the variable name with the appropriate
.br
   record type in the header of the function or sub. Example code:
.br
.SH ""
   RECORD rec
.br
       LOCAL nr
.br
       LOCAL area$
.br
   END RECORD
.br
.SH ""
   SUB subroutine(rec_type var)
.br
       PRINT var.nr
.br
       PRINT var.area$
.br
   ENDSUB
.br
   rec.nr = 123
.br
   rec.area$ = "europe"
.br
   CALL subroutine(rec)
.br
.SH ""
   Similarly, it is possible to pass an array of records as well. Note the
.br
   square brackets in the function header:
.br
.SH ""
   RECORD rec ARRAY 10
.br
       LOCAL nr
.br
       LOCAL area$
.br
   END RECORD
.br
.SH ""
   SUB subroutine(rec_type var[])
.br
       PRINT var[0].nr
.br
       PRINT var[0].area$
.br
   ENDSUB
.br
   rec[0].nr = 123
.br
   rec[0].area$ = "europe"
.br
   CALL subroutine(rec)
.br
.SH ""
.SS "  Returning records from functions"
.SH ""
   In order to return a record from a function, the record type must be
.br
   visible to the caller. The below example declares the record in the main
.br
   program. The function declares a variable of the same type and initializes
.br
   the record to 0. This initialization is obligatory for string members to
.br
   work properly. Then some values are assigned. Lastly, the complete record
.br
   is returned to the caller:
.br
.SH ""
   RECORD rec
.br
       LOCAL id
.br
       LOCAL zip$[2]
.br
   END RECORD
.br
.SH ""
   FUNCTION  func TYPE  rec_type
.br
       LOCAL  var = { 0 } TYPE  rec_type
.br
       var.id = 1
.br
       var.zip$[0] = "XJ342"
.br
       var.zip$[1] = "YP198"
.br
       RETURN  var
.br
   ENDFUNCTION
.br
   rec = func()
.br
   PRINT  rec.id
.br
   PRINT  rec.zip$[0]
.br
   PRINT  rec.zip$[1]
.br
.SH ""
.SH "Strings by value or by reference"
.SH ""
   Strings can be stored by value or by reference. By value means that a copy
.br
   of the original string is stored in a variable. This happens automatically
.br
   when when a string variable name ends with the '$' symbol.
.br
.SH ""
   Sometimes it may be necessary to refer to a string by reference. In such a
.br
   case, simply declare a variable name as STRING but omit the '$' at the
.br
   end. Such a variable will point to the same memory location as the
.br
   original string. The following examples should show the difference between
.br
   by value and by reference.
.br
.SH ""
   When using string variables by value:
.br
.SH ""
   a$ = "I am here"
.br
   b$ = a$
.br
   a$ = "Hello world..."
.br
   PRINT a$, b$
.br
.SH ""
   This will print "Hello world...I am here". The variables point to their
.br
   individual memory areas so they contain different strings. Now consider
.br
   the following code:
.br
.SH ""
   a$ = "Hello world..."
.br
   LOCAL b TYPE STRING
.br
   b = a$
.br
   a$ = "Goodbye..."
.br
   PRINT a$, b FORMAT "%s%s\\n"
.br
.SH ""
   This will print "Goodbye...Goodbye..." because the variable 'b' points to
.br
   the same memory area as 'a$'. (The optional FORMAT forces the variable 'b'
.br
   to be printed as a string, otherwise BaCon assumes that the variable 'b'
.br
   contains a value.)
.br
.SH ""
   Note that as soon an existing string variable is referred to by a
.br
   reference variable, the string will not profit from the optimized high
.br
   performance string engine anymore.
.br
.SH ""
.SH "ASCII, Unicode, UTF8"
.SH ""
   BaCon is a byte oriented converter. This means it always will assume that
.br
   a string consists of a sequence of ASCII bytes. Though this works fine for
.br
   plain ASCII strings, it will cause unexpected results in case of non-Latin
.br
   languages, like Chinese or Cyrillic. However, BaCon supports UTF8 encoded
.br
   strings also.
.br
.SH ""
   The original text already may contain the UTF8 byte order mark 0xEF 0xBB
.br
   0xBF. The function HASBOM can be used to detect if such byte order mark is
.br
   present. To add or delete a byte order mark, use EDITBOM$.
.br
.SH ""
   In order to work with UTF8 strings, OPTION UTF8 needs to be enabled. This
.br
   option will put all string related functions in UTF8 mode at the cost of
.br
   some performance loss in string processing.
.br
.SH ""
   Next to this option, BaCon also provides a few functions which relate to
.br
   UTF8 encoding. The following functions work independently from OPTION
.br
   UTF8:
.br
.SH ""
     * ULEN will correctly calculate the actual characters based on the
.br
       binary UTF8 sequence.
.br
.SH ""
     * BYTELEN will show the actual amount of bytes used by a UTF8 string.
.br
.SH ""
     * ISASCII can be used to verify if a string only consists of ASCII data.
.br
.SH ""
     * UTF8$ needs the Unicode value as argument and returns the
.br
       corresponding character depending on environment settings and the
.br
       current font type.
.br
.SH ""
     * UCS needs a UTF8 character as an argument and returns the
.br
       corresponding Unicode value.
.br
.SH ""
     * ESCAPE$ will convert a UTF8 string to an ASCII sequence with escape
.br
       characters.
.br
.SH ""
     * UNESCAPE$ will convert an ASCII sequence with escaped characters back
.br
       to valid UTF8.
.br
.SH ""
     * HASBOM will detect if the UTF8 byte order mark is present in the text
.br
.SH ""
     * EDITBOM$ can be used to add or delete a UTF8 byte order mark
.br
.SH ""
.SH "Binary trees"
.SH ""
   BaCon has a built-in API for binary trees. Compared to arrays, a binary
.br
   tree is a data structure which can access its elements in a faster and
.br
   more efficient manner. Regular arrays store an element in a linear way,
.br
   which, in worst case, can end up in long sequential lookup times. A binary
.br
   tree however uses an internal decision tree to lookup an element, of which
.br
   the lookup time, depending on the tree position, is logarithmic.
.br
.SH ""
   A typical application using a binary tree is a database, which needs to
.br
   lookup information from a large amount of data. A search in a binary tree
.br
   will be a lot faster compared to a plain linear search in a regular array.
.br
.SH ""
   To declare a binary tree, BaCon uses the DECLARE or LOCAL keyword together
.br
   with TREE. For example, to declare a binary tree containing strings:
.br
.SH ""
   DECLARE mytree TREE  STRING
.br
.SH ""
   Subsequently, it is possible to declare other types as well, for example
.br
   integers or floats:
.br
.SH ""
   DECLARE myinttree TREE  int
.br
   DECLARE  myfloattree  TREE  float
.br
.SH ""
   After the declaration, new values (nodes) can be added to the tree. Adding
.br
   a string is very straightforward. It can be added to a binary tree using
.br
   the TREE statement:
.br
.SH ""
   TREE mytree ADD "hello"
.br
   text$ = "world"
.br
   TREE mytree ADD text$
.br
.SH ""
   Similarly, to add an integer or float to the binary tree:
.br
.SH ""
   TREE myinttree ADD 567
.br
   TREE myfloattree ADD 4.127
.br
.SH ""
   When adding a duplicate string or value nothing happens. Such attempt will
.br
   silently be ignored. As a result, all entries in a binary tree are unique.
.br
.SH ""
   The FIND function can lookup the presence of an element. If found, the
.br
   FIND function will return TRUE (1), otherwise it will return FALSE (0).
.br
   The following example looks up a string in a binary tree:
.br
.SH ""
   IF FIND(mytree, "abc") THEN PRINT "Found!"
.br
.SH ""
   Similarly it is possible to lookup an integer or float value:
.br
.SH ""
   result = FIND(myfloattree, 2.2)
.br
   var = 123
.br
   result = FIND(myinttree, var)
.br
.SH ""
   It is also possible to remove an element from the tree using the DELETE
.br
   statement. If an element is not found then nothing happens:
.br
.SH ""
   DELETE result$ FROM mytree
.br
   DELETE 1.2 FROM myfloattree
.br
.SH ""
   The COLLECT statement can collect all the strings or values of all nodes
.br
   in the binary tree and put them into a regular array:
.br
.SH ""
   COLLECT mytree TO allnodes$
.br
   COLLECT myinttree TO  intnodes
.br
.SH ""
   Lastly, the function TOTAL can be used to find out the total amount of
.br
   elements in a binary tree:
.br
.SH ""
   PRINT  "Amount of nodes:",  TOTAL(mytree)
.br
.SH ""
.SH "Creating and linking to libraries created with BaCon"
.SH ""
   With Bacon, it is possible to create libraries. In the world of Unix these
.br
   are known as shared objects. The following steps should explain how to
.br
   create and link to BaCon libraries.
.br
.SH ""
.SS "  Step 1: create a library"
.SH ""
   The below program only contains a function, which accepts one argument and
.br
   returns a value.
.br
.SH ""
   FUNCTION bla (NUMBER n)
.br
       LOCAL i
.br
       i = 5 * n
.br
       RETURN i
.br
   END FUNCTION
.br
.SH ""
   In this example, the program will be saved as 'libdemo.bac'. Note that the
.br
   name must begin with the prefix 'lib'. This is a Unix convention. The
.br
   linker will search for library names starting with these three letters.
.br
.SH ""
.SS "  Step 2: compile the library"
.SH ""
   The program must be compiled using the '-f' flag: bacon -f libdemo.bac
.br
.SH ""
   This will create a file called 'libdemo.so'.
.br
.SH ""
.SS "  Step 3: copy library to a system path"
.SH ""
   To use the library, it must be located in a place which is known to the
.br
   linker. There are several ways to achieve this. For sake of simplicity, in
.br
   this example the library will be copied to a system location. It is common
.br
   usage to copy additional libraries to '/usr/local/lib': sudo cp libdemo.so
.br
   /usr/local/lib
.br
.SH ""
.SS "  Step 4: update linker cache"
.SH ""
   The linker now must become aware that there is a new library. Update the
.br
   linker cache with the following command: sudo ldconfig
.br
.SH ""
.SS "  Step 5: demonstration program"
.SH ""
   The following program uses the function from the new library:
.br
.SH ""
   PROTO bla
.br
   x = 5
.br
   result = bla(x)
.br
   PRINT result
.br
.SH ""
   This program first declares the function 'bla' as prototype, so the BaCon
.br
   parser will not choke on this external function. Then the external
.br
   function is invoked and the result is printed on the screen.
.br
.SH ""
.SS "  Step 6: compile and link"
.SH ""
   Now the program must be compiled with reference to the library created
.br
   before. This can be done as follows: ./bacon -l demo program.bac
.br
.SH ""
   With the Unix command 'ldd' it will be visible that the resulting binary
.br
   indeed has a dependency with the new library.
.br
.SH ""
   When executed, the result of this program should show 25.
.br
.SH ""
.SS "  Remarks"
.SH ""
   In case global dynamic string arrays are used by the BaCon shared object,
.br
   then these need to be initialized prior to using the arrays. This can be
.br
   done by calling a special function available in each shared object created
.br
   in BaCon: the 'BaCon_init()' function. In case the shared object is
.br
   compiled by a GNU C compatible compiler, then this function is executed
.br
   automatically.
.br
.SH ""
.SH "Creating internationalization files"
.SH ""
   It is possible to create internationalized strings for a BaCon program. In
.br
   order to do so, OPTION INTERNATIONAL should be enabled in the beginning of
.br
   the program. After this, make sure that each translatable string is
.br
   surrounded by the INTL$ or NNTL$ function.
.br
.SH ""
   Now start BaCon and use the '-x' option. This will generate a template for
.br
   the catalog file, provided that the 'xgettext' utility is available on
.br
   your platform. The generated template by default has the same name as your
.br
   BaCon program, but with a '.pot' extension.
.br
.SH ""
   Then proceed with the template file and fill in the needed translations,
.br
   create the PO file as usual and copy the binary formatted catalog to the
.br
   base directory of the catalog files (default: "/usr/share/locale").
.br
.SH ""
   The default textdomain and base directory can be changed with the
.br
   TEXTDOMAIN statement.
.br
.SH ""
   Below a complete sequence of steps creating internationalization files.
.br
   Make sure the GNU gettext utilities are installed.
.br
.SH ""
.SS "  Step 1: create program"
.SH ""
   The following simple program should be translated:
.br
.SH ""
   OPTION INTERNATIONAL TRUE
.br
   PRINT INTL$("Hello cruel world!")
.br
   x = 2
.br
   PRINT x FORMAT NNTL$("There is %ld green bottle", "There are %ld green
.br
   bottles", x)
.br
.SH ""
   This program is saved as 'hello.bac'.
.br
.SH ""
.SS "  Step 2: compile program"
.SH ""
   Now compile the program using the '-x' option.
.br
.SH ""
   # bacon -x hello.bac
.br
.SH ""
   Next to the resulting binary, a template catalog file is created called
.br
   'hello.pot'.
.br
.SH ""
.SS "  Step 3: create catalog file"
.SH ""
   At the command line prompt, run the 'msginit' utility on the generated
.br
   template file.
.br
.SH ""
   # msginit -l nl_NL -o hello.po -i hello.pot
.br
.SH ""
   In this example, the nl_NL locale is used, which is Dutch. This will
.br
   create a genuine catalog file called 'hello.po' from the template
.br
   'hello.pot'.
.br
.SH ""
.SS "  Step 4: add translations"
.SH ""
   Edit the catalog file 'hello.po' manually, by adding the necessary
.br
   translations.
.br
.SH ""
.SS "  Step 5: create object file"
.SH ""
   Again at the command line prompt, run the 'msgfmt' utility to convert the
.br
   catalog file to a binary machine object file. The result will have the
.br
   same name but with an '.mo' extension:
.br
.SH ""
   # msgfmt -c -v -o hello.mo hello.po
.br
.SH ""
.SS "  Step 6: install"
.SH ""
   Copy the resulting binary formatted catalog file 'hello.mo' into the
.br
   correct locale directory. In this example, the locale used was 'nl_NL'.
.br
   Therefore, it needs to be copied to the default textdomain directory
.br
   '/usr/share/locale' appended with the locale name, thus:
.br
   /usr/share/locale/nl_NL. In there, the subdirectory LC_MESSAGES should
.br
   contain the binary catalog file.
.br
.SH ""
   # cp hello.mo /usr/share/locale/nl_NL/LC_MESSAGES/
.br
.SH ""
   The TEXTDOMAIN statement can be used to change the default directory for
.br
   the catalog files.
.br
.SH ""
.SS "  Step 7: setup Unix environment"
.SH ""
   Finally, the Unix environment needs to understand that the correct locale
.br
   must be used. To do so, simply set the LANG environment variable to the
.br
   desired locale.
.br
.SH ""
   # export LANG=nl_NL
.br
.SH ""
   After this, the BaCon program will show the translated strings.
.br
.SH ""
.SH "Networking"
.SH ""
.SS "  TCP"
.SH ""
   Using BaCon, it is possible to create programs which have access to TCP
.br
   networking. The following small demonstration shows a client program which
.br
   fetches a website over HTTP:
.br
.SH ""
   OPEN "www.basic-converter.org:80" FOR NETWORK AS mynet
.br
   SEND "GET / HTTP/1.1\\r\\nHost: www.basic-converter.org\\r\\n\\r\\n" TO mynet
.br
   REPEAT
.br
       RECEIVE dat$ FROM mynet
.br
       total$ = total$ & dat$
.br
   UNTIL ISFALSE(WAIT(mynet, 5000))
.br
   CLOSE NETWORK mynet
.br
   PRINT total$
.br
.SH ""
   The following program verifies if a remote site can be reached by a
.br
   specific port, trying to access it via a specific interface on the
.br
   localhost:
.br
.SH ""
   CATCH GOTO Error
.br
   OPEN "www.basic-converter.org:443" FOR NETWORK FROM "192.168.1.107" AS net
.br
   PRINT "The host 'basic-converter.org' listens at port 443."
.br
   CLOSE NETWORK net
.br
   END
.br
   LABEL Error
.br
       PRINT "The host 'basic-converter.org' either is not reachable,
.br
   filtered or has port 443 not open."
.br
.SH ""
   The next program shows how to setup a simple TCP server. The main program
.br
   uses OPEN FOR SERVER after which the ACCEPT function handles the incoming
.br
   connection:
.br
.SH ""
   PRINT "Connect from other terminals with 'telnet localhost 51000' and
.br
   enter text - 'quit' ends."
.br
   OPEN "localhost:51000" FOR  SERVER  AS mynet
.br
   WHILE TRUE
.br
       fd = ACCEPT(mynet)
.br
       REPEAT
.br
           RECEIVE dat$ FROM fd
.br
           PRINT "Found: ", dat$;
.br
       UNTIL LEFT$(dat$, 4)  = "quit"
.br
       CLOSE SERVER fd
.br
   WEND
.br
.SH ""
.SS "  UDP"
.SH ""
   The UDP mode can be set with the OPTION NETWORK statement. After this, a
.br
   network program for UDP looks the same as a network program for TCP. This
.br
   is an example client program:
.br
.SH ""
   OPTION NETWORK UDP
.br
   OPEN "localhost:1234" FOR NETWORK AS mynet
.br
   SEND "Hello" TO mynet
.br
   CLOSE NETWORK mynet
.br
.SH ""
   Example server program:
.br
.SH ""
   OPTION NETWORK UDP
.br
   OPEN "localhost:1234" FOR SERVER AS mynet
.br
   RECEIVE dat$ FROM mynet
.br
   CLOSE SERVER mynet
.br
   PRINT dat$
.br
.SH ""
.SS "  BROADCAST"
.SH ""
   BaCon also knows how to send data in UDP broadcast mode. For example:
.br
.SH ""
   OPTION NETWORK BROADCAST
.br
   OPEN "192.168.1.255:12345" FOR NETWORK AS mynet
.br
   SEND "Using UDP broadcast" TO mynet
.br
   CLOSE NETWORK mynet
.br
.SH ""
   Example server program using UDP broadcast, listening to all interfaces:
.br
.SH ""
   OPTION NETWORK BROADCAST
.br
   OPEN "*:12345" FOR SERVER AS mynet
.br
   RECEIVE dat$ FROM mynet
.br
   CLOSE SERVER mynet
.br
   PRINT dat$
.br
.SH ""
.SS "  MULTICAST"
.SH ""
   If UDP multicast is required then simply specify MULTICAST. Optionally,
.br
   the TTL can be determined also. Here are the same examples, but using a
.br
   multicast address with a TTL of 5:
.br
.SH ""
   OPTION NETWORK MULTICAST 5
.br
   OPEN "225.2.2.3:1234" FOR NETWORK AS mynet
.br
   SEND "This is UDP multicast" TO mynet
.br
   CLOSE NETWORK mynet
.br
.SH ""
   Example server program using multicast:
.br
.SH ""
   OPTION NETWORK MULTICAST
.br
   OPEN "225.2.2.3:1234" FOR SERVER AS mynet
.br
   RECEIVE dat$ FROM mynet
.br
   CLOSE SERVER mynet
.br
   PRINT dat$
.br
.SH ""
.SS "  SCTP"
.SH ""
   BaCon also supports networking using the SCTP protocol. Optionally, a
.br
   value for the amount of streams within one association can be specified.
.br
.SH ""
   OPTION NETWORK SCTP 5
.br
   OPEN "127.0.0.1:12380", "172.17.130.190:12380" FOR NETWORK AS mynet
.br
   SEND "Hello world" TO mynet
.br
   CLOSE NETWORK mynet
.br
.SH ""
   An example server program:
.br
.SH ""
   OPTION NETWORK SCTP 5
.br
   OPEN "127.0.0.1:12380", "172.17.130.190:12380" FOR SERVER AS mynet
.br
   RECEIVE txt$ FROM mynet
.br
   CLOSE SERVER mynet
.br
   PRINT txt$
.br
.SH ""
.SH "TLS secured network connections"
.SH ""
   The previous chapter demonstrated network connections where the data is
.br
   transferred over the wire in plain text. However, with the increasing
.br
   vulnerabilities in current network traffic, it usually is a good idea to
.br
   apply Transport Layer Security (TLS).
.br
.SH ""
   BaCon does not implement a propriety TLS standard by its own. However, it
.br
   can make use of existing libraries like OpenSSL. Alternatively, BaCon also
.br
   allows other TLS implementations, in case these provide an OpenSSL
.br
   compatible API. Examples are the GnuTLS and WolfSSL libraries but also
.br
   projects forking from OpenSSL, like BoringSSL and LibreSSL.
.br
.SH ""
   To enable TLS, simply add OPTION TLS to the program. From then on, new
.br
   network connections are considered to be TLS encapsulated:
.br
.SH ""
   OPTION TLS TRUE
.br
.SH ""
   This option enables the usage of OpenSSL by default. The presence of the
.br
   OpenSSL libraries and header files on the system is required. BaCon will
.br
   try to convert the source program and assumes the default locations of the
.br
   OpenSSL development files. However, if these reside at a different
.br
   location, it is possible to specify their location as follows:
.br
.SH ""
   PRAGMA TLS openssl INCLUDE <openssl/ssl.h> LDFLAGS -lssl -lcrypto
.br
.SH ""
   The OPTION TLS statement is always required, but instead of OpenSSL, it is
.br
   possible to specify a different library:
.br
.SH ""
   PRAGMA TLS  gnutls
.br
.SH ""
   This will provide an indication that BaCon should make use of the
.br
   development files from the GnuTLS implementation. If these files should be
.br
   taken from a special location:
.br
.SH ""
   PRAGMA TLS  gnutls INCLUDE  <gnutls/openssl.h> LDFLAGS  -lgnutls
.br
   -lgnutls-openssl
.br
.SH ""
   Lastly, BaCon supports WolfSSL as well:
.br
.SH ""
   PRAGMA TLS  wolfssl
.br
.SH ""
   Also for the WolfSSL library it is possible to specify the location of the
.br
   development files:
.br
.SH ""
   PRAGMA TLS wolfssl INCLUDE <wolfssl/options.h> <wolfssl/openssl/ssl.h>
.br
   LDFLAGS -lwolfssl
.br
.SH ""
   BaCon can use the function CA$ to discover the certificate authority of
.br
   the connection, and CN$ to discover the common name. The CIPHER$ function
.br
   can be used to obtain details on the encryption and the VERIFY function to
.br
   verify the validity of the certificate.
.br
.SH ""
   The following small program queries a Mac address API over TLS using
.br
   default OpenSSL:
.br
.SH ""
   OPTION TLS TRUE
.br
   website$ = "api.macvendors.com"
.br
   mac$ = "b0:52:16:d0:3c:fb"
.br
   OPEN website$ & ":443" FOR NETWORK AS mynet
.br
   SEND "GET /" & mac$ & " HTTP/1.1\\r\\nHost: " & website$ & "\\r\\n\\r\\n" TO
.br
   mynet
.br
   RECEIVE info$ FROM mynet
.br
   CLOSE NETWORK mynet
.br
   PRINT TOKEN$(info$, 2, "\\r\\n\\r\\n")
.br
.SH ""
   The next program shows how to setup a simple webserver using TLS:
.br
.SH ""
   OPTION TLS TRUE
.br
   CERTIFICATE "key.pem", "certificate.pem"
.br
   CATCH GOTO resume_on_error
.br
   CONST Msg$ = "<html><head>Hello from BaCon!</head></html>"
.br
   PRINT "Connect with your browser to 'https://localhost:51000'."
.br
   OPEN "localhost:51000" FOR SERVER AS mynet
.br
   WHILE TRUE
.br
       client = ACCEPT(mynet)
.br
       IF client < 0 THEN CONTINUE
.br
       RECEIVE dat$ FROM client
.br
       PRINT dat$
.br
       SEND "HTTP/1.1 200 Ok\\r\\nContent-Length: " & STR$(LEN(Msg$)) &
.br
   "\\r\\n\\r\\n" & Msg$ TO client
.br
       CLOSE SERVER client
.br
   WEND
.br
   LABEL resume_on_error
.br
       RESUME
.br
.SH ""
   The program below demonstrates a plain HTTPS connection using GnuTLS:
.br
.SH ""
   OPTION TLS TRUE
.br
   PRAGMA TLS gnutls INCLUDE <gnutls/openssl.h> LDFLAGS  -lgnutls
.br
   -lgnutls-openssl
.br
   website$ = "www.google.com"
.br
   OPEN website$ & ":443" FOR NETWORK AS mynet
.br
   SEND "GET / HTTP/1.1\\r\\nHost: " & website$ & "\\r\\n\\r\\n" TO mynet
.br
   WHILE WAIT(mynet, 2000)
.br
       RECEIVE data$ FROM mynet
.br
       total$ = total$ & data$
.br
       IF REGEX(data$, "</html>") THEN BREAK
.br
   WEND
.br
   PRINT REPLACE$(total$, "\\r\\n[0-9a-fA-F]+\\r\\n", "\\r\\n", TRUE)
.br
   PRINT "--------------------------"
.br
   PRINT CIPHER$(mynet)
.br
   PRINT CA$(mynet)
.br
   PRINT CN$(mynet)
.br
   PRINT VERIFY(mynet, pem_file_with_rootca$)
.br
   PRINT "--------------------------"
.br
   CLOSE NETWORK mynet
.br
.SH ""
.SH "Ramdisks and memory streams"
.SH ""
   When creating programs which need heavy I/O towards the hard drive, it may
.br
   come handy to create a ramdisk for performance reasons. Basically, a
.br
   ramdisk is a storage in memory. While on Unix level administrator rights
.br
   are required to create such a disk, BaCon can create an elementary ramdisk
.br
   during runtime which is accessible within the program.
.br
.SH ""
   First, some amount of memory needs to be claimed which has to be opened in
.br
   streaming mode. This returns a memory pointer which indicates the current
.br
   position in memory, similar to a file pointer for files.
.br
.SH ""
   Then, the statements GETLINE and PUTLINE can be used to read and write
.br
   lines of data towards the memory storage. For example:
.br
.SH ""
   memory_chunk = MEMORY(1000)
.br
   OPEN memory_chunk FOR MEMORY AS ramdisk
.br
   PUTLINE "Hello world" TO ramdisk
.br
.SH ""
   If the ramdisk needs to be read from the beginning, use MEMREWIND to
.br
   reposition the memory pointer. In the next example, a GETLINE retrieves
.br
   the line which was stored there:
.br
.SH ""
   MEMREWIND ramdisk
.br
   GETLINE text$ FROM ramdisk
.br
.SH ""
   If the option MEMSTREAM was set to TRUE, BaCon can treat the created
.br
   ramdisk also as a string variable, which allows manipulations by using the
.br
   standard string functions. The variable used for the memory pointer must
.br
   be a string variable:
.br
.SH ""
   OPTION MEMSTREAM TRUE
.br
   memory_chunk = MEMORY(1000)
.br
   OPEN memory_chunk FOR MEMORY AS ramdisk$
.br
   PUTLINE "Hello world" TO ramdisk$
.br
   MEMREWIND ramdisk$
.br
   IF INSTR(ramdisk$, "world") THEN PRINT "found!
.br
   PRINT REPLACE$(ramdisk$, "Hello", "Goodbye")
.br
.SH ""
   Always make sure that there is enough memory to perform string changes to
.br
   the ramdisk. The RESIZE statement safely can be used to enlarge the
.br
   claimed memory during runtime, as this will preserve the data.
.br
.SH ""
   The contents of the ramdisk can be written to disk using PUTBYTE. However,
.br
   it must be clear how many bytes need to be written, as the total amount of
.br
   memory reserved to the ramdisk may be bigger than the actual amount of
.br
   data. The function MEMTELL can be used in case the memory pointer is
.br
   positioned at the end of the ramdisk:
.br
.SH ""
   memory_chunk = MEMORY(1000)
.br
   OPEN memory_chunk FOR MEMORY AS ramdisk
.br
       PUTLINE "Hello world" TO ramdisk
.br
       OPEN "ramdisk.txt" FOR WRITING AS txtfile
.br
           PUTBYTE memory_chunk TO txtfile CHUNK
.br
   MEMTELL(ramdisk)-memory_chunk
.br
       CLOSE FILE txtfile
.br
   CLOSE MEMORY ramdisk
.br
   FREE memory_chunk
.br
.SH ""
   Alternatively, if the ramdisk was opened with OPTION MEMSTREAM set to
.br
   TRUE, the string function LEN also will return the length of the data.
.br
.SH ""
.SH "Delimited strings"
.SH ""
   A delimited string is a string which can be cut into parts, based on a
.br
   character or on a set of characters. An example of such a string is a
.br
   plain space delimited line in a textbook, where the words are separated by
.br
   a whitespace. Another example is an ASCII file, in which the lines are
.br
   separated by a newline. A very famous example of a delimited string is the
.br
   Comma Separated Value (CSV) string. From another point of view, a
.br
   delimited string also can be looked at as a list of items, which is the
.br
   basis of LISP like languages.
.br
.SH ""
   The SPLIT statement can be used to split a string into elements of an
.br
   array, based on a delimiter. As with all statements and functions handling
.br
   delimited strings, the SPLIT statement will ignore a delimiter when it
.br
   occurs between double quotes. Such delimiter is considered to be part of
.br
   the string. For example:
.br
.SH ""
   csv$ = "This,is,a,CSV,string,\\"with,an\\",escaped,delimiter"
.br
   SPLIT csv$ BY "," TO member$ SIZE x
.br
.SH ""
   One of the resulting members of the array will contain "with,an" because
.br
   the comma is enclosed within double quotes. BaCon will consider this a
.br
   piece of text where the characters should be kept together. The behavior
.br
   of skipping delimiters within double quotes can be changed by setting or
.br
   unsetting OPTION QUOTED. The JOIN statement can be used to merge array
.br
   elements back into one (delimited) string.
.br
.SH ""
   Instead of SPLIT, it is possible to use FOR..IN as well. This statement
.br
   will subsequently return the parts of the delimited text into a variable.
.br
   Example:
.br
.SH ""
   FOR i$ IN "aa bb cc"
.br
.SH ""
   In this example, the variable 'i$' will subsequently have the value 'aa',
.br
   'bb' and 'cc' assigned. Also the FOR statement will skip a delimiter
.br
   occurring within double quotes. Note that the OPTION COLLAPSE will prevent
.br
   empty results, both for SPLIT and FOR.
.br
.SH ""
   It is also possible to return a single member in a delimited string. This
.br
   can be achieved with the TOKEN$ function. Note that all element counting
.br
   is 1-based. The following returns the 5^th member of a space delimited
.br
   string, being "e f". It does not use an optional third parameter, because
.br
   for all delimited string processing, BaCon defines the default delimiter
.br
   as a single space:
.br
.SH ""
   PRINT TOKEN$("a b c d \\"e f\\" g h i j", 5)
.br
.SH ""
   But this function also works in case some other delimiter is used. The
.br
   delimiter must then be specified in the third optional argument.
.br
.SH ""
   PRINT TOKEN$("1,2,3,4,5", 3, ",")
.br
.SH ""
   All the functions handling delimited strings accept such an optional
.br
   argument. Alternatively, OPTION DELIM can define the delimiter string
.br
   which should be used in subsequent functions. As mentioned, the default
.br
   value is a single space.
.br
.SH ""
   The function EXPLODE$ will return a delimited string based on a specified
.br
   amount of characters:
.br
.SH ""
   PRINT EXPLODE$("aabbcc", 1)
.br
.SH ""
   Alternatively, the inline loop function COIL$ can create a delimited
.br
   string also, using an optional variable, for example the alphabet:
.br
.SH ""
   PRINT COIL$(i, 26, CHR$(64+i))
.br
.SH ""
   The MERGE$ function will do the opposite: merging the elements of a
.br
   delimited string to one regular string, again optionally specifying a
.br
   delimiter, for example:
.br
.SH ""
   PRINT MERGE$("aa,bb,cc", ",")
.br
.SH ""
   The ISTOKEN function can verify if a text occurs as a token in a delimited
.br
   string. If so, this function returns the actual position of the token:
.br
.SH ""
   t$ = "Kiev Amsterdam Lima Moscow Warschau Vienna Paris Madrid Bonn Bern
.br
   Rome"
.br
   PRINT "Is this a token: ", ISTOKEN(t$, "Rome")
.br
.SH ""
   To obtain the first members from a delimited string, the function HEAD$
.br
   can be used:
.br
.SH ""
   PRINT "The first 2 elements: ", HEAD$(t$, 2)
.br
.SH ""
   Similarly, it is possible to get the last elements by using TAIL$:
.br
.SH ""
   PRINT "The last element: ", TAIL$(t$, 1)
.br
.SH ""
   The TAIL$ and HEAD$ functions have their complementary functions in LAST$
.br
   and FIRST$. The following example will show all members of a delimited
.br
   string except the first 2 members:
.br
.SH ""
   PRINT "All except the first 2 elements: ", LAST$(t$, 2)
.br
.SH ""
   The next code shows all members except the last:
.br
.SH ""
   PRINT "All except the last element: ", FIRST$(t$, 1)
.br
.SH ""
   It also is possible to obtain an excerpt using CUT$. The following piece
.br
   of code will get the members from delimited string 't$' starting at
.br
   position 2 and ending at position 4 inclusive:
.br
.SH ""
   PRINT "Some middle members: ", CUT$(t$, 2, 4)
.br
.SH ""
   Instead of fetching a member, BaCon also can change a member in a
.br
   delimited string directly by using the CHANGE$ function:
.br
.SH ""
   result$ = CHANGE$("a,b,c,d,e,f,g,h,i,j", 5, "Ok", ",")
.br
.SH ""
   It is even possible to swap two members in a delimited string with the
.br
   EXCHANGE$ function:
.br
.SH ""
   result$ = EXCHANGE$("a b c d e f g h i j", 5, 4)
.br
.SH ""
   The UNIQ$ function will return a delimited string where all members occur
.br
   only once:
.br
.SH ""
   city$ = "Kiev Lima Moscow \\"New York\\" Warschau \\"New York\\" Rome"
.br
   PRINT "Unique member cities: ", UNIQ$(city$)
.br
.SH ""
   To add more members to a delimited string, use APPEND$:
.br
.SH ""
   t$ = APPEND$(t$, 2, "Santiago")
.br
.SH ""
   And to delete a member from a delimited string, use DEL$:
.br
.SH ""
   t$ = DEL$(t$, 3)
.br
.SH ""
   There are also functions to sort the members in a delimited string (SORT$)
.br
   and to put them in reversed order (REV$). With PROPER$ it is possible to
.br
   capitalize the first letter of each individual element in a delimited
.br
   string. The ROTATE$ function rotates the items in a delimited string. The
.br
   COLLAPSE$ function will remove empty items in a delimited string. The
.br
   MATCH function can compare elements between two delimited strings and
.br
   PARSE can return parts of a delimited string based on wildcards. The WHERE
.br
   function returns the actual character position of the indicated token.
.br
.SH ""
   To determine if a string contains a delimiter at all, the HASDELIM
.br
   function can be used, while the DELIM$ function can change the actual
.br
   delimiter in a string to some other definition.
.br
.SH ""
   If a member still contains double quotes and escaped double quotes, then
.br
   this can be flattened out by using the FLATTEN$ function. This function
.br
   will remove double quotes and put escaping one level lower:
.br
.SH ""
   PRINT FLATTEN$("\\"Hello \\\\\\" world\\"")
.br
.SH ""
   Lastly, the function AMOUNT will count the number of members in a
.br
   delimited string:
.br
.SH ""
   nr = AMOUNT("a b c d e f g h i j")
.br
   PRINT AMOUNT("a,b,c,d,e,f,g,h,i,j", ",")
.br
.SH ""
   BaCon also has string functions available to handle delimited strings
.br
   which use unbalanced delimiters. These are delimiters which consist of
.br
   different characters, or different sets of characters. Examples of such
.br
   strings are HTML or XML strings. They can be handled by functions like
.br
   INBETWEEN$ and OUTBETWEEN$ very easily. For example, to obtain the title
.br
   of a website from an HTML definition:
.br
.SH ""
   PRINT INBETWEEN$("<html><head><title>Website</title></head>", "<title>",
.br
   "</title>")
.br
.SH ""
   By default, INBETWEEN$ will perform a non-greedy match, but the fourth
.br
   optional argument can be set to specify a greedy match.
.br
.SH ""
   Similarly, the OUTBETWEEN$ function will return everything but the matched
.br
   substring, effectively cutting out a substring based on unbalanced
.br
   delimiters.
.br
.SH ""
   Note that OPTION COLLAPSE does not impact both INBETWEEN$ and OUTBETWEEN$.
.br
.SH ""
.SH "Regular expressions"
.SH ""
   BaCon can digest POSIX compliant regular expressions when using the REGEX
.br
   function or the string functions EXTRACT$, REPLACE$ and WALK$. For this,
.br
   BaCon relies on the standard libc implementation. However, it is possible
.br
   to define a different regular expression engine with the PRAGMA statement.
.br
.SH ""
   For example, to specify the very fast NFA based regular expression library
.br
   TRE, the following line must be added at the top of the program:
.br
.SH ""
   PRAGMA RE tre
.br
.SH ""
   This will include the header file from the TRE library and will link
.br
   against its shared object. Of course, the system needs to have the
.br
   required development files from the TRE library installed.
.br
.SH ""
   BaCon will add the default locations of all necessary files to the compile
.br
   flags. In case these files are kept at a different location, it is
.br
   possible to define this explicitly as well:
.br
.SH ""
   PRAGMA RE tre INCLUDE <tre/regex.h> LDFLAGS -ltre
.br
.SH ""
   Next to the TRE library, also the Oniguruma library can be specified:
.br
.SH ""
   PRAGMA RE onig
.br
.SH ""
   When specifying the required development files:
.br
.SH ""
   PRAGMA RE onig INCLUDE <onigposix.h> LDFLAGS -lonig
.br
.SH ""
   Also the famous PCRE library is supported:
.br
.SH ""
   PRAGMA RE pcre
.br
.SH ""
   The full definition looks like:
.br
.SH ""
   PRAGMA RE pcre INCLUDE <pcreposix.h> LDFLAGS -lpcreposix
.br
.SH ""
   Basically, any regular expression library with a functional POSIX
.br
   interface can be specified. This allows a lot of flexibility when certain
.br
   features for regular expression parsing are required. The libraries TRE,
.br
   Oniguruma and PCRE do not need a further INCLUDE or LDFLAGS specification
.br
   if their development files have their default names and reside at their
.br
   default location.
.br
.SH ""
.SH "Error trapping, error catching and debugging"
.SH ""
   BaCon can distinguish between 4 types of errors.
.br
.SH ""
    1. System errors. These relate to the environment in which BaCon runs.
.br
.SH ""
    2. Syntax errors. These are detected during the conversion process.
.br
.SH ""
    3. Compiler errors. These are generated by the C compiler and passed on
.br
       to BaCon.
.br
.SH ""
    4. Runtime errors. These can occur during execution of the program.
.br
.SH ""
   When an error occurs, the default behavior of a BaCon program is to stop.
.br
   Only in case of runtime errors, it is possible to let the program handle
.br
   the error.
.br
.SH ""
     * In case of statements, the CATCH GOTO command can jump to a
.br
       self-defined error handling function. This is especially convenient
.br
       when creating GUI applications, as runtime errors by default appear on
.br
       the Unix command prompt.
.br
.SH ""
     * In case of functions, the OPTION ERROR must be set to FALSE to prevent
.br
       the program from stopping. The program then needs to check the
.br
       reserved ERROR variable to handle any unexpected situation.
.br
.SH ""
   Alternatively, it is possible to set a callback function for both
.br
   statements and functions. This callback function can be defined by the
.br
   CATCH ERROR statement. It should point to a function with three arguments:
.br
   the first argument capturing the statement or function causing the error,
.br
   the second the name of the file and the last the line number.
.br
.SH ""
   To prevent BaCon from detecting runtime errors altogether, use TRAP
.br
   SYSTEM.
.br
.SH ""
   The reserved ERROR variable contains the number of the last error
.br
   occurred. A full list of error numbers can be found in appendix A. With
.br
   the ERR$ function a human readable text for the error number can be
.br
   retrieved programmatically.
.br
.SH ""
   Next to these options, the statement TRACE ON can set the program in such
.br
   a way that it is executed at each keystroke, step-by-step. This way it is
.br
   possible to spot the location where the problem occurs. The ESC-key will
.br
   then exit the program. To switch of trace mode within a program, use TRACE
.br
   OFF.
.br
.SH ""
   Also the STOP statement can be useful in debugging. This will interrupt
.br
   the execution of the program and return to the Unix command prompt,
.br
   allowing intermediate checks. By using the Unix 'fg' command, or by
.br
   sending the CONT signal to the PID of the program, execution can be
.br
   resumed.
.br
.SH ""
.SH "Notes on transcompiling"
.SH ""
   The process of translating a programming language into another language,
.br
   and then compiling it, is also known as transcompiling. BaCon is a Basic
.br
   to C translator, or a transcompiler, or transpiler.
.br
.SH ""
   When using BaCon, three stages can be distinguished:
.br
.SH ""
    1. conversion time
.br
.SH ""
    2. compilation time
.br
.SH ""
    3. runtime
.br
.SH ""
   It is important to realize that BaCon commands can function in all these
.br
   stages. Examples of statements which have impact the on conversion stage
.br
   are INCLUDE, RELATE, USEC, USEH, WITH and some of the OPTION arguments.
.br
   These statements instruct BaCon about the way the Basic code should be
.br
   converted.
.br
.SH ""
   A statement impacting the compilation stage is PRAGMA. With this statement
.br
   it is possible to influence the behavior of the compiler.
.br
.SH ""
   Most other BaCon statements are effective during runtime. These form the
.br
   actual program being executed.
.br
.SH ""
   It should be clear that the aforementioned stages cannot be mixed. For
.br
   example, it does not make sense to define the argument for the INCLUDE
.br
   statement in a string variable, as the INCLUDE statement is effective
.br
   during conversion time, while variables are used during runtime.
.br
.SH ""
   Note that except for system errors, the logic of the error messages
.br
   basically follows the same structure: there are syntax errors (conversion
.br
   time), compiler errors and runtime errors. The system errors relate to the
.br
   possibility of using BaCon itself.
.br
.SH ""
.SH "Using the BaCon spartanic editor (BaSE)"
.SH ""
   BaCon comes with a limited built-in ASCII editor which can display BaCon
.br
   code using syntax highlighting. The editor requires an ANSI compliant
.br
   terminal. To start the editor, simply use the '-e' argument and a
.br
   filename:
.br
.SH ""
   # bacon -e prog.bac
.br
.SH ""
   If the file does not exist, then an empty screen occurs. Pressing the
.br
   <ESC> button will pop up a menu down below the screen. The options are:
.br
.SH ""
   - (H)elp: display the Help screen
.br
   - (Q)uit: quit the editor
.br
.SH ""
   The usual functionality for editing text applies. Most actions can be
.br
   performed using the <CTRL> key and a regular key. The <CTRL>+<h> key
.br
   combination will pop up the Help screen.
.br
.SH ""
   The Help screen will show the following information:
.br
.SH ""
   - <CTRL>+<n>: new file
.br
   - <CTRL>+<l>: load file
.br
   - <CTRL>+<s>: save file
.br
   - <CTRL>+<x>: cut line of text
.br
   - <CTRL>+<c>: copy line of text
.br
   - <CTRL>+<v>: paste line of text
.br
   - <CTRL>+<w> or <CTRL>+<del>: delete line
.br
   - <HOME>: put cursor at start of line
.br
   - <END>: put cursor at end of line
.br
   - <PgUp>: move one page upwards
.br
   - <PgDn>: move page downwards
.br
   - <cursor keys>: navigate through text
.br
   - <CTRL>+<f>: find term in code
.br
   - <CTRL>+<g>: goto line number
.br
   - <CTRL>+<e>: compile and execute program
.br
   - <CTRL>+<a>: apply indentation
.br
   - <CTRL>+<r>: toggle line numbers
.br
   - <CTRL>+<b>: toggle text boldness
.br
   - <CTRL>+<d>: show context info
.br
   - <CTRL>+<h>: show this help
.br
   - <CTRL>+<q>: quit BaCon spartanic editor
.br
.SH ""
   The context info works by first moving the cursor to the statement or
.br
   function for which more information is desired. Then, the <CTRL>+<d> key
.br
   combination will try to lookup the keyword in the manpage.
.br
.SH ""
   It is also possible to adjust the colors of the syntax highlighting.
.br
   Create the BaCon configuration file ~/.bacon/bacon.cfg if it does not
.br
   exist yet. The following keywords can set the coloring scheme, following
.br
   the numbering of the COLOR statement:
.br
.SH ""
   - statement_color (default: 2)
.br
   - function_color (default: 6)
.br
   - variable_color (default: 3)
.br
   - type_color (default: 3)
.br
   - number_color (default: 1)
.br
   - comment_color (default: 4)
.br
   - quote_color (default: 5)
.br
   - default_color (default: 7)
.br
.SH ""
   For example, to set the color for quoted text strings to green, the
.br
   following definition can be added to the BaCon configuration file:
.br
.SH ""
   quote_color 2
.br
.SH ""
.SH "Support for GUI programming"
.SH ""
   BaCon has a few functions available which enable basic GUI programming.
.br
   These functions follow the "object/property" model and implement simple
.br
   event handling.
.br
.SH ""
.SS "  Enabling GUI functions"
.SH ""
   To enable these functions, add the following line to your code:
.br
.SH ""
   OPTION GUI TRUE
.br
.SH ""
   By default, BaCon assumes Xaw as a backend. Though this is not the most
.br
   attractive widget set in the world, it is always available on any Unix
.br
   platform which has X installed. Alternatively, a different backend can be
.br
   set using PRAGMA GUI. Currently, Xaw3d, Motif, TK, GTK2, GTK3, GTK4 and
.br
   the console based CDK widgets (experimental) sets are supported. The
.br
   following code will select Motif as a backend:
.br
.SH ""
   PRAGMA GUI motif
.br
.SH ""
   Instead of "motif", the PRAGMA GUI statement also accepts "xaw3d", "uil",
.br
   "gtk2", "gtk3", "gtk4", "tk" and "cdk".
.br
.SH ""
   BaCon generates the source code for the GUI so the required header files
.br
   for the toolkits should be available on the compiling platform.
.br
.SH ""
.SS "  Defining the GUI"
.SH ""
   To define the GUI, the function GUIDEFINE can be used. This function may
.br
   occur in the program only once. Its string argument should contain a list
.br
   of declarative widget definitions, each set of definitions grouped between
.br
   curly brackets. The GUIDEFINE function returns the GUI id number. This is
.br
   an example for the Xaw widget toolkit:
.br
.SH ""
   gui = GUIDEFINE( " \\
.br
   { type=window name=window callback=window XtNwidth=300
.br
   XtNtitle=\\"Information\\" } \\
.br
   { type=dialogWidgetClass name=dialog parent=window XtNlabel=\\"Enter
.br
   term:\\" XtNvalue=\\"<term>\\" } \\
.br
   { type=commandWidgetClass name=submit parent=dialog callback=XtNcallback
.br
   XtNlabel=\\"Submit\\" } ")
.br
.SH ""
   As can be observed, each widget refers to properties which are specific to
.br
   the Xaw toolkit. A widget must have a type and a name. Optionally, a
.br
   widget can be attached to a parent, and it can submit a callback signal,
.br
   in which case the signal name must be specified.
.br
.SH ""
   The callback keyword can also define a particular string to be returned in
.br
   the event loop, defined after the signal name. The following will return
.br
   "click" when the button is pressed:
.br
.SH ""
   { type=commandWidgetClass name=submit parent=dialog
.br
   callback=XtNcallback,click XtNlabel=\\"Submit\\" }
.br
.SH ""
.SS "  Setting properties"
.SH ""
   The function GUISET can be used to specify more properties at a later
.br
   stage in the program:
.br
.SH ""
   CALL GUISET(gui, "label", XtNjustify, XtJustifyLeft)
.br
.SH ""
   The function GUIGET is used to retrieve a value from a widget. The value
.br
   is stored in a pointer variable:
.br
.SH ""
   CALL GUIGET(gui, "text", XtNstring, &txt)
.br
.SH ""
   For the TK backend, these functions can get and set variables from and to
.br
   the several TK functions.
.br
.SH ""
.SS "  Entering the mainloop"
.SH ""
   Once the GUI is defined, the program can enter the event loop using
.br
   GUIEVENT$. It requires the GUI id as an argument:
.br
.SH ""
   WHILE  TRUE
.br
       event$ = GUIEVENT$(gui)
.br
       SELECT  event$
.br
           CASE  "submit"
.br
               BREAK
.br
       ENDSELECT
.br
   WEND
.br
.SH ""
   When an event has happened, either the name of the widget causing the
.br
   event is returned, or the defined string in the callback keyword. The
.br
   BaCon program can decide what to do next.
.br
.SH ""
   In some cases it may be necessary to obtain a value which is passed to the
.br
   callback by the widget library. In such situation, the GUIEVENT$ function
.br
   accepts an optional second boolean parameter. This will add the incoming
.br
   callback value as a pointer attached as a string to the return value.
.br
.SH ""
   For example, to obtain the selected item in a XawList widget, the Xaw
.br
   library returns a struct containing information about the XawList. This
.br
   can be fetched as follows:
.br
.SH ""
   WHILE  TRUE
.br
       event$ = GUIEVENT$(gui, TRUE)
.br
       SELECT  TOKEN$(event$, 1)
.br
           CASE  "submit"
.br
               BREAK
.br
           CASE  "list"
.br
               info = (XawListReturnStruct*)DEC(TOKEN$(event$, 2))
.br
               PRINT  TOKEN$(info->string, 1)
.br
       ENDSELECT
.br
   WEND
.br
.SH ""
.SS "  Defining helper functions"
.SH ""
   It is also possible to define supplementary helper functions. A widget
.br
   library can implement additional functions to perform actions on widgets.
.br
   These helper functions can be configured in the BaCon program by setting
.br
   up a function pointer and then use GUIFN.
.br
.SH ""
   For example, to define a helper function showing a Xaw widget:
.br
.SH ""
   LOCAL (*show)() = XtPopup TYPE void
.br
   CALL GUIFN(id, "window", show, XtGrabNonexclusive)
.br
.SH ""
   Such definition may seem unnecessary, however, using GUIFN has several
.br
   advantages: it is compliant with the overall API design, the source code
.br
   becomes smaller in size, and most importantly, we do not need to worry
.br
   about argument types of the helper function.
.br
.SH ""
   For the TK backend, the GUIFN statement can define additional TCL code in
.br
   the current TK context.
.br
.SH ""
.SS "  Using native functions"
.SH ""
   The function GUIWIDGET will return the memory address of a widget based on
.br
   the defined name for that widget. This can come handy in cases where a GUI
.br
   helper function is used natively.
.br
.SH ""
.SH "Overview of BaCon statements and functions"
.SH ""
.SS "  ABS"
.SH ""
   ABS(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the absolute value of x. This is the value of x without sign.
.br
   Example without and with ABS, where the latter always will produce a
.br
   positive output:
.br
.SH ""
   PRINT x-y
.br
   PRINT ABS(x-y)
.br
.SH ""
.SS "  ACCEPT"
.SH ""
   ACCEPT(fd)
.br
.SH ""
   Type: function
.br
.SH ""
   In a network program, this function waits for an incoming connection and
.br
   returns a new descriptor to be used for SEND and RECEIVE. If the ACCEPT
.br
   functions fails, then the returned value is a negative number. Example:
.br
.SH ""
   OPEN "localhost:51000" FOR SERVER AS mynet
.br
   WHILE TRUE
.br
       fd = ACCEPT(mynet)
.br
       REPEAT
.br
           RECEIVE dat$ FROM fd
.br
           PRINT "Found: ", dat$;
.br
       UNTIL LEFT$(dat$, 4) = "quit"
.br
       CLOSE SERVER fd
.br
   WEND
.br
.SH ""
.SS "  ACOS"
.SH ""
   ACOS(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the calculated arc cosine of x, where x is a value in radians.
.br
.SH ""
.SS "  ADDRESS"
.SH ""
   ADDRESS(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the memory address of a variable or function. The ADDRESS function
.br
   can be used when passing pointers to imported C functions (see IMPORT).
.br
.SH ""
.SS "  ALARM"
.SH ""
   ALARM <sub>, <time>
.br
.SH ""
   Type: statement
.br
.SH ""
   Sets a SUB to be executed in <time> milliseconds. The value '0' will
.br
   cancel an alarm. The alarm will interrupt any action the BaCon program
.br
   currently is performing; an alarm always has priority.
.br
.SH ""
   After the sub is executed, the program will continue the operation it was
.br
   doing when the alarm occurred. Example:
.br
.SH ""
   SUB dinner
.br
       PRINT "Dinner time!"
.br
   END SUB
.br
   ALARM dinner, 5000
.br
.SH ""
.SS "  ALIAS"
.SH ""
   ALIAS <function> TO <alias>
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines an alias to an existing function or an imported function. Aliases
.br
   cannot be created for statements or operators. Example:
.br
.SH ""
   ALIAS "printf" TO DISPLAY
.br
   DISPLAY("Hello world\\n")
.br
.SH ""
.SS "  ALIGN$"
.SH ""
   ALIGN$(string$, width, type [,indent])
.br
.SH ""
   Type: function
.br
.SH ""
   Aligns a multi line <string$> over a maximum of <width> characters. The
.br
   <type> indicates the kind of alignment to apply: 0 = left alignment, 1 =
.br
   right alignment, 2 = center alignment, and 3 means fill or justify.
.br
.SH ""
   The alignment takes place in three stages. First, if the text starts with
.br
   the UTF-8 byte order mark bytes 0xEF 0xBB 0xBF, then these are removed and
.br
   the ALIGN$ function will automatically enable UTF8 mode for the text.
.br
   Then, if the original text contains newline characters (0x0A), these are
.br
   replaced with a single space. However, empty lines (double new lines
.br
   indicating a paragraph) are preserved, as well as all other special
.br
   characters, like a space (0x20), tab (0x09), carriage return (0x0D), non
.br
   breaking space (0xA0) or a form feed (0x0C). Therefore, in some cases, it
.br
   may be necessary to remove such special characters before using ALIGN$.
.br
.SH ""
   The second stage will try to find the best spot where to replace the space
.br
   character (0x20) for a newline character (0x0A). This is done within the
.br
   provided <width>. If there are redundant adjacent spaces then these are
.br
   removed.
.br
.SH ""
   Note that the ALIGN$ function will not hyphenate words. Lines are being
.br
   cut at a white space where possible. If a word does not fit in the
.br
   provided width by itself, then it will be wrapped around.
.br
.SH ""
   The third stage will apply the chosen type of alignment. In case type is
.br
   0, 1 or 2, the lines in the final result are being padded with a single
.br
   space character. In case type is 3, additional spaces are being added
.br
   equally in between the words to align the text on both sides, except for
.br
   the last line in a paragraph (where paragraphs are considered to be
.br
   separated from each other by an empty line).
.br
.SH ""
   If the original text contained the UTF8 order mark 0xEF 0xBB 0xBF, then
.br
   the ALIGN$ function will put back the byte order mark in the first bytes
.br
   of the result. For more information on the UTF8 byte order mark, see also
.br
   the HASBOM and EDITBOM$ functions.
.br
.SH ""
   The optional argument <indent> will prepend additional space characters to
.br
   each line. Example:
.br
.SH ""
   data$ = LOAD$("ascii_data.txt")
.br
   PRINT ALIGN$(data$, 40, 0)
.br
.SH ""
   The ALIGN$ can handle UTF8 strings correctly as well. If the original text
.br
   does not contain the UTF8 byte order mark then UTF8 mode should be enabled
.br
   manually. The following example aligns a UTF8 text without byte order mark
.br
   at two sides, each line not containing more than 50 characters, starting
.br
   10 positions from the left, while the text is being stripped from carriage
.br
   return symbols:
.br
.SH ""
   OPTION UTF8 TRUE
.br
   text$ = LOAD$("Jane_Austen.txt")
.br
   PRINT ALIGN$(EXTRACT$(text$, CR$), 50, 3, 10)
.br
.SH ""
.SS "  AMOUNT"
.SH ""
   AMOUNT(string$ [,delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the amount of tokens in a string split by delimiter$. The
.br
   delimiter$ is optional. If it is omitted, then the definition from OPTION
.br
   DELIM is assumed. When specified, it may consist of multiple characters.
.br
   If delimiter$ occurs between double quotes in string$ then it is ignored.
.br
   Example:
.br
.SH ""
   PRINT AMOUNT("a b c d \\"e f\\" g h i j")
.br
   PRINT AMOUNT("Dog Cat@@@Mouse Bird@@@123@@@456@@@789", "@@@")
.br
.SH ""
.SS "  AND"
.SH ""
   <expr> AND <expr>
.br
.SH ""
   Type: operator
.br
.SH ""
   Performs a logical 'and' between two expressions. For the binary 'and',
.br
   use the '&' symbol. Example:
.br
.SH ""
   IF x = 0 AND y = 1 THEN PRINT "Hello"
.br
.SH ""
.SS "  APPEND"
.SH ""
   APPEND string$ TO filename$
.br
.SH ""
   APPEND string$, other$
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement can be used two ways. The first is to save a string to disk
.br
   in one step. If the file already exists, the data will be appended. See
.br
   BAPPEND for appending binary files in one step, and
.br
   OPEN/WRITELN/READLN/CLOSE to read and write to a file using a filehandle
.br
   in append mode.
.br
.SH ""
   In the second way, this statement simply will append one string to
.br
   another, thereby modifying the original string.
.br
.SH ""
   Examples:
.br
.SH ""
   APPEND result$ TO "/tmp/more_data.txt"
.br
   APPEND str$, "world"
.br
.SH ""
.SS "  APPEND$"
.SH ""
   APPEND$(string$, pos, token$ [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Inserts <token$> into a delimited string$ split by delimiter$, at position
.br
   <pos>. The delimiter$ is optional. If it is omitted, then the definition
.br
   from OPTION DELIM is assumed. When specified, it may consist of multiple
.br
   characters.
.br
.SH ""
   If the <pos> parameter is 0, or is bigger than the amount of members in
.br
   <string$>, then <token$> is appended. If OPTION COLLAPSE is FALSE
.br
   (default) then APPEND$ always will add a delimiter to an empty <string$>,
.br
   after which <token$> will be added. In case of TRUE however, appending
.br
   <token$> will simply copy the contents of <token$> to an empty <string$>.
.br
.SH ""
   If the <pos> parameter is negative, then <string$> will be returned
.br
   unmodified. If delimiter$ occurs between double quotes in string$, then it
.br
   is ignored. This behavior can be changed by setting OPTION QUOTED to
.br
   FALSE. See DEL$ to delete members, and the chapter on delimited string
.br
   functions for more information about delimited strings. Example:
.br
.SH ""
   PRINT APPEND$("Rome Amsterdam Kiev Bern Paris London", 2, "Vienna")
.br
.SH ""
.SS "  ARGUMENT$"
.SH ""
   ARGUMENT$
.br
.SH ""
   Type: variable
.br
.SH ""
   Reserved variable containing name of the program and the arguments to the
.br
   program. These are all separated by spaces.
.br
.SH ""
   If the CMDLINE function is used then this variable will contain optional
.br
   arguments to command line functions.
.br
.SH ""
.SS "  ASC"
.SH ""
   ASC(char)
.br
.SH ""
   Type: function
.br
.SH ""
   Calculates the ASCII value of char (opposite of CHR$). See also UCS for
.br
   UTF8 characters. Example:
.br
.SH ""
   PRINT ASC("x")
.br
.SH ""
.SS "  ASIN"
.SH ""
   ASIN(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the calculated arcsine of x, where x is a value in radians.
.br
.SH ""
.SS "  ATN"
.SH ""
   ATN(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the calculated arctangent of x, where x is a value in radians.
.br
.SH ""
   PRINT ATN(RAD(90))
.br
.SH ""
.SS "  ATN2"
.SH ""
   ATN2(y, x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the calculated arctangent of y/x. The sign of the arguments is
.br
   used to determine the quadrant.
.br
.SH ""
   PRINT ATN2(30, -35)
.br
.SH ""
.SS "  B64DEC$"
.SH ""
   B64DEC$(x$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the decoded string or data from a BASE64 string. In case of binary
.br
   data, the LEN function will correctly provide the amount of bytes
.br
   available in the string. Example:
.br
.SH ""
   PRINT B64DEC$("QmFDb24gaXMgZnVu")
.br
.SH ""
   Example where binary PNG data is recovered into a string variable and
.br
   saved:
.br
.SH ""
   png$ = B64DEC$(some_encoded_png$)
.br
   BSAVE png$ TO "picture.png" SIZE LEN(png$)
.br
.SH ""
.SS "  B64ENC$"
.SH ""
   B64ENC$(x$[, length])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the encoded string from a regular string or memory area. In case
.br
   of a string, the length of the string is the default. In case of a memory
.br
   area, the additional <length> argument must specify the amount of bytes to
.br
   encode. Examples:
.br
.SH ""
   PRINT B64ENC$("Encode me")
.br
   PRINT B64ENC$(mem, 1024)
.br
.SH ""
.SS "  BAPPEND"
.SH ""
   BAPPEND data TO filename$ SIZE amount
.br
.SH ""
   Type: statement
.br
.SH ""
   Saves a memory area with binary data to disk in one step. If the file
.br
   already exists, the data will be appended. See APPEND for appending text
.br
   files in one step, and OPEN/PUTBYTE/GETBYTE/CLOSE to read and write to a
.br
   file using a filehandle. Example:
.br
.SH ""
   BAPPEND mem TO "/home/me/data" SIZE 10
.br
.SH ""
.SS "  BASENAME$"
.SH ""
   BASENAME$(filename$ [, flag])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the filename part of a given full filename. The optional [flag]
.br
   indicates the part of the filename to be returned. The values are: 0 =
.br
   full filename (default), 1 = filename without extension and 2 = extension
.br
   without filename. See also DIRNAME$.
.br
.SH ""
.SS "  BIN$"
.SH ""
   BIN$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Calculates the binary value of x and returns a string with the result. The
.br
   type size depends on the setting of OPTION MEMTYPE. If MEMTYPE is set to
.br
   char (default), then 8 bits are returned, if it is set to short then 16
.br
   bits are returned, etc. See also DEC to convert back to decimal.
.br
.SH ""
.SS "  BIT"
.SH ""
   BIT(x)
.br
.SH ""
   Type: function
.br
.SH ""
   This function returns the value for a bit on position <x>. If x = 0 then
.br
   it returns 1, if x = 1 then it returns 2, if x = 2 then it returns 4 and
.br
   so on.
.br
.SH ""
   PRINT BIT(x)
.br
.SH ""
.SS "  BLOAD"
.SH ""
   BLOAD(filename$)
.br
.SH ""
   Type: function
.br
.SH ""
   Performs a load into a memory address of a binary file. The memory address
.br
   is returned when the loading was successful. When done with the data, the
.br
   memory should be freed with the FREE statement. See LOAD$ for loading text
.br
   files in one step, and OPEN/PUTBYTE/GETBYTE/CLOSE to read and write to a
.br
   file using a file handle. Example:
.br
.SH ""
   binary = BLOAD("/home/me/myprog")
.br
   PRINT "First two bytes are: ", PEEK(binary), " ", PEEK(binary+1)
.br
   FREE binary
.br
.SH ""
.SS "  BREAK"
.SH ""
   BREAK [x]
.br
.SH ""
   Type: statement
.br
.SH ""
   Breaks out loop constructs like FOR/NEXT, WHILE/WEND, REPEAT/UNTIL or
.br
   DOTIMES/DONE.
.br
.SH ""
   The optional parameter can define to which level the break should take
.br
   place in case of nested loops. This parameter should be an integer value
.br
   higher than 0. See also CONTINUE to resume a loop.
.br
.SH ""
.SS "  BSAVE"
.SH ""
   BSAVE data TO filename$ SIZE amount
.br
.SH ""
   Type: statement
.br
.SH ""
   Saves a memory area with binary data to disk in one step. If the file
.br
   already exists it is overwritten. The amount must be specified in bytes.
.br
   See SAVE for saving text files in one step, and OPEN/PUTBYTE/GETBYTE/CLOSE
.br
   to read and write to a file using a filehandle. Example:
.br
.SH ""
   BSAVE mem TO "/home/me/picture.png" SIZE 12123
.br
.SH ""
.SS "  BYTELEN"
.SH ""
   BYTELEN(x$, y [, z])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the actual byte length of UTF8 string x$ in case of y characters.
.br
   This is a wrapper function which can be used in combination with regular
.br
   string functions, allowing correct processing of UTF8 string sequences. If
.br
   the optional argument z is set then start counting the byte length from
.br
   the right size of string x$. Example:
.br
.SH ""
   str$ = "A  and a  symbol"
.br
   PRINT LEFT$(str$, BYTELEN(str$, 3))
.br
   PRINT RIGHT$(str$, BYTELEN(str$, 8, TRUE))
.br
.SH ""
.SS "  CA$"
.SH ""
   CA$(connection)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the Certificate Authority from the certificate used in the current
.br
   network connection. Assumes that TLS has been enabled. See the chapter on
.br
   secure network connections for more details. See also CN$.
.br
.SH ""
.SS "  CALL"
.SH ""
   CALL <sub name> [TO <var>]
.br
.SH ""
   Type: statement
.br
.SH ""
   Calls a subroutine if the sub is defined at the end of the program. With
.br
   the optional TO also a function can be invoked which stores the result
.br
   value in <var>.
.br
.SH ""
   Example:
.br
.SH ""
   CALL fh2celsius(72) TO celsius
.br
   PRINT celsius
.br
.SH ""
.SS "  CATCH"
.SH ""
   CATCH GOTO <label> | RESET | ERROR <function>
.br
.SH ""
   Type: statement
.br
.SH ""
   The GOTO keyword sets the error function where the program should jump to
.br
   if runtime error checking is enabled with TRAP. This only is applicable
.br
   for statements. For an example, see the RESUME statement.
.br
.SH ""
   The RESET keyword restores the BaCon default error messages for
.br
   statements.
.br
.SH ""
   The ERROR keyword allows setting a callback function where the program
.br
   will jump to in case an error occurs. This works both for statements and
.br
   functions provided that OPTION ERROR is set to FALSE. This is to prevent
.br
   that erroneous functions will stop the program. The callback function
.br
   should have three arguments which will hold the name of the statement or
.br
   function, the name of the file and the line number where the error
.br
   occurred. Example:
.br
.SH ""
   OPTION ERROR FALSE
.br
   CATCH ERROR help
.br
   SUB help(c$, f$, no)
.br
       PRINT "Error is: ", ERR$(ERROR), " in function ", c$, " in file '",
.br
   f$, "' at line ", no
.br
       PRINT "Callback ended"
.br
   END SUB
.br
.SH ""
.SS "  CEIL"
.SH ""
   CEIL(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Rounds x up to the nearest integral (integer) number. This function always
.br
   returns a float value. See also FLOOR and ROUND.
.br
.SH ""
.SS "  CERTIFICATE"
.SH ""
   CERTIFICATE <key.pem>, <certificate.pem>
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines the private key and certificate file in PEM format. This function
.br
   is used to setup TLS server networking. For an example, see the chapter on
.br
   TLS.
.br
.SH ""
.SS "  CHANGE$"
.SH ""
   CHANGE$(string$, position, new$ [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Changes the token in string$, which is split by delimiter$, at position
.br
   with new$. The delimiter$ is optional. If it is omitted, then the
.br
   definition from OPTION DELIM is assumed. When specified, it may consist of
.br
   multiple characters. If delimiter$ occurs between double quotes in string$
.br
   then it is ignored. This behavior can be changed by setting OPTION QUOTED
.br
   to FALSE.
.br
.SH ""
   If the indicated position is outside a valid range, the original string is
.br
   returned. Use the FLATTEN$ function to flatten out the returned token. See
.br
   also EXCHANGE$, TOKEN$ and SPLIT.
.br
.SH ""
   Examples:
.br
.SH ""
   PRINT CHANGE$("a b c d \\"e f\\" g h i j", 5, "OK")
.br
   PRINT CHANGE$("a,b,c,d,e,f,g,h,i,j", 4, "123", ",")
.br
.SH ""
.SS "  CHANGEDIR"
.SH ""
   CHANGEDIR <directory>
.br
.SH ""
   Type: statement
.br
.SH ""
   Changes the current working directory. Example:
.br
.SH ""
   CHANGEDIR "/tmp/mydir"
.br
.SH ""
.SS "  CHOP$"
.SH ""
   CHOP$(x$[, y$[, z]])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns a string defined in x$ where on both sides <CR>, <NL>, <TAB> and
.br
   <SPACE> have been removed. If other characters need to be chopped then
.br
   these can be specified in the optional y$. The optional parameter z
.br
   defines where the chopping must take place: 0 means on both sides, 1 means
.br
   chop at the left and 2 means chop at the right. Examples:
.br
.SH ""
   PRINT CHOP$("bacon", "bn")
.br
   PRINT CHOP$(" hello world ", " ", 2)
.br
.SH ""
   PRINT CHOP$("print \\"end\\"", "\\n\\r\\t " & CHR$(34))
.br
.SH ""
.SS "  CHR$"
.SH ""
   CHR$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the character belonging to ASCII number x. This function does the
.br
   opposite of ASC. The value for x must lie between 0 and 255. See UTF8$ for
.br
   Unicode values. Example:
.br
.SH ""
   LET a$ = CHR$(0x23)
.br
   PRINT a$
.br
.SH ""
.SS "  CIPHER$"
.SH ""
   CIPHER$(connection)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the description of the encryption methods in use by the current
.br
   network connection. Assumes that TLS has been enabled. See the chapter on
.br
   secure network connections for more details. See also CA$ and CN$.
.br
.SH ""
.SS "  CL$"
.SH ""
   CL$
.br
.SH ""
   Type: variable
.br
.SH ""
   The Clear Line variable clears the line indicated by the current cursor
.br
   position. See also EL$.
.br
.SH ""
.SS "  CLASS"
.SH ""
   CLASS
.br
       <body>
.br
   ENDCLASS | END CLASS
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines a class in original C++ code. This code is put unmodified into the
.br
   generated global header source file. It is particularly useful when
.br
   embedding C++ code into BaCon. See also USEC and USEH. Example:
.br
.SH ""
   CLASS TVision : public Tapplication
.br
   public:
.br
       TVision() : TProgInit(&TVision::TV_initStatusLine,
.br
   &TVision::TV_initMenuBar, &Tvision::initDeskTop)
.br
       {
.br
       }
.br
       static TMenuBar *TV_initMenuBar(TRect);
.br
       static TStatusLine *TV_initStatusLine(TRect);
.br
   ENDCLASS
.br
.SH ""
.SS "  CLEAR"
.SH ""
   CLEAR
.br
.SH ""
   Type: statement
.br
.SH ""
   Clears the terminal screen. To be used with ANSI compliant terminals.
.br
.SH ""
.SS "  CLOSE"
.SH ""
   CLOSE FILE|DIRECTORY|NETWORK|SERVER|MEMORY|LIBRARY|DEVICE x[, y, z, ...]
.br
.SH ""
   Type: statement
.br
.SH ""
   Close file, directory, network, memory or library identified by handle.
.br
   Multiple handles of the same type maybe used in a comma separated list.
.br
   Examples:
.br
.SH ""
   CLOSE FILE myfile
.br
   CLOSE MEMORY mem1, mem2, block
.br
   CLOSE LIBRARY "libgtk.so"
.br
.SH ""
.SS "  CMDLINE"
.SH ""
   CMDLINE(options$)
.br
.SH ""
   Type: function
.br
.SH ""
   Defines the possible command line options to the current program. The
.br
   CMDLINE function returns the ASCII value of each option until all provided
.br
   options are parsed, in which case a '-1' is returned. In case an unknown
.br
   option is encountered, question mark is returned.
.br
.SH ""
   If <options$> contains a colon, then an extra argument to the option is
.br
   required. Such argument will appear in the reserved variable ARGUMENT$.
.br
   Example where a program recognizes the options '-n' and '-f <arg>':
.br
.SH ""
   REPEAT
.br
       option = CMDLINE("nf:")
.br
       PRINT option
.br
       PRINT ARGUMENT$
.br
   UNTIL option = -1
.br
.SH ""
.SS "  CN$"
.SH ""
   CN$(connection)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the Common Name from the certificate used in the current network
.br
   connection. Assumes that TLS has been enabled. See the chapter on secure
.br
   network connections for more details. See also CA$.
.br
.SH ""
.SS "  COIL$"
.SH ""
   COIL$([variable,] nr, expression$[, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   This is an inline loop which returns the results of the repeatedly
.br
   evaluated <expression$> appended to a delimited string. The optional
.br
   <variable> must be a numeric variable and <nr> defines how many times the
.br
   <expression$> is carried out. If <variable> is not present then the
.br
   anonymous variable "_" will be used.
.br
.SH ""
   It is possible to specify the concatenation delimiter explicitly. Note
.br
   that this only works when COIL$ also defines a variable name, so COIL$
.br
   counts 4 parameters in total.
.br
.SH ""
   It is not allowed to use nested COIL$ constructs, or to use COIL$
.br
   multitple times in the same statement. Such code will generate a syntax
.br
   error during conversion time. See also EXPLODE$ for another method to
.br
   create delimited strings, the inline LOOP$ to create regular strings, or
.br
   the inline if IIF$. More info on delimited strings can be found in the
.br
   chapter on delimited string functions.
.br
.SH ""
   Example to get the first 10 letters in the Latin alphabet as a delimited
.br
   string, using the anonymous variable:
.br
.SH ""
   PRINT COIL$(10, CHR$(64+_))
.br
.SH ""
   The following code prints only the even numbers between 0 and 100:
.br
.SH ""
   PRINT COIL$(100, IIF$(EVEN(_), STR$(_)))
.br
.SH ""
   This example prints the elements in a string array, each on a separate
.br
   line:
.br
.SH ""
   PRINT COIL$(i, 5, array$[i-1], NL$)
.br
.SH ""
.SS "  COLLAPSE$"
.SH ""
   COLLAPSE$(string$ [,delim$])
.br
.SH ""
   Type: function
.br
.SH ""
   Collapses a delimited string so no empty items are present. The resulting
.br
   string will only contain items separated by exactly one delimiter.
.br
.SH ""
   If the delimiter occurs between double quotes in string$, then it is
.br
   ignored. This behavior can be changed by setting OPTION QUOTED to FALSE.
.br
   See also the chapter on delimited string functions for more information
.br
   about delimited strings. Example:
.br
.SH ""
   PRINT COLLAPSE$("a,,,b,,,,,,c,d,,,e", ",")
.br
.SH ""
.SS "  COLLECT"
.SH ""
   COLLECT <tree> TO <array> [SIZE <variable>][STATIC]
.br
.SH ""
   Type: statement
.br
.SH ""
   Retrieves all values of the nodes which are present in a binary tree. The
.br
   results are stored in <array>. As it sometimes is unknown how many
.br
   elements this resulting array will contain, the array should not be
.br
   declared explicitly. Instead, COLLECT will declare the result array
.br
   dynamically.
.br
.SH ""
   If COLLECT is being used in a function or sub, then <array> will have a
.br
   local scope. Else <array> will be visible globally, and can be accessed
.br
   within all functions and subs.
.br
.SH ""
   The total amount of elements created in this array is stored in the
.br
   optional <variable>. This variable can be declared explicitly using LOCAL
.br
   or GLOBAL.
.br
.SH ""
   For more information and examples, see the chapter on binary trees. See
.br
   also FIND to verify the presence of a node in a binary tree. Example:
.br
.SH ""
   COLLECT mytree TO allnodes
.br
   FOR x = 0 TO UBOUND(allnodes)-1
.br
       PRINT allnodes[x]
.br
   NEXT
.br
.SH ""
   The optional STATIC keyword allows the created <array> to be returned from
.br
   a function.
.br
.SH ""
.SS "  COLOR"
.SH ""
   COLOR <BG|FG> TO <BLACK|RED|GREEN|YELLOW|BLUE|MAGENTA|CYAN|WHITE>
.br
   COLOR <NORMAL|INTENSE|INVERSE|RESET>
.br
.SH ""
   Type: statement
.br
.SH ""
   Sets coloring for the output of characters in a terminal screen. For FG,
.br
   the foreground color is set. With BG, the background color is set. The
.br
   INTENSE and NORMAL keywords can be used combined with a color. This
.br
   statement only works well with ANSI compliant terminals. Refer to the TYPE
.br
   statement to set the terminal font type. Example:
.br
.SH ""
   COLOR FG TO GREEN
.br
   PRINT "This is green!"
.br
   COLOR FG TO INTENSE RED
.br
   PRINT "This is red!"
.br
   COLOR RESET
.br
.SH ""
   Instead of color names, it is also possible to use a numeric reference.
.br
   The FG and BG indicators have an enumeration as well:
.br
.SH ""
          Item              Number        
.br
          Black                0          
.br
           Red                 1          
.br
          Green                2          
.br
         Yellow                3          
.br
          Blue                 4          
.br
         Magenta               5          
.br
          Cyan                 6          
.br
          White                7          
.br
       BackGround              0          
.br
       ForeGround              1          
.br
.SH ""
   Example using numeric color references:
.br
.SH ""
   COLOR 1 TO 3
.br
   PRINT "This is yellow!"
.br
   COLOR RESET
.br
.SH ""
.SS "  COLUMNS"
.SH ""
   COLUMNS
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the amount of columns in the current ANSI compliant terminal. See
.br
   also ROWS. Example:
.br
.SH ""
   PRINT "X,Y: ", COLUMNS, ",", ROWS
.br
.SH ""
.SS "  CONCAT$"
.SH ""
   CONCAT$(x$, y$, ...)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the concatenation of x$, y$, ... The CONCAT$ function can accept
.br
   an unlimited amount of arguments. Example:
.br
.SH ""
   txt$ = CONCAT$("Help this is ", name$, " carrying a strange ", thing$)
.br
.SH ""
   The CONCAT$ function is deprecated but it still is available for
.br
   compatibility reasons. It can be used for high performance string
.br
   concatenation but care should be taken when using non-BaCon functions as
.br
   arguments.
.br
.SH ""
   Instead, BaCon uses either the '&' symbol or the + symbol as infix
.br
   string concatenation operator. These operators are more versatile and
.br
   allow any kind of concatenation. The following is the same example using
.br
   '&':
.br
.SH ""
   txt$ = "Help this is " & name$ & " carrying a strange " & thing$
.br
.SH ""
   This will work as well:
.br
.SH ""
   txt$ = "Help this is " + name$ + " carrying a strange " + thing$
.br
.SH ""
.SS "  CONST"
.SH ""
   CONST <var> = <value> | <expr>
.br
.SH ""
   Type: statement
.br
.SH ""
   Assigns a value a to a label which cannot be changed during execution of
.br
   the program. Consts are globally visible from the point where they are
.br
   defined. Example:
.br
.SH ""
   CONST WinSize = 100
.br
   CONST Screen = WinSize * 10 + 5
.br
.SH ""
.SS "  CONTINUE"
.SH ""
   CONTINUE [x]
.br
.SH ""
   Type: statement
.br
.SH ""
   Skips the remaining body of loop constructs like FOR/NEXT, WHILE/WEND,
.br
   REPEAT/UNTIL or DOTIMES/DONE.
.br
.SH ""
   The optional parameter can define at which level a continue should be
.br
   performed in case of nested loops, and should be an integer value higher
.br
   than 0.
.br
.SH ""
.SS "  COPY"
.SH ""
   COPY <from> TO <new> [SIZE length]
.br
.SH ""
   Type: statement
.br
.SH ""
   If <from> and <to> contain string values, then COPY copies a file to a new
.br
   file. Example:
.br
.SH ""
   COPY "file.txt" TO "/tmp/new.txt"
.br
.SH ""
   If the SIZE keyword is present, then COPY assumes a memory copy. Example
.br
   copying one array to another:
.br
.SH ""
   OPTION MEMTYPE long
.br
   DECLARE array[5], copy[5] TYPE long
.br
   array[0] = 15
.br
   array[1] = 24
.br
   array[2] = 33
.br
   array[3] = 42
.br
   array[4] = 51
.br
   COPY array TO copy SIZE 5
.br
.SH ""
.SS "  COS"
.SH ""
   COS(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the calculated COSINE of x, where x is a value in radians.
.br
   Example:
.br
.SH ""
   PRINT COS(RAD(45))
.br
.SH ""
.SS "  COUNT"
.SH ""
   COUNT(string, y)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the amount of times the ASCII or UCS value <y> occurs in <string>.
.br
   Example:
.br
.SH ""
   PRINT COUNT("Hello world", ASC("l"))
.br
   OPTION UTF8 TRUE
.br
   PRINT COUNT(FILL$(5, 0x1F600), 0x1F600)
.br
.SH ""
   See also FILL$.
.br
.SH ""
.SS "  CR$"
.SH ""
   CR$
.br
.SH ""
   Type: variable
.br
.SH ""
   Represents the Carriage Return as a string.
.br
.SH ""
.SS "  CURDIR$"
.SH ""
   CURDIR$
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the full path of the current working directory. See also ME$ or
.br
   REALPATH$.
.br
.SH ""
.SS "  CURSOR"
.SH ""
   CURSOR <ON|OFF> | <FORWARD|BACK|UP|DOWN> [x]
.br
.SH ""
   Type: statement
.br
.SH ""
   Shows ("on") or hides ("off") the cursor in the current ANSI compliant
.br
   terminal. Also, the cursor can be moved one position in one of the four
.br
   directions. Optionally, the amount of steps to move can be specified.
.br
   Example:
.br
.SH ""
   PRINT "I am here"
.br
   CURSOR DOWN 2
.br
   PRINT "...now I am here"
.br
.SH ""
.SS "  CUT$"
.SH ""
   CUT$(string$, start, end [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Retrieves elements from a delimited string$ split by delimiter$, starting
.br
   at <start> until <end> inclusive. The delimiter$ is optional. If it is
.br
   omitted, then the definition from OPTION DELIM is assumed. When specified,
.br
   it may consist of multiple characters.
.br
.SH ""
   If the <start> parameter is higher than <end>, the result will be the same
.br
   as when the parameters were reversed.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See also
.br
   HEAD$ and TAIL$, and the chapter on delimited string functions for more
.br
   information about delimited strings. Example:
.br
.SH ""
   PRINT "Excerpt: ", CUT$("Rome Amsterdam Kiev Bern Paris London", 2, 4)
.br
.SH ""
.SS "  DATA"
.SH ""
   DATA <x, y, z, ...>
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines data. The DATA statement always contains data which is globally
.br
   visible. The data can be read with the READ statement. If more data is
.br
   read than available, then in case of numeric data a '0' will be retrieved,
.br
   and in case of string data an empty string. To start reading from the
.br
   beginning again use RESTORE. Example:
.br
.SH ""
   DATA 1, 2, 3, 4, 5, 6
.br
   DATA 0.5, 0.7, 11, 0.15
.br
   DATA 1, "one", 2, "two", 3, "three", 4, "four"
.br
.SH ""
.SS "  DAY"
.SH ""
   DAY(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the day of the month (1-31) where x is amount of seconds since
.br
   January 1, 1970. Example:
.br
.SH ""
   PRINT DAY(NOW)
.br
.SH ""
.SS "  DEC"
.SH ""
   DEC(x [,flag])
.br
.SH ""
   Type: function
.br
.SH ""
   Calculates the decimal value of x, where x should be passed as a string.
.br
   The optional [flag] parameter determines the base to convert from. If flag
.br
   = 0 (default) then base is hexadecimal. If flag lies between 2 and 36 then
.br
   the corresponding base is assumed. Note that DEC always returns a positive
.br
   number. See also HEX$ and BIN$ for hexadecimal and binary conversions.
.br
   Example:
.br
.SH ""
   PRINT DEC("AB1E")
.br
   PRINT DEC("00010101", 2)
.br
.SH ""
.SS "  DECLARE"
.SH ""
   DECLARE <var>[,var2,var3,...] TYPE | ASSOC | TREE <c-type> | [ARRAY
.br
   <size>]
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement is similar to the GLOBAL statement and is available for
.br
   compatibility reasons.
.br
.SH ""
.SS "  DECR"
.SH ""
   DECR <x>[, y]
.br
.SH ""
   Type: statement
.br
.SH ""
   Decreases variable <x> with 1. Optionally, the variable <x> can be
.br
   decreased with <y>. Example:
.br
.SH ""
   x = 10
.br
   DECR x
.br
   PRINT x
.br
   DECR x, 3
.br
   PRINT x
.br
.SH ""
.SS "  DEF FN"
.SH ""
   DEF FN <label> [(args)] = <value> | <expr>
.br
.SH ""
   Type: statement
.br
.SH ""
   Assigns a value or expression to a label. Examples:
.br
.SH ""
   DEF FN func(x) = 3 * x
.br
   PRINT func(12)
.br
.SH ""
   DEF FN First$(x$) = LEFT$(x$, INSTR(x$, " ")-1)
.br
   PRINT First$("One Two Three")
.br
.SH ""
.SS "  DEG"
.SH ""
   DEG(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the degree value of x radians. Example:
.br
.SH ""
   PRINT DEG(PI)
.br
.SH ""
.SS "  DEL$"
.SH ""
   DEL$(string$, pos [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Deletes a member at position <pos> from a delimited string$ split by
.br
   delimiter$. The delimiter$ is optional. If it is omitted, then the
.br
   definition from OPTION DELIM is assumed. When specified, it may consist of
.br
   multiple characters.
.br
.SH ""
   If the <pos> parameter is smaller than 1 or bigger than the amount of
.br
   members in <string$>, then the original string$ is returned.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See
.br
   APPEND$ for adding members, and the chapter on delimited string functions
.br
   for more information about delimited strings. Example:
.br
.SH ""
   PRINT DEL$("Rome Amsterdam Kiev Bern Paris London", 2)
.br
.SH ""
.SS "  DELETE"
.SH ""
   DELETE <FILE|DIRECTORY|RECURSIVE> <x$> [FROM] <binary tree>
.br
.SH ""
   Type: statement
.br
.SH ""
   Deletes a file with the FILE argument, or an empty directory when using
.br
   the DIRECTORY argument. The RECURSIVE argument can delete a directory
.br
   containing files. It can also delete a complete directory tree. The FROM
.br
   keyword is used when deleting a node from a binary tree. If an error
.br
   occurs then this can be captured by using the CATCH statement. Example:
.br
.SH ""
   DELETE FILE "/tmp/data.txt"
.br
   DELETE RECURSIVE "/usr/data/stuff"
.br
   DELETE value FROM tree
.br
.SH ""
.SS "  DELIM$"
.SH ""
   DELIM$(string$, old$, new$)
.br
.SH ""
   Type: function
.br
.SH ""
   Changes the delimiter in string$ from old$ to new$. The new delimiter can
.br
   be of different size compared to the old delimiter.
.br
.SH ""
   If the old delimiter occurs between double quotes in string$, then it is
.br
   ignored. This behavior can be changed by setting OPTION QUOTED to FALSE.
.br
   See also the chapter on delimited string functions for more information
.br
   about delimited strings. Example:
.br
.SH ""
   PRINT "Changed delimiter: ", DELIM$("f,q,a,c,i,b,r,t,e,d,z,", ",", "@@@")
.br
.SH ""
.SS "  DIRNAME$"
.SH ""
   DIRNAME$(filename$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the pathname part of a given filename. See also REALPATH$ and
.br
   BASENAME$.
.br
.SH ""
.SS "  DLE$"
.SH ""
   DLE$
.br
.SH ""
   Type: variable
.br
.SH ""
   The DOS Line Ending variable returns a carriage return and a newline
.br
   character. See also NL$ and CR$.
.br
.SH ""
.SS "  DO"
.SH ""
   DO
.br
       <body>
.br
   DONE
.br
.SH ""
   Type: statement
.br
.SH ""
   With DO/DONE a body of statements can be grouped together. This is useful
.br
   in case of special compiler constructs like pragmas. Example:
.br
.SH ""
   PRAGMA omp parallel sections
.br
   DO
.br
       <...code...>
.br
   DONE
.br
.SH ""
.SS "  DOTIMES"
.SH ""
   DOTIMES x
.br
       <body>
.br
       [BREAK]|[CONTINUE]
.br
   DONE
.br
.SH ""
   Type: statement
.br
.SH ""
   With DOTIMES/DONE a body of statements can be repeated for a fixed amount
.br
   of times without the need for a variable. This is known as an anonymous
.br
   loop. As with other loops, it can be prematurely exited by using BREAK.
.br
   Also, part of the body can be skipped by the use of the CONTINUE
.br
   statement. See FOR/NEXT, WHILE/WEND and REPEAT/UNTIL for setting up other
.br
   types of loops. To refer to the current loop, the anonymous variable "_"
.br
   can be used. Example:
.br
.SH ""
   DOTIMES 10
.br
       PRINT "This is loop number ", _, " in DOTIMES."
.br
   DONE
.br
.SH ""
.SS "  EDITBOM$"
.SH ""
   EDITBOM$(string$, action)
.br
.SH ""
   Type: function
.br
.SH ""
   Adds or deletes the UTF8 byte order mark from <string$>. If <action> is
.br
   0 then the byte order mark will be removed from <string$>, if found in
.br
   the string. If <action> is 1 then the UTF8 byte order will be added to
.br
   the string if it is not there already. See also HASBOM to determine if a
.br
   string has a UTF8 byte order mark.
.br
.SH ""
.SS "  EL$"
.SH ""
   EL$
.br
.SH ""
   Type: variable
.br
.SH ""
   The Erase Line variable clears the line from the current cursor position
.br
   towards the end of the line. See also CL$.
.br
.SH ""
.SS "  END"
.SH ""
   END [value]
.br
.SH ""
   Type: statement
.br
.SH ""
   Exits a program. Optionally, a value can be provided which the program can
.br
   return to the shell.
.br
.SH ""
.SS "  ENDFILE"
.SH ""
   ENDFILE(filehandle)
.br
.SH ""
   Type: function
.br
.SH ""
   Function to check if EOF on a file opened with <handle> is reached. If the
.br
   end of a file is reached, the value '1' is returned, else this function
.br
   returns '0'. For an example, see the OPEN statement.
.br
.SH ""
.SS "  ENUM"
.SH ""
   ENUM
.br
       item1, item2, item3
.br
   ENDENUM | END ENUM
.br
.SH ""
   Type: statement
.br
.SH ""
   Enumerates variables automatically. If no value is provided, the
.br
   enumeration starts at 0 and will increase with integer numbers. Example:
.br
.SH ""
   ENUM
.br
       cat, dog, fish
.br
   END ENUM
.br
.SH ""
   It is also possible to explicitly define a value:
.br
.SH ""
   ENUM
.br
       Monday=1, Tuesday=2, Wednesday=3
.br
   END ENUM
.br
.SH ""
.SS "  EPRINT"
.SH ""
   EPRINT [value] | [text] | [variable] | [expression] [FORMAT <format>[TO
.br
   <variable>[SIZE <size>]] | [,] | [;]
.br
.SH ""
   Type: statement
.br
.SH ""
   Same as PRINT but uses 'stderror' as output.
.br
.SH ""
.SS "  EQ"
.SH ""
   x EQ y
.br
.SH ""
   Type: operator
.br
.SH ""
   Verifies if x is equal to y. To improve readability it is also possible to
.br
   use IS instead. Both the EQ and IS operators only can be used in case of
.br
   numerical comparisons. Examples:
.br
.SH ""
   IF q EQ 5 THEN
.br
       PRINT "q equals 5"
.br
   END IF
.br
.SH ""
   BaCon also accepts a single '=' symbol for comparison. Next to the single
.br
   '=' also the double '==' can be used. These work both for numerical
.br
   comparisons and for string comparisons. See also NE.
.br
.SH ""
   IF b$ = "Hello" THEN
.br
       PRINT "world"
.br
   END IF
.br
.SH ""
.SS "  EQUAL"
.SH ""
   EQUAL(x$, y$)
.br
.SH ""
   Type: function
.br
.SH ""
   Compares two strings, and returns 1 if x$ and y$ are equal, or 0 if x$ and
.br
   y$ are not equal. Use OPTION COMPARE to establish case insensitive
.br
   comparison. Example:
.br
.SH ""
   IF EQUAL(a$, "Hello") THEN
.br
       PRINT "world"
.br
   END IF
.br
.SH ""
   The EQUAL function is in place for compatibility reasons. The following
.br
   code also works:
.br
.SH ""
   IF a$ = "Hello" THEN
.br
       PRINT "world"
.br
   END IF
.br
.SH ""
.SS "  ERR$"
.SH ""
   ERR$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the runtime error as a human readable string, identified by x.
.br
   Example:
.br
.SH ""
   PRINT ERR$(ERROR)
.br
.SH ""
.SS "  ERROR"
.SH ""
   ERROR
.br
.SH ""
   Type: variable
.br
.SH ""
   This is a reserved variable, which contains the last error number. This
.br
   variable may be reset during runtime.
.br
.SH ""
.SS "  ESCAPE$"
.SH ""
   ESCAPE$(string$)
.br
.SH ""
   Type: function
.br
.SH ""
   Parses the text in <string$> and converts special characters (like newline
.br
   or Unicode) into their escaped version. This functionality mainly is used
.br
   by C files or JSON files. The special characters are converted into
.br
   default C escape sequences like '\\n', '\\r', '\\t' etc, and into '\\u' and
.br
   '\\U' for Unicode characters. Non-printable binary data in the string is
.br
   not converted. See also UNESCAPE$ to do the opposite. Example:
.br
.SH ""
   PRINT ESCAPE$("Hello world ")
.br
.SH ""
.SS "  EVAL"
.SH ""
   EVAL(x$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the evaluated result of a mathematical function described in a
.br
   string. This function relies on the presence of the 'libmatheval' library
.br
   and development header files on the compiling platform. The EVAL function
.br
   first needs to be enabled using OPTION EVAL.
.br
.SH ""
   The syntax for the mathematical function follows the regular C syntax.
.br
   This means that the operators + (add), - (subtract), * (multiply), /
.br
   (divide) and ^ (exponent) work as usual. More over, the following
.br
   functions are supported as well: exp, log, sqrt, sin, cos, tan, cot, sec,
.br
   csc, asin, acos, atan, acot, asec, acsc, sinh, cosh, tanh, coth, sech,
.br
   csch, asin), acosh, atanh, acoth, asech, acsch, log2e, e, log10e, ln2,
.br
   ln10, pi, pi_2, pi_4, 1_pi, 2_pi, 2_sqrtpi, sqrt, sqrt1_2 and abs.
.br
.SH ""
   The string may contain real variable names from the BaCon program. These
.br
   will be evaluated automatically. The variables must be declared as
.br
   floating type (double) before. Example:
.br
.SH ""
   OPTION EVAL TRUE
.br
   DECLARE x, y TYPE FLOATING
.br
   x = 3
.br
   y = 4
.br
   nr = 5
.br
   PRINT EVAL("x*x + y +" & STR$(nr) & " + 6")
.br
.SH ""
.SS "  EVEN"
.SH ""
   EVEN(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns 1 if x is even, else returns 0.
.br
.SH ""
.SS "  EXCHANGE$"
.SH ""
   EXCHANGE$(haystack$, pos1, pos2 [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Exchanges the token at pos1 with the token at pos2 in haystack$ split by
.br
   delimiter$. The delimiter$ is optional. If it is omitted, then the
.br
   definition from OPTION DELIM is assumed. When specified, it may consist of
.br
   multiple characters. If delimiter$ occurs between double quotes in
.br
   haystack$ then it is ignored. This behavior can be changed by setting
.br
   OPTION QUOTED to FALSE.
.br
.SH ""
   If one of the indicated positions is outside a valid range, the original
.br
   string is returned. Use the FLATTEN$ function to flatten out the returned
.br
   token. See also CHANGE$, TOKEN$ and SPLIT. Examples:
.br
.SH ""
   PRINT EXCHANGE$("a b c d \\"e f\\" g h i j", 8, 5)
.br
   PRINT EXCHANGE$("a,b,c,d,e,f,g,h,i,j", 4, 7, ",")
.br
.SH ""
   The next example code snippet sorts a delimited string. It uses the Bubble
.br
   Sort algorithm:
.br
.SH ""
   t$ = "Kiev Amsterdam Lima Moscow Warschau Vienna Paris Madrid Bonn Bern
.br
   Rome"
.br
   total = AMOUNT(t$)
.br
   WHILE total > 1
.br
       FOR x = 1 TO total-1
.br
           IF TOKEN$(t$, x) > TOKEN$(t$, x+1) THEN t$ = EXCHANGE$(t$, x, x+1)
.br
       NEXT
.br
       DECR total
.br
   WEND
.br
.SH ""
   Note that this is just an example to demonstrate the EXCHANGE$ function.
.br
   Delimited strings can be sorted using the native SORT$ function.
.br
.SH ""
.SS "  EXEC$"
.SH ""
   EXEC$(command$ [, stdin$[, out]])
.br
.SH ""
   Type: function
.br
.SH ""
   Executes an operating system command and returns the result to the BaCon
.br
   program. The exit status of the executed command itself is stored in the
.br
   reserved variable RETVAL. Optionally, a second argument may be used to
.br
   feed to STDIN. Also optionally, a third argument can be specified to
.br
   determine whether all output needs to be captured (0 = default), only
.br
   stdout (1) or only stderr (2). See SYSTEM to plainly execute a system
.br
   command. Example:
.br
.SH ""
   result$ = EXEC$("ls -l")
.br
   result$ = EXEC$("bc", "123*456" & NL$ & "quit")
.br
   PRINT EXEC$("ls  xyz123", NULL, 2)
.br
.SH ""
.SS "  EXIT"
.SH ""
   EXIT
.br
.SH ""
   Type: statement
.br
.SH ""
   Exits a SUB or FUNCTION prematurely. Note that functions which are
.br
   supposed to return a value will return a 0. String functions will return
.br
   an empty string.
.br
.SH ""
   Also note that it is allowed to write EXIT SUB or EXIT FUNCTION to improve
.br
   code readability.
.br
.SH ""
.SS "  EXP"
.SH ""
   EXP(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns e (base of natural logarithms) raised to the power of x.
.br
.SH ""
.SS "  EXPLODE$"
.SH ""
   EXPLODE$(string$, [length [, delimiter$]])
.br
.SH ""
   Type: function
.br
.SH ""
   Splits a string based on <length> characters and returns the result in a
.br
   delimited string using the default delimiter. The <length> parameter is
.br
   optional. If not specified then the default value is 1.
.br
.SH ""
   Also the delimiter$ is optional. If it is omitted, then the definition
.br
   from OPTION DELIM is assumed. When specified, it may consist of multiple
.br
   characters.
.br
.SH ""
   See also SPLIT to create an array based on a delimiter, MERGE$ to join the
.br
   components of a delimited string back to a regular string, and the chapter
.br
   on delimited string functions for more information about delimited
.br
   strings. Example:
.br
.SH ""
   PRINT EXPLODE$("Amsterdam", 2)
.br
.SH ""
.SS "  EXTRACT$"
.SH ""
   EXTRACT$(x$, y$[, flag])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the string defined in <x$> from which the string mentioned in <y$>
.br
   has been removed. The optional flag determines if the <y$> should be taken
.br
   as a regular expression where OPTION COMPARE establishes case insensitive
.br
   expression matching. See also REPLACE$.
.br
.SH ""
   Examples:
.br
.SH ""
   PRINT EXTRACT$("bacon program", "ra")
.br
   PRINT EXTRACT$(name$, "e")
.br
   PRINT EXTRACT$("a b c", " .* ", TRUE)
.br
.SH ""
.SS "  FALSE"
.SH ""
   FALSE
.br
.SH ""
   Type: variable
.br
.SH ""
   Represents and returns the value of '0'.
.br
.SH ""
.SS "  FILEEXISTS"
.SH ""
   FILEEXISTS(filename$)
.br
.SH ""
   Type: function
.br
.SH ""
   Verifies if <filename$> exists. If the file exists, this function returns
.br
   1. Else it returns 0. This function also can be used to verify if a
.br
   directory exists. If <filename$> is a symbolic link, it is dereferenced.
.br
.SH ""
.SS "  FILELEN"
.SH ""
   FILELEN(filename$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the size of a file identified by <filename$>. If an error occurs
.br
   this function returns '-1'. The ERR$ statement can be used to find out the
.br
   error if TRAP is set to LOCAL. Example:
.br
.SH ""
   length = FILELEN("/etc/passwd")
.br
.SH ""
.SS "  FILETIME"
.SH ""
   FILETIME(filename$, type)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the timestamp of a file identified by <filename$>, depending on
.br
   the type of timestamp indicated in <type>. The type can be one of the
.br
   following: 0 = access time, 1 = modification time and 2 = status change
.br
   time. Example:
.br
.SH ""
   stamp = FILETIME("/etc/hosts", 0)
.br
   PRINT "Last access: ", MONTH$(stamp), " ", DAY(stamp), ", ", YEAR(stamp)
.br
.SH ""
.SS "  FILETYPE"
.SH ""
   FILETYPE(filename$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the type of a file identified by <filename$>. If an error occurs
.br
   this function returns '0'. The ERR$ statement can be used find out which
.br
   error if TRAP is set to LOCAL. The following values may be returned:
.br
.SH ""
       Value               Meaning            
.br
         0          Error or undetermined     
.br
         1               Regular file         
.br
         2                Directory           
.br
         3             Character device       
.br
         4               Block device         
.br
         5            Named pipe (FIFO)       
.br
         6              Symbolic link         
.br
         7                  Socket            
.br
.SH ""
.SS "  FILL$"
.SH ""
   FILL$(x, y)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns an <x> amount of character <y>. The value for y must lie between 0
.br
   and 127 in ASCII mode, or between 0 and 1114111 (0x10FFFF) in case OPTION
.br
   UTF8 is enabled. Example printing 10 times the character '@':
.br
.SH ""
   PRINT FILL$(10, ASC("@"))
.br
.SH ""
   Example printing 5 times a smiley character using unicode:
.br
.SH ""
   OPTION UTF8 TRUE
.br
   PRINT FILL$(5, 0x1F600)
.br
.SH ""
   See also COUNT to count the amount of times a character occurs in a
.br
   string.
.br
.SH ""
.SS "  FIND"
.SH ""
   FIND(binary tree, value)
.br
.SH ""
   Type: function
.br
.SH ""
   Verifies the presence of a value in a binary tree. For more information
.br
   and examples, see the chapter on binary trees.
.br
.SH ""
.SS "  FIRST$"
.SH ""
   FIRST$(string$, amount [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Retrieves the remaining elements except the last <amount> from a delimited
.br
   <string$> split by delimiter$. The delimiter$ is optional. If it is
.br
   omitted, then the definition from OPTION DELIM is assumed. When specified,
.br
   it may consist of multiple characters.
.br
.SH ""
   If no delimiter is present in the string, this function will return the
.br
   full <string$>.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE.
.br
.SH ""
   See also TAIL$ to obtain elements counting from the end from the delimited
.br
   string, and HEAD$ to obtain elements counting from the start. Refer to the
.br
   chapter on delimited string functions for more information about delimited
.br
   strings. Example:
.br
.SH ""
   PRINT "Remaining first members: ", FIRST$("Rome Amsterdam Kiev Bern Paris
.br
   London", 2)
.br
.SH ""
.SS "  FLATTEN$"
.SH ""
   FLATTEN$(txt$ [, groupingchar$])
.br
.SH ""
   Type: function
.br
.SH ""
   Flattens out a string where the double quote symbol is used to group parts
.br
   of the string together. Instead of the double quote symbol a different
.br
   character can be specified (optional). See also UNFLATTEN$ for the reverse
.br
   operation. Examples:
.br
.SH ""
   PRINT FLATTEN$("\\"Hello \\\\\\"cruel\\\\\\" world\\"")
.br
   PRINT FLATTEN$(TOKEN$("Madrid,Kiev,\\"New York\\",Paris", 3, ","))
.br
   PRINT FLATTEN$("\\'Hello world\\'", "'")
.br
.SH ""
.SS "  FLOOR"
.SH ""
   FLOOR(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the rounded down value of x. Note that this function returns a
.br
   float value. Refer to CEIL for rounding up.
.br
.SH ""
.SS "  FOR"
.SH ""
   FOR var = x TO|DOWNTO y [STEP z]
.br
       <body>
.br
       [BREAK]|[CONTINUE]
.br
   NEXT [var]
.br
.SH ""
   FOR var$ IN source$ [STEP delimiter$]
.br
       <body>
.br
       [BREAK]|[CONTINUE]
.br
   NEXT [var]
.br
.SH ""
   Type: statement
.br
.SH ""
   With FOR/NEXT a body of statements can be repeated a fixed amount of
.br
   times.
.br
.SH ""
   In the first usage the variable x will be increased (to) or decreased
.br
   (downto) until y with 1, unless a STEP is specified. Example:
.br
.SH ""
   FOR x = 1 TO 10 STEP 0.5
.br
       PRINT x
.br
   NEXT
.br
.SH ""
   In the second usage of FOR, the variable <var$> will be assigned the space
.br
   delimited strings mentioned in source$. Instead of a space delimiter, some
.br
   other delimiter can be specified after the STEP keyword. The delimiter can
.br
   consist of multiple characters. If the <delimiter$> occurs in between
.br
   double quotes, then it is skipped until FOR finds the next one. This
.br
   behavior can be changed by setting OPTION QUOTED to FALSE.
.br
.SH ""
   To prevent empty results, OPTION COLLAPSE can be set to TRUE (or 1). See
.br
   also SPLIT to create an array of delimited strings.
.br
.SH ""
   Example:
.br
.SH ""
   OPTION COLLAPSE TRUE
.br
   FOR x$ IN "Hello cruel world"
.br
       PRINT x$
.br
   NEXT
.br
.SH ""
   FOR y$ IN "1,2,\\"3,4\\",5" STEP ","
.br
       PRINT y$
.br
   NEXT
.br
.SH ""
.SS "  FORK"
.SH ""
   FORK
.br
   <child>
.br
   [ENDFORK [x]] | [END FORK [x]]
.br
.SH ""
   Type: function
.br
.SH ""
   Duplicate the current running program in memory. If the return value is 0,
.br
   then we're in the child process. If the child process needs an explicit
.br
   exit then ENDFORK can be used.
.br
.SH ""
   If the return value > 0, then we are in the parent process; the actual
.br
   value is the process ID of the spawned child.
.br
.SH ""
   If the return value < 0, then an error has occurred. See also REAP to
.br
   detect and cleanup child processes which have ended, or SIGNAL to prevent
.br
   occurring zombie processes altogether. Example:
.br
.SH ""
   pid = FORK
.br
   IF pid = 0 THEN
.br
       PRINT "I am the child, my PID is:", MYPID
.br
       ENDFORK
.br
   ELIF pid > 0 THEN
.br
       PRINT "I am the parent, pid of child:", pid
.br
       REPEAT
.br
           PRINT "Waiting for child to exit"
.br
           SLEEP 50
.br
       UNTIL REAP(pid)
.br
   ELSE
.br
       PRINT "Error in fork"
.br
   ENDIF
.br
.SH ""
.SS "  FP"
.SH ""
   FP (x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the memory address of a function with name 'x'. Example:
.br
.SH ""
   SUB Hello
.br
       PRINT "Hello world"
.br
   END SUB
.br
.SH ""
   DECLARE (*func)() TYPE void
.br
   func = FP(Hello)
.br
   CALL (*func)()
.br
.SH ""
.SS "  FREE"
.SH ""
   FREE x[, y, z, ...]
.br
.SH ""
   Type: statement
.br
.SH ""
   Releases claimed memory (see also MEMORY). Multiple memory pointers can be
.br
   provided. Example:
.br
.SH ""
   mem1 = MEMORY(500)
.br
   mem2 = MEMORY(100)
.br
   FREE mem1, mem2
.br
.SH ""
   This statement also can be used to delete individual members from
.br
   associative arrays:
.br
.SH ""
   FREE array$("abc")
.br
.SH ""
   Lastly, it can delete all members of an associative array in one step:
.br
.SH ""
   FREE array$
.br
.SH ""
.SS "  FUNCTION"
.SH ""
   FUNCTION <name> ()|(STRING s, NUMBER i, FLOATING f, VAR v SIZE t) [TYPE
.br
   <c-type>]
.br
       <body>
.br
       RETURN <x>
.br
   ENDFUNC | ENDFUNCTION | END FUNCTION
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines a function. The variables within a function are visible globally,
.br
   unless declared with the LOCAL statement. Instead of the Bacon types
.br
   STRING, NUMBER and FLOATING for the incoming arguments, also regular
.br
   C-types can be used. If no type is specified, then BaCon will recognize
.br
   the argument type from the variable suffix. In case no suffix is
.br
   available, plain NUMBER type is assumed. With VAR a variable amount of
.br
   arguments can be defined.
.br
.SH ""
   A FUNCTION always returns a value or a string, this should explicitly be
.br
   specified with the RETURN statement. If the FUNCTION returns a string,
.br
   then the function name should end with a '$' to indicate a string by
.br
   value. Function names also may end with the '#' or '%' type suffix, to
.br
   force a float or integer return type.
.br
.SH ""
   Furthermore, it is also possible to explicitly define the type of the
.br
   return value using the TYPE keyword.
.br
.SH ""
   Examples:
.br
.SH ""
   FUNCTION fh2celsius(FLOATING fahrenheit) TYPE float
.br
       PRINT "Calculating Celsius..."
.br
       RETURN (fahrenheit-32)*5/9
.br
   ENDFUNCTION
.br
.SH ""
   FUNCTION Hello$(STRING name$)
.br
       RETURN "Hello " & name$ & " !"
.br
   ENDFUNCTION
.br
.SH ""
.SS "  GETBYTE"
.SH ""
   GETBYTE <memory> FROM <handle> [CHUNK x] [SIZE y]
.br
.SH ""
   Type: statement
.br
.SH ""
   Retrieves binary data into a memory area from a either a file or a device
.br
   identified by handle, with optional amount of <x> bytes depending on
.br
   OPTION MEMTYPE (default amount of bytes = 1). Also optionally, the actual
.br
   amount retrieved can be stored in variable <y>. Use PUTBYTE to write
.br
   binary data.
.br
.SH ""
   Example program:
.br
.SH ""
   OPEN prog$ FOR READING AS myfile
.br
       bin = MEMORY(100)
.br
       GETBYTE bin FROM myfile SIZE 100
.br
   CLOSE FILE myfile
.br
.SH ""
.SS "  GETENVIRON$"
.SH ""
   GETENVIRON$(var$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the value of the environment variable 'var$'. If the environment
.br
   variable does not exist, this function returns an empty string. See
.br
   SETENVIRON to set an environment variable.
.br
.SH ""
.SS "  GETFILE"
.SH ""
   GETFILE <var> FROM <dirhandle> [FTYPE <var>]
.br
.SH ""
   Type: statement
.br
.SH ""
   Reads a file from an opened directory. Subsequent reads return the files
.br
   in the directory. If there are no more files then an empty string is
.br
   returned. Optionally, the FTYPE keyword can store the actual file type of
.br
   the file. The resulting file type numbering follows the same schedule as
.br
   the FILETYPE function. Note that this optional feature is only supported
.br
   on a few file systems, like btrfs, ext2, ext3, ext4, recent xfs, etc.
.br
   Example:
.br
.SH ""
   OPEN "/tmp" FOR DIRECTORY AS mydir
.br
   REPEAT
.br
       GETFILE myfile$ FROM mydir FTYPE thetype
.br
       PRINT "File found: '", myfile$, "' - type: ", thetype
.br
   UNTIL ISFALSE(LEN(myfile$))
.br
   CLOSE DIRECTORY mydir
.br
.SH ""
.SS "  GETKEY"
.SH ""
   GETKEY
.br
.SH ""
   Type: function
.br
.SH ""
   Returns a key from the keyboard without waiting for <RETURN>-key. See also
.br
   INPUT and WAIT. Example:
.br
.SH ""
   PRINT "Press <escape> to exit now..."
.br
   key = GETKEY
.br
   IF key = 27 THEN
.br
       END
.br
   END IF
.br
.SH ""
.SS "  GETLINE"
.SH ""
   GETLINE <variable$> FROM <handle>
.br
.SH ""
   Type: statement
.br
.SH ""
   Reads a line of data from a memory area identified by <handle> into a
.br
   string variable. The memory area can be opened in streaming mode using the
.br
   the OPEN statement (see also the chapter on ramdisks and memory streams).
.br
   A line of text is read until the next newline character. Example:
.br
.SH ""
   GETLINE text$ FROM mymemory
.br
.SH ""
   See also PUTLINE to store lines of text into memory areas.
.br
.SH ""
.SS "  GETPEER$"
.SH ""
   GETPEER$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Gets the IP address and port of the (remote) host connected to a handle
.br
   returned by OPEN FOR NETWORK or OPEN FOR SERVER. Example in case of a
.br
   client connection:
.br
.SH ""
   website$ = "www.basic-converter.org"
.br
   OPEN website$ & ":443" FOR NETWORK AS mynet
.br
   PRINT "Remote IP  is: ", GETPEER$(mynet)
.br
.SH ""
   Example when setting up a TCP server:
.br
.SH ""
   OPEN "localhost:51000" FOR SERVER AS mynet
.br
   PRINT "Peer is: ", GETPEER$(mynet)
.br
   CLOSE SERVER mynet
.br
.SH ""
.SS "  GETX / GETY"
.SH ""
   GETX
.br
   GETY
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the current x and y position of the cursor. An ANSI compliant
.br
   terminal is required. See GOTOXY to set the cursor position.
.br
.SH ""
.SS "  GLOBAL"
.SH ""
   GLOBAL <var>[,var2,var3,...] [TYPE]|ASSOC|TREE <c-type> | [ARRAY <size>]
.br
.SH ""
   Type: statement
.br
.SH ""
   Explicitly declares a variable to a C-type. The ASSOC keyword is used to
.br
   declare associative arrays. The TREE keyword is used to declare binary
.br
   trees. This is always a global declaration, meaning that variables
.br
   declared with the GLOBAL keyword are visible in each part of the program.
.br
   Use LOCAL for local declarations.
.br
.SH ""
   The ARRAY keyword is used to define a dynamic array, which can be resized
.br
   with REDIM at a later stage in the program.
.br
.SH ""
   Optionally, within a SUB or FUNCTION it is possible to use GLOBAL in
.br
   combination with RECORD to define a record variable which is visible
.br
   globally.
.br
.SH ""
   GLOBAL x TYPE float
.br
   GLOBAL q$
.br
   GLOBAL new_array TYPE float ARRAY 100
.br
   GLOBAL name$ ARRAY 25
.br
.SH ""
   Multiple variables of the same type can be declared at once, using a comma
.br
   separated list. In case of pointer variables the asterisk should be
.br
   attached to the variable name:
.br
.SH ""
   GLOBAL x, y, z TYPE int
.br
   GLOBAL *s, *t TYPE long
.br
.SH ""
.SS "  GOSUB"
.SH ""
   GOSUB <label>
.br
.SH ""
   Type: statement
.br
.SH ""
   Jumps to a label defined elsewhere in the program (see also the LABEL
.br
   statement). When a RETURN is encountered, the program will return to the
.br
   last invoked GOSUB and continue from there. Note that a SUB or FUNCTION
.br
   also limits the scope of the GOSUB; it cannot jump outside. Example:
.br
.SH ""
   PRINT "Where are you?"
.br
   GOSUB there
.br
   PRINT "Finished."
.br
   END
.br
   LABEL there
.br
       PRINT "In a submarine!"
.br
       RETURN
.br
.SH ""
.SS "  GOTO"
.SH ""
   GOTO <label>
.br
.SH ""
   Type: statement
.br
.SH ""
   Jumps to a label defined elsewhere in the program. Note that a SUB or
.br
   FUNCTION limits the scope of the GOTO; it cannot jump outside. See also
.br
   the LABEL statement.
.br
.SH ""
.SS "  GOTOXY"
.SH ""
   GOTOXY x, y
.br
.SH ""
   Type: statement
.br
.SH ""
   Puts cursor to position x,y where 1,1 is the upper left of the terminal
.br
   screen. An ANSI compliant terminal is required. Example:
.br
.SH ""
   CLEAR
.br
   FOR x = 5 TO 10
.br
       GOTOXY x, x
.br
       PRINT "Hello world"
.br
   NEXT
.br
   GOTOXY 1, 12
.br
.SH ""
.SS "  GUIDEFINE"
.SH ""
   GUIDEFINE(string$)
.br
.SH ""
   Type: function
.br
.SH ""
   Defines a graphical user interface according to an object/property model.
.br
   Each object (e.g. widget) should occur between curly brackets and should
.br
   contain properties known to the used toolkit. By default, BaCon will
.br
   assume the Xaw toolkit, but this can be overridden by the PRAGMA GUI
.br
   statement. The GUIDEFINE function can only occur once in a BaCon program.
.br
   The return value is a unique handle which should be used in subsequent GUI
.br
   functions. For each object, the 'type and 'name' fields are obligatory.
.br
   See also the chapter on GUI programming for more information. For example:
.br
.SH ""
   id = GUIDEFINE("{ type=window name=window
.br
   resources=\\"*font:lucidasans-18\\" XtNtitle=\\"Hello world application\\" }"
.br
.SH ""
.SS "  GUIEVENT$"
.SH ""
   GUIEVENT$(handle [,TRUE])
.br
.SH ""
   Type: function
.br
.SH ""
   Executes the mainloop of the GUI and returns the name of the widget or
.br
   string from the callback definition. For example:
.br
.SH ""
   WHILE TRUE
.br
       SELECT GUIEVENT$(gui)
.br
           CASE "window"
.br
               BREAK
.br
           CASE "button"
.br
               INCR clicked
.br
       ENDSELECT
.br
   WEND
.br
.SH ""
   The optional second argument allows returning a pointer to data which was
.br
   passed to the internal callback function.
.br
.SH ""
.SS "  GUIFN"
.SH ""
   GUIFN(id, name$, function [, argn])
.br
.SH ""
   Type: function
.br
.SH ""
   Calls a GUI helper function based on a previously defined function
.br
   pointer. It allows to omit specific type casting and does not perform
.br
   argument type checks allowing more code flexibility. For example:
.br
.SH ""
   LOCAL (*show)() = XtPopup TYPE void
.br
   CALL GUIFN(id, "window", show, XtGrabNonexclusive)
.br
.SH ""
.SS "  GUIGET"
.SH ""
   GUIGET(id, name$, property$, &variable)
.br
.SH ""
   Type: function
.br
.SH ""
   Fetches a value set by <property$> from a widget with <name$> in a GUI
.br
   identified by <id>. The <variable> should be a pointer variable, also in
.br
   case of strings. For example:
.br
.SH ""
   CALL GUIGET(dialog, "dialog", XtNvalue, &data)
.br
.SH ""
.SS "  GUISET"
.SH ""
   GUISET(id, name$, property$, variable)
.br
.SH ""
   Type: function
.br
.SH ""
   Sets a value for <property$> regarding widget with <name$> in a GUI
.br
   identified by <id>. For example:
.br
.SH ""
   CALL GUISET(dialog, "label", XtNjustify, XtJustifyLeft)
.br
.SH ""
.SS "  GUIWIDGET"
.SH ""
   GUIWIDGET(name$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the memory address of a widget based on <name$>. This can come
.br
   handy when using foreign GUI functions natively.
.br
.SH ""
.SS "  HASBOM"
.SH ""
   HASBOM(string$)
.br
.SH ""
   Type: function
.br
.SH ""
   Determines whether the string contains a UTF8 byte order mark. Some UTF8
.br
   text files are shipped with a first three bytes of 0xEF 0xBB 0xBF. The
.br
   byte order mark is an optional byte sequence to indicate that the text
.br
   contains UTF8 encoding. If <string$> contains such byte order mark HASBOM
.br
   will return TRUE (1). Otherwise it will return FALSE (0). See also
.br
   EDITBOM$ and the chapter on UTF8 encoding.
.br
.SH ""
.SS "  HASDELIM"
.SH ""
   HASDELIM(string$ [,delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Determines whether the string contains a delimiter or not. If the
.br
   delimiter is not present, FALSE (0) is returned. Otherwise this function
.br
   returns the position of the first delimiter in the string.
.br
.SH ""
   The delimiter$ is optional. If it is omitted, then the definition from
.br
   OPTION DELIM is assumed. When specified, it may consist of multiple
.br
   characters. If delimiter$ occurs between double quotes in string$ then it
.br
   is ignored. Refer to the chapter on delimited string functions for more
.br
   information about delimited strings.
.br
.SH ""
   For regular strings, see INSTR.
.br
.SH ""
.SS "  HASH"
.SH ""
   HASH(data [, length])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns a hash from string data or memory data. The optional <length>
.br
   specifies the amount of bytes to be hashed. If no length is specified, the
.br
   HASH function will use each byte until a 0 is encountered (like in C
.br
   strings). On 64bit systems the returned value is 64bit, on 32bit systems
.br
   the returned value is 32bit.
.br
.SH ""
   The hash algorithm used is based on the Fowler-Noll-Vo algorithm (FNV1a).
.br
   Example to create a hash from a string:
.br
.SH ""
   PRINT HASH("Hello world") FORMAT "%lu\\n"
.br
.SH ""
   Example to create a hash from data in memory:
.br
.SH ""
   mem = MEMORY(16)
.br
   FOR x = 0 TO 15
.br
       POKE mem+x, RANDOM(256)
.br
   NEXT
.br
   PRINT HASH(mem, 16) FORMAT "%lu\\n"
.br
.SH ""
.SS "  HEAD$"
.SH ""
   HEAD$(string$, amount [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Retrieves the first <amount> elements from a delimited string$ split by
.br
   delimiter$. The delimiter$ is optional. If it is omitted, then the
.br
   definition from OPTION DELIM is assumed. When specified, it may consist of
.br
   multiple characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE.
.br
.SH ""
   See also LAST$ to obtain the remaining elements, and TAIL$ to obtain
.br
   elements counting from the end of the delimited string. Refer to the
.br
   chapter on delimited string functions for more information about delimited
.br
   strings. Example:
.br
.SH ""
   PRINT "First 2 members: ", HEAD$("Rome Amsterdam Kiev Bern Paris London",
.br
   2)
.br
.SH ""
.SS "  HEX$"
.SH ""
   HEX$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Calculates the hexadecimal value of x. Returns a string with the result.
.br
   See also DEC to convert back to decimal.
.br
.SH ""
.SS "  HOST$"
.SH ""
   HOST$(name$)
.br
.SH ""
   Type: function
.br
.SH ""
   When name$ contains a hostname this function returns the corresponding IP
.br
   address. If name$ contains an IP address the corresponding hostname is
.br
   returned. If the name or IP address cannot be resolved an error is
.br
   generated. Examples:
.br
.SH ""
   PRINT HOST$("www.google.com")
.br
   PRINT HOST$("127.0.0.1")
.br
.SH ""
.SS "  HOSTNAME$"
.SH ""
   HOSTNAME$()
.br
.SH ""
   Type: function
.br
.SH ""
   Retrieves the actual hostname of the current system where the program is
.br
   running. Example:
.br
.SH ""
   PRINT "My hostname is: ", HOSTNAME$
.br
.SH ""
.SS "  HOUR"
.SH ""
   HOUR(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the hour (0-23) where x is the amount of seconds since January 1,
.br
   1970.
.br
.SH ""
.SS "  IF"
.SH ""
   IF <expression> THEN
.br
       <body>
.br
   [ELIF]
.br
       <body>
.br
   [ELSE]
.br
       [body]
.br
   ENDIF | END IF | FI
.br
.SH ""
   Type: statement
.br
.SH ""
   Execute <body> if <expression> is true. If <expression> is not true then
.br
   run the optional ELSE body. Multiple IF's can be written with ELIF. The IF
.br
   construction should end with ENDIF or END IF or FI. Example:
.br
.SH ""
   a = 0
.br
   IF a > 10 THEN
.br
       PRINT "This is strange:"
.br
       PRINT "a is bigger than 10"
.br
   ELSE
.br
       PRINT "a is smaller than 10"
.br
   END IF
.br
.SH ""
   The IF statement also allows comparing strings. The textual order is
.br
   determined by the standard ASCII table. As a result, capital letters,
.br
   which occur in the ASCII table before the small letters, are considered to
.br
   be 'smaller' than regular letters.
.br
.SH ""
   name$ = "BaCon"
.br
   IF name$ > "basic" THEN
.br
       PRINT "Not printed"
.br
   ELSE
.br
       PRINT "This is correct!"
.br
   END IF
.br
.SH ""
   Equations allow the BETWEEN operator both for numbers and strings:
.br
.SH ""
   IF "c" BETWEEN "basic"; "pascal" THEN PRINT "This is C"
.br
.SH ""
   If only one function or statement has to be executed, then the
.br
   if-statement also can be used without a body. For example:
.br
.SH ""
   IF age > 18 THEN PRINT "You are an adult"
.br
   ELSE INPUT "Your age: ", age
.br
.SH ""
   It is not allowed to mix an IF without a body and an ELSE which contains a
.br
   body, or v.v. For example, the following is not allowed:
.br
.SH ""
   IF year > 1969 THEN PRINT "You are younger"
.br
   ELSE
.br
       PRINT "You are older"
.br
   ENDIF
.br
.SH ""
.SS "  IIF / IIF$"
.SH ""
   IIF(expression, true[, false])
.br
   IIF$(expression, true[, false])
.br
.SH ""
   Type: function
.br
.SH ""
   The inline IF behaves similar to a regular IF, except that it is used as a
.br
   function. The first argument contains the expression to be evaluated, the
.br
   second argument will be returned when the expression is true, and the
.br
   optional last argument will be returned when the expression is false.
.br
.SH ""
   The inline IF function also allows comparing strings. The textual order is
.br
   determined by the standard ASCII table. As a result, capital letters,
.br
   which occur in the ASCII table before the small letters, are considered to
.br
   be 'smaller' than regular letters.
.br
.SH ""
   If the returned values are numeric, a plain IIF must be used. If strings
.br
   are returned, then IIF$ should be used. See also LOOP$ for inline loops.
.br
   Examples:
.br
.SH ""
   nr = IIF(1 <> 2, 10, 20)
.br
   answer$ = IIF$(2 + 2 = 5, "Correct", "Wrong")
.br
   PRINT IIF$(a$ = "B", "Yes it is")
.br
   PRINT IIF(x BETWEEN y;z, 1, -1)
.br
.SH ""
.SS "  IMPORT"
.SH ""
   IMPORT <function[(type arg1, type arg2, ...)]> FROM <library> TYPE <type>
.br
   [ALIAS word]
.br
.SH ""
   Type: statement
.br
.SH ""
   Imports a function from a C library defining the type of return value.
.br
   Optionally, the type of arguments can be specified. Also optionally it is
.br
   possible to define an alias under which the imported function will be
.br
   known to BaCon.
.br
.SH ""
   When the library name is 'NULL', a function will be imported from the
.br
   program itself. In such situation, the ALIAS keyword is obligatory. Note
.br
   that the program must be compiled with a linker flag like
.br
   '-export-dynamic' (GCC) or '-rdynamic' (TCC) to make the target function
.br
   visible for IMPORT.
.br
.SH ""
   An imported library can also be closed afterwards by using CLOSE LIBRARY.
.br
   This will unload any symbols from the current program and release the
.br
   library. It is mandatory to close a library when symbols need to be
.br
   reloaded starting from the first IMPORT statement.
.br
.SH ""
   Examples:
.br
.SH ""
   IMPORT "ioctl" FROM "libc.so" TYPE int
.br
   IMPORT "gdk_draw_line(long, long, int, int, int, int)" FROM
.br
   "libgdk-x11-2.0.so" TYPE void
.br
   IMPORT "fork" FROM "libc.so" TYPE int ALIAS "FORK"
.br
   IMPORT "atan(double)" FROM "libm.so" TYPE double ALIAS "arctangens"
.br
   IMPORT "MyFunc(void)" FROM NULL TYPE int ALIAS "Othername"
.br
   CLOSE LIBRARY "libm.so"
.br
.SH ""
.SS "  INBETWEEN$"
.SH ""
   INBETWEEN$(haystack$, lm$, rm$ [,flag])
.br
.SH ""
   Type: function
.br
.SH ""
   This function returns a substring from <haystack$>, delimited by <lm$> on
.br
   the left and <rm$> on the right. The delimiters may contain multiple
.br
   characters. They are not part of the returned result. The <flag> is
.br
   optional (default value is 0) and specifies if <rm$> should either
.br
   indicate the most right match (greedy indication, flag=1), or should
.br
   return a balanced match (flag=2). See also OUTBETWEEN$. Note that OPTION
.br
   COLLAPSE has no impact on this function. Example usage:
.br
.SH ""
   PRINT INBETWEEN$("Lorem ipsum dolor sit amet", "ipsum", "sit")
.br
   PRINT INBETWEEN$("<p>Chapter one.</p>", "<p>", "</p>")
.br
   a$ = INBETWEEN$("yes no 123 yes 456 yes", "no", "yes", TRUE)
.br
.SH ""
.SS "  INCLUDE"
.SH ""
   INCLUDE <filename>[, func1, func2, ...]
.br
.SH ""
   Type: statement
.br
.SH ""
   Adds a external BaCon file to current program. Includes may be nested. The
.br
   file name extension may be omitted. Optionally, it is possible to specify
.br
   which particular functions in the included file need to be added.
.br
   Examples:
.br
.SH ""
   INCLUDE "beep.bac"
.br
   INCLUDE "canvas"
.br
   INCLUDE "hug", INIT, WINDOW, DISPLAY
.br
.SH ""
.SS "  INCR"
.SH ""
   INCR <x>[, y]
.br
.SH ""
   Type: statement
.br
.SH ""
   Increases variable <x> with 1. Optionally, the variable <x> can be
.br
   increased with <y>.
.br
.SH ""
.SS "  INDEX"
.SH ""
   INDEX(<array>, <value> [, flag])
.br
.SH ""
   Type: function
.br
.SH ""
   This function looks up a <value> in <array> and returns the position in
.br
   the array where the value was found. If the value was not found, then this
.br
   function returns 0.
.br
.SH ""
   By default, BaCon will perform a plain linear lookup. If the optional
.br
   [flag] is set to TRUE, then BaCon assumes the array is ordered and the
.br
   lookup will use the binary search algorithm, resulting in a better
.br
   performance. This function only works for static and dynamic arrays. For
.br
   associative arrays, refer to INDEX$. Examples:
.br
.SH ""
   DECLARE data[] = { 0, 1, 3, 5, 7, 8, 12, 30, 44, 55, 61 }
.br
   PRINT INDEX(data, 61, TRUE)
.br
.SH ""
   DECLARE floats#[] = { 3.2, 5.3, 7.5, 8.6, 12.2, 30.3, 55.5, 61.6}
.br
   PRINT INDEX(floats#, 30.3)
.br
.SH ""
   DECLARE string$[] = { "a", "b", "c", "d", "e" }
.br
   PRINT INDEX(string$, "c")
.br
.SH ""
   DECLARE nr TYPE int ARRAY 5
.br
   nr[0] = 1
.br
   nr[1] = 2
.br
   nr[2] = 6
.br
   nr[3] = 8
.br
   nr[4] = 10
.br
   PRINT INDEX(nr, 10)
.br
.SH ""
.SS "  INDEX$"
.SH ""
   INDEX$(<associative_array>, <value>)
.br
.SH ""
   Type: function
.br
.SH ""
   This function looks up a <value> in <associative_array> and returns the
.br
   index in the array where the value was found. If the value was not found,
.br
   then this function returns an empty string. If INDEX$ refers to a value
.br
   which occurs multiple times, the returned index is the first inserted into
.br
   the associative array. Example:
.br
.SH ""
   DECLARE data$ ASSOC STRING
.br
   data$("name") = "BaCon"
.br
   data$("place") = "Internet"
.br
   data$("language") = "BASIC"
.br
   PRINT INDEX$(data$, "Internet")
.br
.SH ""
.SS "  INPUT"
.SH ""
   INPUT [text[, ... ,]<variable[$]>
.br
.SH ""
   Type: statement
.br
.SH ""
   Interactive input from the user. If the variable ends with a '$' then the
.br
   input is considered to be a string. Otherwise it will be treated as
.br
   numeric. Example:
.br
.SH ""
   INPUT a$
.br
   PRINT "You entered the following: ", a$
.br
.SH ""
   The input-statement also can print text. The input variable always must be
.br
   present at the end of the line. Example:
.br
.SH ""
   INPUT "What is your age? ", age
.br
   PRINT "You probably were born in ", YEAR(NOW) - age
.br
.SH ""
   The INPUT statement by nature is a blocking statement. Note that INPUT
.br
   always will chop off a trailing newline from text captured into a string
.br
   variable, if there is any.
.br
.SH ""
   The OPTION INPUT parameter can be used to define where INPUT should cut
.br
   off the incoming stream from STDIN. This is especially useful in CGI
.br
   programs, for example:
.br
.SH ""
   OPTION INPUT CHR$(4)
.br
   INPUT data$
.br
.SH ""
.SS "  INSERT$"
.SH ""
   INSERT$(source$, x, string$)
.br
.SH ""
   Type: function
.br
.SH ""
   Inserts the string$ into source$ at position <x>. The letters in source$
.br
   starting from position <x> are pushed forward. If x <= 1 then string$ is
.br
   prepended to source$. If position > length of source$ then string$ is
.br
   appended to source$. Example:
.br
.SH ""
   PRINT INSERT$("Hello world", 7, "cruel ")
.br
.SH ""
.SS "  INSTR"
.SH ""
   INSTR(haystack$, needle$ [,z])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the position where needle$ begins in haystack$, optionally
.br
   starting at position z. If not found then this function returns the value
.br
   '0'. See also TALLY to count the occurrences of needle$.
.br
.SH ""
   position = INSTR("Hello world", "wo")
.br
   PRINT INSTR("Don't take my wallet", "all", 10)
.br
.SH ""
.SS "  INSTRREV"
.SH ""
   INSTRREV(haystack$, needle$ [,z])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the position where needle$ begins in haystack$, but start
.br
   searching from the end of haystack$, optionally at position z also
.br
   counting from the end. The result is counted from the beginning of
.br
   haystack$. If not found then this function returns the value '0'.
.br
.SH ""
   See also OPTION STARTPOINT to return the result counted from the end of
.br
   haystack$.
.br
.SH ""
.SS "  INTL$"
.SH ""
   INTL$(x$)
.br
.SH ""
   Type: function
.br
.SH ""
   Specifies that <x$> should be taken into account for internationalization.
.br
   All strings which are surrounded by INTL$ will be candidate for the
.br
   template catalog file. This file is created when BaCon is executed with
.br
   the '-x' switch. See also the chapter about internationalization and the
.br
   TEXTDOMAIN statement.
.br
.SH ""
.SS "  INVERT"
.SH ""
   INVERT(<assoc_array>)
.br
.SH ""
   Type: function
.br
.SH ""
   Swaps the keys and values in an associative array. In case multiple keys
.br
   hold the same value, a collision occurs. In such case, the last occurrence
.br
   of a value is inverted and the INVERT function returns the amount of
.br
   collisions. If all values are unique, then this function returns 0.
.br
.SH ""
   Note that values of numerical associative arrays will silently be
.br
   converted to strings and that the key names will be converted back to the
.br
   numerical type of the array. So if the keys contain regular strings then
.br
   these will be converted to 0 in case of numerical arrays. Example:
.br
.SH ""
   DECLARE example ASSOC int
.br
   example("10") = 33
.br
   example("20") = 12
.br
   example("30") = 44
.br
   example("40") = 44
.br
   PRINT INVERT(example)
.br
   PRINT OBTAIN$(example)
.br
.SH ""
.SS "  ISASCII"
.SH ""
   ISASCII(string$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns TRUE (1) if <string$> only contains ASCII data. If not, FALSE (0)
.br
   is returned. See also TOASCII$. Example:
.br
.SH ""
   PRINT ISASCII("hello world")
.br
.SH ""
.SS "  ISFALSE"
.SH ""
   ISFALSE(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Verifies if x is equal to 0.
.br
.SH ""
.SS "  ISKEY"
.SH ""
   ISKEY(array, string$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns TRUE (1) if <string$> is defined as a key in the associative
.br
   <array>. If not, FALSE (0) is returned. For static and dynamic arrays,
.br
   refer to INDEX. See also NRKEYS to find the amount of keys in an
.br
   associative array. Example:
.br
.SH ""
   DECLARE array ASSOC int
.br
   array("hello") = 25
.br
   array("world") = 30
.br
   array("compound", "key") = 40
.br
   PRINT ISKEY(array, "goodbye")
.br
   PRINT ISKEY(array, "world")
.br
   PRINT ISKEY(array, "compound", "key")
.br
.SH ""
.SS "  ISTOKEN"
.SH ""
   ISTOKEN(string$, token$ [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Verifies if the <token$> occurs in a delimited <string$>. The delimiter$
.br
   is optional. If it is omitted, then the definition from OPTION DELIM is
.br
   assumed. When specified, it may consist of multiple characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE.
.br
.SH ""
   If token$ was found in string$, then this function returns the actual
.br
   position of the token in the delimited string, counting from the left.
.br
   Otherwise it returns '0'. See also TOKEN$. Example:
.br
.SH ""
   string$ = "Kiev Amsterdam Lima Moscow Warschau Vienna Paris Madrid Bonn
.br
   Bern Rome"
.br
   PRINT ISTOKEN(string$, "Paris")
.br
.SH ""
.SS "  ISTRUE"
.SH ""
   ISTRUE(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Verifies if x is not equal to 0.
.br
.SH ""
.SS "  ISUTF8"
.SH ""
   ISUTF8(string$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns TRUE (1) if <string$> is compliant with UTF8 encoding. If not,
.br
   FALSE (0) is returned. Note that also random binary data can accidentally
.br
   be compliant to UTF8 and that ASCII data always is compliant to UTF8. See
.br
   also ISASCII. Example:
.br
.SH ""
   PRINT ISUTF8("Despus maana voy para mi casa")
.br
.SH ""
.SS "  JOIN"
.SH ""
   JOIN <array> [BY <sub>] TO <string> [SIZE <value>]
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement can join elements of a one dimensional string array into a
.br
   single string. The optional argument in BY defines the delimiter string in
.br
   between the array elements. If BY is omitted, then no delimiter is put in
.br
   between the concatenated array elements. The result is stored in the
.br
   <string> argument mentioned by the TO keyword. Optionally, the total
.br
   amount of array elements to be joined can be defined in SIZE. If SIZE is
.br
   omitted then all elements in the array will be joined together. See also
.br
   SPLIT to do the opposite. Example:
.br
.SH ""
   DECLARE name$[3]
.br
   name$[0] = "Hello"
.br
   name$[1] = "cruel"
.br
   name$[2] = "world"
.br
   JOIN name$ BY " " TO result$ SIZE 3
.br
.SH ""
.SS "  LABEL"
.SH ""
   LABEL <label>
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines a label which can be jumped to by using a GOTO, GOSUB or CATCH
.br
   GOTO statement. A label may not contain spaces.
.br
.SH ""
   A label can appear amid existing DATA statements. In such case, RESTORE
.br
   may refer to a label so READ will start reading data from that point. The
.br
   label must be unique throughout the whole program because DATA statements
.br
   are visible globally.
.br
.SH ""
.SS "  LAST$"
.SH ""
   LAST$(string$, amount [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Retrieves the remaining elements except the first <amount> from a
.br
   delimited string$ split by delimiter$. The delimiter$ is optional. If it
.br
   is omitted, then the definition from OPTION DELIM is assumed. When
.br
   specified, it may consist of multiple characters.
.br
.SH ""
   If no delimiter is present in the string, this function will return the
.br
   full <string$>.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See also
.br
   HEAD$ to get the first element(s), and the chapter on delimited string
.br
   functions for more information about delimited strings. Example:
.br
.SH ""
   PRINT "Remaining members: ", LAST$("Rome Amsterdam Kiev Bern Paris
.br
   London", 1)
.br
.SH ""
.SS "  LCASE$"
.SH ""
   LCASE$(x$)
.br
.SH ""
   Type: function
.br
.SH ""
   Converts x$ to lowercase characters and returns the result. Example:
.br
.SH ""
   PRINT LCASE$("ThIs Is All LoWeRcAsE")
.br
.SH ""
.SS "  LEFT$"
.SH ""
   LEFT$(string$[, amount])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns <amount> characters from the left of <string$>. The <amount>
.br
   argument is optional. If omitted, then LEFT$ by default will return 1
.br
   character. See also RIGHT$ and MID$.
.br
.SH ""
.SS "  LEN"
.SH ""
   LEN(x$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the length of ASCII string x$. If OPTION UTF8 is enabled, then the
.br
   LEN function will return the length of UTF8 formatted strings correctly as
.br
   well. See also ULEN.
.br
.SH ""
.SS "  LET"
.SH ""
   LET <var> = <value> | <expr>
.br
.SH ""
   Type: statement
.br
.SH ""
   Assigns a value or result from an expression to a variable. The LET
.br
   statement may be omitted. Example:
.br
.SH ""
   LET a = 10
.br
.SH ""
.SS "  LINENO"
.SH ""
   LINENO
.br
.SH ""
   Type: variable
.br
.SH ""
   Contains the current line number of the program. This variable mainly is
.br
   used for debugging purposes.
.br
.SH ""
.SS "  LOAD$"
.SH ""
   LOAD$(filename$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns a string with the content of the specified text file in one step.
.br
   See BLOAD for loading binary files in one step, and
.br
   OPEN/WRITELN/READLN/CLOSE to read and write to a file using a filehandle.
.br
   Example:
.br
.SH ""
   content$ = LOAD$("bacon.bac")
.br
   PRINT "Content of 'bacon.bac': ", content$
.br
.SH ""
.SS "  LOCAL"
.SH ""
   LOCAL <var>[,var2,var3,...] [TYPE]|ASSOC|TREE <c-type> | [ARRAY <size>]
.br
   [STATIC]
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement only has sense within functions, subroutines or records. It
.br
   defines a local variable <var> with C type <type> which will not be
.br
   visible to other functions, subroutines or records, nor to the main
.br
   program.
.br
.SH ""
   If the TYPE keyword is omitted then variables are assumed to be of 'long'
.br
   type. If TYPE is omitted and the variable name ends with a '$' then the
.br
   variable will be a string.
.br
.SH ""
   The ARRAY keyword is used to define a dynamic array, which can be resized
.br
   with REDIM at a later stage in the program. The optional STATIC keyword
.br
   allows the array to be returned from a function.
.br
.SH ""
   Examples:
.br
.SH ""
   LOCAL tt TYPE int
.br
   LOCAL q$
.br
   LOCAL new_array TYPE float ARRAY 100
.br
   LOCAL name$ ARRAY 25
.br
.SH ""
   LOCAL key$ ASSOC STRING
.br
.SH ""
   Multiple variables of the same type can be declared at once, using a comma
.br
   separated list. In case of pointer variables the asterisk should be
.br
   attached to the variable name:
.br
.SH ""
   LOCAL x, y, z TYPE int
.br
   LOCAL *s, *t TYPE long
.br
.SH ""
.SS "  LOG"
.SH ""
   LOG(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the natural logarithm of x.
.br
.SH ""
.SS "  LOOKUP"
.SH ""
   LOOKUP <assoc> TO <array$> [SIZE <variable>][STATIC]|[SORT[DOWN]]
.br
.SH ""
   Type: statement
.br
.SH ""
   Retrieves all index names created in an associative array. The results are
.br
   stored in <array$>. As it sometimes is unknown how many elements this
.br
   resulting array will contain, the array should not be declared explicitly.
.br
   Instead, LOOKUP will declare the result array dynamically.
.br
.SH ""
   If LOOKUP is being used in a function or sub, then <array> will have a
.br
   local scope. Else <array> will be visible globally, and can be accessed
.br
   within all functions and subs.
.br
.SH ""
   The optional SORT keyword will first sort the elements in the associative
.br
   array before returning the corresponding indexes. A sort in descending
.br
   order can be accomplished by adding the DOWN keyword. As with the SORT
.br
   statement, string and numeric C-types are supported.
.br
.SH ""
   The total amount of elements created in this array is stored in the
.br
   optional <variable>. This variable can be declared explicitly using LOCAL
.br
   or GLOBAL. See also OBTAIN$ to store index names into a delimited string.
.br
   Example:
.br
.SH ""
   LOOKUP mortal TO men$ SIZE amount
.br
   FOR x = 0 TO amount - 1
.br
       PRINT men$[x]
.br
   NEXT
.br
.SH ""
   The optional STATIC keyword allows the created <array> to be returned from
.br
   a function.
.br
.SH ""
.SS "  LOOP"
.SH ""
   LOOP([variable,] nr, expression)
.br
.SH ""
   Type: function
.br
.SH ""
   This is an inline loop which returns the sum of the repeatedly evaluated
.br
   <expression> as a numeric value. The optional <variable> must be a numeric
.br
   variable and <nr> defines how many times the <expression> is carried out.
.br
   If <variable> is not present then the anonymous variable "_" will be used.
.br
   It is not allowed to use nested LOOP constructs or to use LOOP multitple
.br
   times in the same statement. Such code will generate a syntax error during
.br
   conversion time. See also FILL$, or COIL$ for an inline loop creating
.br
   delimited strings, or the inline if IIF$.
.br
.SH ""
   Example to add all numbers mentioned in a string variable:
.br
.SH ""
   a$ = "123456789"
.br
   PRINT LOOP(LEN(a$), VAL(MID$(a$, _, 1)))
.br
.SH ""
.SS "  LOOP$"
.SH ""
   LOOP$([variable,] nr, expression$)
.br
.SH ""
   Type: function
.br
.SH ""
   This is an inline loop which returns the result of the repeatedly
.br
   evaluated <expression$> as a concatenated regular string. The optional
.br
   <variable> must be a numeric variable and <nr> defines how many times the
.br
   <expression$> is carried out. If <variable> is not present then the
.br
   anonymous variable "_" will be used. It is not allowed to use nested LOOP$
.br
   constructs or to use LOOP$ multitple times in the same statement. Such
.br
   code will generate a syntax error during conversion time. See also FILL$,
.br
   or COIL$ for an inline loop creating delimited strings, LOOP for numeric
.br
   calculations, or the inline if IIF$.
.br
.SH ""
   Example to get all letters in the Latin alphabet:
.br
.SH ""
   PRINT LOOP$(i, 26, CHR$(96+i))
.br
.SH ""
   Example to print all elements in a delimited list using the anonymous
.br
   variable "_":
.br
.SH ""
   PRINT LOOP$(AMOUNT(list$), TOKEN$(list$, _))
.br
.SH ""
.SS "  MAKEDIR"
.SH ""
   MAKEDIR <directory>
.br
.SH ""
   Type: statement
.br
.SH ""
   Creates an empty directory. Parent directories are created implicitly. If
.br
   the directory already exists then it is recreated. Errors like write
.br
   permissions, disk quota issues and so on can be captured with CATCH.
.br
   Example:
.br
.SH ""
   MAKEDIR "/tmp/mydir/is/here"
.br
.SH ""
.SS "  MAP"
.SH ""
   MAP <array1> [,array2, ...array<n>] BY <function> TO <array> [SIZE
.br
   <const|variable>] [STATIC]
.br
.SH ""
   Type: statement
.br
.SH ""
   Performs a mapping of a function towards one or more arrays, storing the
.br
   results in another array. All arrays shall have one dimension. The target
.br
   array can be declared previously with the DECLARE or LOCAL statement.
.br
   Using LOCAL in combination with the optional STATIC keyword, the array is
.br
   created so it can be returned from a function. However, if there is no
.br
   explicit previous declaration, then the MAP statement will declare the
.br
   target array implicitly. The STATIC keyword can be used here as well.
.br
.SH ""
   When the target array is declared implicitly, the following logic applies:
.br
   if MAP is being used in a function or sub, then the target <array> will
.br
   have a local scope. Else <array> will be visible globally, and can be
.br
   accessed within all functions and subs.
.br
.SH ""
   The <function> can either be defined by DEF FN, or it can point to a
.br
   regular function. Only the function name should be provided, not the
.br
   arguments. Note that the amount of arguments must be the same as the
.br
   amount of arrays to which the <function> is mapped.
.br
.SH ""
   The SIZE argument is optional. When SIZE is not provided, MAP will apply
.br
   the <function> to all elements in the given arrays. Example:
.br
.SH ""
   DEF FN addition(x, y) = x+y
.br
   MAP array1, array2 BY addition TO result SIZE 5
.br
.SH ""
   In this example, the first 5 elements of array1 and array2 are used for
.br
   the 'addition' function. The results are stored in the array 'result'. See
.br
   also SUM for adding members within the same array.
.br
.SH ""
   String arrays are supported as well:
.br
.SH ""
   word$ = "Hello world this is a program"
.br
   DEF FN func(x$) = LEN(x$)
.br
   SPLIT word$ TO letter$ SIZE total
.br
   MAP letter$ BY func TO new SIZE total
.br
.SH ""
   Here, each word is put into an array, after which the length of the
.br
   individual words is being calculated. The results are then stored in
.br
   another array.
.br
.SH ""
.SS "  MATCH"
.SH ""
   MATCH(string$, pattern$, [amount [,delimiter$]])
.br
.SH ""
   Type: function
.br
.SH ""
   Compares the delimited elements between <string$> and <pattern$>. By
.br
   default, the amount of elements to compare is determined by the amount of
.br
   elements in <string$>. Optionally, the <amount> of elements to be compared
.br
   can be provided explicitly. The value -1 means the default amount of
.br
   elements in <string$>.
.br
.SH ""
   The <pattern$> can use the wildcards '?' and '*'. In case of '?' a single
.br
   element will be matched. The '*' wildcard can be used to match multiple
.br
   elements. To match an actual '?' or '*' in <string$> the wildcard symbol
.br
   has to be escaped in <pattern$> or should be written between double
.br
   quotes. The use of multiple wildcards in <pattern$> is allowed.
.br
.SH ""
   Both the <string$> and the <pattern$> should be delimited by the same
.br
   delimiter$. The delimiter$ argument is optional. If it is omitted, then
.br
   the definition from OPTION DELIM is assumed. When specified, it may
.br
   consist of multiple characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See also
.br
   the chapter on delimited string functions for more information about
.br
   delimited strings. Examples:
.br
.SH ""
   IF  MATCH("a b c d", "a b e f", 2) THEN PRINT "Partially the same"
.br
   IF  MATCH("a b c d", "a b *") THEN PRINT "Matched"
.br
   IF  NOT(MATCH("a b c d", "a b ? c")) THEN PRINT "Not matched"
.br
   IF  MATCH("a b \\"c d\\" d", "a b * d") THEN PRINT "Matched"
.br
   IF  MATCH("a b * d", "a b \\\\* d") THEN PRINT "Matched"
.br
   IF  MATCH("a,b,c,d", "a,b,c,d", -1, ",") THEN PRINT "Matched"
.br
.SH ""
.SS "  MAX / MAX$"
.SH ""
   MAX(x, y)
.br
   MAX$(x$, y$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the maximum value of two numbers or two strings. In case of
.br
   strings, this function will follow the ASCII table to determine the
.br
   'maximum' string. This means that small letters, which occur in the ASCII
.br
   table after capital letters, will have priority. Example:
.br
.SH ""
   PRINT MAX(3, PI)
.br
   PRINT MAX$("hello", "HELLO")
.br
.SH ""
.SS "  MAXNUM"
.SH ""
   MAXNUM(type)
.br
.SH ""
   Type: function
.br
.SH ""
   This function returns the maximum value possible for a certain type.
.br
   Example:
.br
.SH ""
   PRINT MAXNUM(short)
.br
   PRINT MAXNUM(long) FORMAT "%ld\\n"
.br
.SH ""
.SS "  MAXRANDOM"
.SH ""
   MAXRANDOM
.br
.SH ""
   Type: variable
.br
.SH ""
   Reserved variable which contains the maximum value RND can generate. The
.br
   actual value may vary on different operating systems.
.br
.SH ""
.SS "  ME$"
.SH ""
   ME$
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the full path of the current active program. See also CURDIR$ and
.br
   REALPATH$.
.br
.SH ""
.SS "  MEMCHECK"
.SH ""
   MEMCHECK(memory address)
.br
.SH ""
   Type: function
.br
.SH ""
   Verifies if <memory address> is accessible, in which case a '1' is
.br
   returned. If not, this function returns a '0'. Example:
.br
.SH ""
   IF MEMCHECK(mem) THEN POKE mem, 1234
.br
.SH ""
.SS "  MEMORY"
.SH ""
   MEMORY(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Claims memory of x size, returning a handle to the address where the
.br
   memory block resides. Use FREE to release the memory. Note that OPTION
.br
   MEMTYPE can influence the type of memory created. The following example
.br
   creates a memory area to store integers:
.br
.SH ""
   OPTION MEMTYPE int
.br
   area = MEMORY(100)
.br
.SH ""
   Effectively, this will provide a memory area of 100 times the length of an
.br
   integer.
.br
.SH ""
.SS "  MEMREWIND"
.SH ""
   MEMREWIND <handle>
.br
.SH ""
   Type: statement
.br
.SH ""
   Returns to the beginning of a memory area opened with <handle>.
.br
.SH ""
.SS "  MEMTELL"
.SH ""
   MEMTELL(handle)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the current position in the memory area opened with <handle>.
.br
.SH ""
.SS "  MERGE$"
.SH ""
   MERGE$(string$ [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Merges the components of a delimited string to a regular string. The
.br
   delimiter$ is optional. If it is omitted, then the definition from OPTION
.br
   DELIM is assumed. When specified, it may consist of multiple characters.
.br
.SH ""
   See also EXPLODE$ to create a delimited string, and the chapter on
.br
   delimited string functions for more information about delimited strings.
.br
   Example:
.br
.SH ""
   PRINT MERGE$("A m s t e r d a m")
.br
.SH ""
.SS "  MID$"
.SH ""
   MID$(x$, y, [z])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns z characters starting at position y in x$. If y is a negative
.br
   number, then start counting the position from the end of x$. The parameter
.br
   'z' is optional. When this parameter is 0, negative or omitted, then
.br
   everything from position 'y' until the end of the string is returned. See
.br
   also RIP$ for the complement of MID$. Example:
.br
.SH ""
   txt$ = "Hello cruel world"
.br
   PRINT MID$(txt$, 7, 5)
.br
   PRINT MID$(txt$, -11)
.br
   PRINT MID$(txt$, 12, -1)
.br
.SH ""
.SS "  MIN / MIN$"
.SH ""
   MIN(x, y)
.br
   MIN$(x$, y$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the minimum value of two numbers or two strings. In case of
.br
   strings, this function will follow the ASCII table to determine the
.br
   'minimum' string. This means that capital letters, which occur in the
.br
   ASCII table before the small letters, will have priority. Example:
.br
.SH ""
   PRINT MIN(3, PI)
.br
   PRINT MIN$("hello", "HELLO")
.br
.SH ""
.SS "  MINUTE"
.SH ""
   MINUTE(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the minute (0-59) where x is amount of seconds since January 1,
.br
   1970.
.br
.SH ""
.SS "  MOD"
.SH ""
   MOD(x, y)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the modulo of x divided by y.
.br
.SH ""
.SS "  MONTH"
.SH ""
   MONTH(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the month (1-12) in a year, where x is the amount of seconds since
.br
   January 1, 1970.
.br
.SH ""
.SS "  MONTH$"
.SH ""
   MONTH$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the month of the year as string in the system's locale ("January",
.br
   "February", etc), where x is the amount of seconds since January 1, 1970.
.br
.SH ""
.SS "  MYPID"
.SH ""
   MYPID
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the process ID of the current running program.
.br
.SH ""
.SS "  NANOTIMER"
.SH ""
   NANOTIMER
.br
.SH ""
   Type: function
.br
.SH ""
   Keeps track of the amount of nanoseconds the current program is running.
.br
   See also TIMER to measure milliseconds. Example:
.br
.SH ""
   SLEEP 100
.br
   PRINT "Slept ", NANOTIMER, " nanoseconds!"
.br
.SH ""
.SS "  NE"
.SH ""
   x NE y
.br
.SH ""
   Type: operator
.br
.SH ""
   Checks if x and y are not equal. Instead, ISNOT can be used as well to
.br
   improve code readability. The NE and ISNOT operators only work for
.br
   numerical comparisons.
.br
.SH ""
   Next to these, BaCon also accepts the '!=' and '<>' constructs for
.br
   comparison. These work both for numerical and string comparisons. See also
.br
   EQ.
.br
.SH ""
.SS "  NL$"
.SH ""
   NL$
.br
.SH ""
   Type: variable
.br
.SH ""
   Represents the New Line as a string.
.br
.SH ""
.SS "  NNTL$"
.SH ""
   NNTL$(x$, y$, value)
.br
.SH ""
   Type: function
.br
.SH ""
   Specifies that <x$> should be taken into account for internationalization.
.br
   This is a variation to INTL$. With NNTL$ singularities and multitudes can
.br
   be specified, which are candidate for the template catalog file. This file
.br
   is created when BaCon is executed with the '-x' switch. See also
.br
   TEXTDOMAIN and INTL$ and the chapter on internationalization. Example:
.br
.SH ""
   LET x = 2
.br
   PRINT x FORMAT NNTL$("There is %ld green bottle\\n", "There are %ld green
.br
   bottles\\n", x)
.br
.SH ""
.SS "  NOT"
.SH ""
   NOT(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the negation of x.
.br
.SH ""
.SS "  NOW"
.SH ""
   NOW
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the amount of seconds since January 1, 1970.
.br
.SH ""
.SS "  NRKEYS"
.SH ""
   NRKEYS(array)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the amount of index names (keys) in the associative <array>. See
.br
   ISKEY to find out if a key exists in an associative array. Refer to UBOUND
.br
   for other types of arrays. Example:
.br
.SH ""
   DECLARE array ASSOC int
.br
   array("hello") = 25
.br
   array("world") = 30
.br
   PRINT NRKEYS(array)
.br
.SH ""
.SS "  OBTAIN$"
.SH ""
   OBTAIN$(assoc$ [,delimiter$ [, sort]])
.br
.SH ""
   Type: function
.br
.SH ""
   Retrieves all index names from an associative array and returns a
.br
   delimited string split by delimiter$. Multiple indexes in the same element
.br
   are returned space separated. The delimiter$ is optional. If it is
.br
   omitted, then the definition from OPTION DELIM is assumed. When specified,
.br
   it may consist of multiple characters. When NULL, the function will take
.br
   the default delimiter as defined by OPTION DELIM.
.br
.SH ""
   The optional <sort> argument will first sort the values of the associative
.br
   array before retrieving the index names, where TRUE will sort ascending
.br
   and FALSE will sort descending.
.br
.SH ""
   See the chapter on delimited string functions for more information about
.br
   delimited strings. See also LOOKUP to store index names from an
.br
   associative array into a regular array. Example:
.br
.SH ""
   PRINT OBTAIN$(AssocArray, ",")
.br
   PRINT OBTAIN$(mydata, NULL, TRUE)
.br
.SH ""
.SS "  ODD"
.SH ""
   ODD(x)
.br
.SH ""
   Type: Function
.br
.SH ""
   Returns 1 if x is odd, else returns 0.
.br
.SH ""
.SS "  ON"
.SH ""
   ON x <GOTO label1 [, label2[, label<x>]]>|<CALL func1 [, func2 [, funcx]]>
.br
.SH ""
   Type: statement
.br
.SH ""
   Jump to a label or function based on the value of x. When x is 1 then the
.br
   first item is chosen, when x is 2 the second item and so on. When x has a
.br
   higher value than the available labels this statement is ignored. Example:
.br
.SH ""
   ON x GOTO a, b
.br
   PRINT "No label found"
.br
   END
.br
   LABEL a
.br
       PRINT "a"
.br
       END
.br
   LABEL b
.br
       PRINT "b"
.br
       END
.br
.SH ""
   Other example using functions, adding brackets to the called function name
.br
   is optional:
.br
.SH ""
   ON ISTOKEN(list$, item$) CALL setx, sety(), print_str(str$)
.br
.SH ""
.SS "  OPEN"
.SH ""
   OPEN <file|dir|address> FOR
.br
   READING|WRITING|APPENDING|READWRITE|DIRECTORY|NETWORK [FROM
.br
   address[:port]]|SERVER|MEMORY|DEVICE AS <handle>
.br
.SH ""
   Type: statement
.br
.SH ""
   When used with READING, WRITING, APPENDING or READWRITE, this statement
.br
   opens a file assigning a handle to it. The READING keyword opens a file
.br
   for read-only, the WRITING for writing, APPENDING to append data and
.br
   READWRITE opens a file both for reading and writing. Example:
.br
.SH ""
   OPEN "data.txt" FOR READING AS myfile
.br
   WHILE NOT(ENDFILE(myfile)) DO
.br
       READLN txt$ FROM myfile
.br
       IF NOT(ENDFILE(myfile)) THEN
.br
           PRINT txt$
.br
       ENDIF
.br
   WEND
.br
   CLOSE FILE myfile
.br
.SH ""
   When used with DIRECTORY a directory is opened as a stream. Subsequent
.br
   reads will return the files in the directory. Example:
.br
.SH ""
   OPEN "." FOR DIRECTORY AS mydir
.br
   REPEAT
.br
       GETFILE myfile$ FROM mydir
.br
       PRINT "File found: ", myfile$
.br
   UNTIL ISFALSE(LEN(myfile$))
.br
   CLOSE DIRECTORY mydir
.br
.SH ""
   When used with NETWORK a network address is opened as a stream.
.br
   Optionally, the source IP address and port can be specified using FROM.
.br
.SH ""
   OPEN "www.google.com:80" FOR NETWORK AS mynet
.br
   SEND "GET / HTTP/1.1\\r\\nHost: www.google.com\\r\\n\\r\\n" TO mynet
.br
   REPEAT
.br
       RECEIVE dat$ FROM mynet
.br
       total$ = total$ & dat$
.br
   UNTIL ISFALSE(WAIT(mynet, 500))
.br
   PRINT total$
.br
   CLOSE NETWORK mynet
.br
.SH ""
   When used with SERVER the program starts as a server to accept incoming
.br
   network connections. When invoked multiple times in TCP mode using the
.br
   same host and port, OPEN SERVER will not create a new socket, but accept
.br
   another incoming connection. Instead of specifying an IP address, also the
.br
   Unix wildcard '*' can be used to listen to all interfaces. See also OPTION
.br
   NETWORK to set the network protocol.
.br
.SH ""
   OPEN "*:51000" FOR SERVER AS myserver
.br
   WHILE NOT(EQUAL(LEFT$(dat$, 4), "quit")) DO
.br
       RECEIVE dat$ FROM myserver
.br
       PRINT "Found: ", dat$
.br
   WEND
.br
   CLOSE SERVER myserver
.br
.SH ""
   When used with MEMORY a memory area can be used in streaming mode.
.br
.SH ""
   data = MEMORY(500)
.br
   OPEN data FOR MEMORY AS mem
.br
   PUTLINE "Hello cruel world" TO mem
.br
   MEMREWIND mem
.br
   GETLINE txt$ FROM mem
.br
   CLOSE MEMORY mem
.br
   PRINT txt$
.br
.SH ""
   When used with DEVICE, a file or device can be opened in any mode. The
.br
   open mode can set by using OPTION DEVICE. Use PUTBYTE or GETBYTE to write
.br
   and retrieve data from the opened device.
.br
.SH ""
   OPEN "/dev/ttyUSB0" FOR DEVICE AS myserial
.br
   SETSERIAL myserial SPEED B38400
.br
   GETBYTE mem FROM myserial CHUNK 5 SIZE received
.br
   CLOSE DEVICE myserial
.br
.SH ""
.SS "  OPTION"
.SH ""
   OPTION <BASE x> | <COMPARE x> | <SOCKET x> | <NETWORK type [ttl]> |
.br
   <MEMSTREAM x> | <MEMTYPE type> | <COLLAPSE x> | <INTERNATIONAL x> |
.br
   <STARTPOINT x> | <DEVICE x> | <PARSE x> | <FRAMEWORK x> | <VARTYPE x> |
.br
   <QUOTED x> | <DQ x> | <ESC x> | <UTF8 x> | <DELIM x> | <BREAK x> |
.br
   <EXPLICIT x> | <INPUT x> | <ERROR x> | <PROPER x> | <TLS x> | <EVAL x> |
.br
   <NO_C_ESC x>
.br
.SH ""
   Type: statement
.br
.SH ""
   Sets an option to define the behavior of the compiled BaCon program. It is
.br
   recommended to use this statement in the beginning of the program, to
.br
   avoid unexpected results.
.br
.SH ""
     * The BASE argument determines the lower bound of arrays. By default the
.br
       lower bound is set to 0. Note that this setting also has impact on the
.br
       array returned by the SPLIT and LOOKUP statements. It has no impact on
.br
       arrays which assign their values statically at the moment of
.br
       declaration.
.br
.SH ""
     * The COMPARE argument defines if string comparisons in the IF and
.br
       IIF/IIF$ statements and in the BETWEEN operator and also in regular
.br
       expressions with REPLACE$, EXTRACT$, REGEX and WALK$ should be case
.br
       sensitive (0) or not (1). The default is case sensitive (0).
.br
.SH ""
     * The SOCKET argument defines the timeout for setting up a socket to an
.br
       IP address. Default value is 5 seconds.
.br
.SH ""
     * The NETWORK argument defines the type of protocol: TCP, UDP,
.br
       BROADCAST, MULTICAST or SCTP. When MULTICAST is selected also an
.br
       optional value for TTL can be specified. When SCTP is selected an
.br
       optional value for the amount of streams can be specified. Default
.br
       setting for this option is: TCP. Default value for TTL is 1. Default
.br
       amount of SCTP streams is 1.
.br
.SH ""
     * The MEMSTREAM argument allows the handle created by the OPEN FOR
.br
       MEMORY statement to be used as a string variable (1). Default value is
.br
       0.
.br
.SH ""
     * The MEMTYPE argument defines the type of memory to be used by POKE,
.br
       PEEK, MEMORY, RESIZE, PUTBYTE, GETBYTE, COPY, ROL and ROR. Default
.br
       value is 'char' (1 byte). Any valid C type can be used here, for
.br
       example 'float', 'unsigned int', 'long' etc.
.br
.SH ""
     * The COLLAPSE argument specifies if the results of the SPLIT and
.br
       FOR..IN statements and of the delimited string functions may contain
.br
       empty results (0) in case the separator occurs as a sequence in the
.br
       target string, or not (1). Default value is 0.
.br
.SH ""
     * The INTERNATIONAL argument enables support for internationalization of
.br
       strings. It sets the textdomain for INTL$ and NNTL$ to the current
.br
       filename. See also TEXTDOMAIN and the chapter on creating
.br
       internationalization files. The default value is 0.
.br
.SH ""
     * The STARTPOINT argument has impact on the way the INSTRREV function
.br
       returns its results. When set to 1, the result of the INSTRREV
.br
       function is counted from the end of the string. Default value is 0
.br
       (counting from the beginning of the string).
.br
.SH ""
     * The DEVICE argument determines the way a device or file is opened in
.br
       the OPEN FOR DEVICE statement. By default BaCon uses the following
.br
       open mode: O_RDWR|O_NOCTTY|O_SYNC. Other common Unix open modes are
.br
       O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK and O_TRUNC. Please
.br
       refer to the open manpage for more details on the open modes.
.br
.SH ""
     * The PARSE argument defines if BaCon should allow non-BaCon code. It
.br
       can be used to embed foreign functions from external C libraries. Use
.br
       with care, as this option accepts any random piece of text. Errors
.br
       only will popup during compile time, which may be hard to
.br
       troubleshoot. The default value is 1.
.br
.SH ""
     * The FRAMEWORK option is used in case of linking to MacOSX frameworks
.br
       like Cocoa. This option allows multiple frameworks separated by a
.br
       comma. For example: PRAGMA FRAMEWORK COCOA.
.br
.SH ""
     * The VARTYPE option defines the default variable type in case of
.br
       implicit declarations. The default value for this option is: long.
.br
.SH ""
     * The QUOTED argument defines whether text delimiters appearing between
.br
       double quotes should be skipped (1) or not (0). The default is to skip
.br
       delimiters between double quotes (1).
.br
.SH ""
     * The DQ argument defines the symbol for OPTION QUOTED. This is a
.br
       numeric ASCII value between 0 and 255. Default value is 34 (double
.br
       quotes).
.br
.SH ""
     * The ESC argument defines the escape symbol for OPTION DQ. This is a
.br
       numeric ASCII value between 0 and 255. Default value is 92
.br
       (backslash).
.br
.SH ""
     * The UTF8 argument enables all BaCon string functions to process text
.br
       in UTF8 format correctly. The default is to process text as ASCII (0).
.br
.SH ""
     * The DELIM argument defines the delimiter string when processing
.br
       delimited strings. It always should be provided as a static string
.br
       literal. The default value is a single space " ".
.br
.SH ""
     * The BREAK argument prevents and disables the use of BREAK statements
.br
       in generated C code. The default is to allow BREAK statement (TRUE).
.br
.SH ""
     * The EXPLICIT argument enforces the declaration of all variables used
.br
       in a program. The default value is 0 (FALSE), so no variable
.br
       declaration is enforced.
.br
.SH ""
     * The INPUT argument defines where the stream of input characters from
.br
       STDIN should be cut off. By default, INPUT returns when a newline is
.br
       encountered. The default value is "\\n".
.br
.SH ""
     * The ERROR argument sets whether or not a program will exit as soon a
.br
       runtime error occurs. The default is TRUE (exit upon error). If set to
.br
       FALSE, the program must take care of error handling by itself, and
.br
       setting an error callback will be possible. See also the chapter on
.br
       error catching for more information.
.br
.SH ""
     * The PROPER argument sets whether or not the PROPER$ function should
.br
       leave the items in a delimited string intact or not. The default value
.br
       is FALSE, causing the PROPER$ function to lowercase the remainder of
.br
       each item.
.br
.SH ""
     * The TLS argument enables network connections to be TLS encapsulated.
.br
       See the chapter on secure network connections for more details. The
.br
       default value is FALSE.
.br
.SH ""
     * The PRIORITY argument defines the TLS priority string for GnuTLS. By
.br
       default, the priority string is defined as
.br
       "NORMAL:-VERS-TLS1.3:%COMPAT" disabling TLS 1.3.
.br
.SH ""
     * The NO_C_ESC argument can disable the effects of the C escape symbol
.br
       "\\" in string literals. This can come handy when printing ASCII art
.br
       for example. Default value is FALSE (do not disable effects of escape
.br
       symbol in text).
.br
.SH ""
     * The EVAL argument enables code generation for the EVAL function. It
.br
       also adds linking flags for 'libmatheval' to the generated Makefile.
.br
       The default value is FALSE.
.br
.SH ""
.SS "  OR"
.SH ""
   x OR y
.br
.SH ""
   Type: operator
.br
.SH ""
   Performs a logical or between x and y. For the binary or, use the '|'
.br
   symbol.
.br
.SH ""
.SS "  OS$"
.SH ""
   OS$
.br
.SH ""
   Type: function
.br
.SH ""
   Function which returns the name and machine of the current Operating
.br
   System.
.br
.SH ""
.SS "  OUTBETWEEN$"
.SH ""
   OUTBETWEEN$(haystack$, lm$, rm$ [,flag])
.br
.SH ""
   Type: function
.br
.SH ""
   This function returns <haystack$> where the substring delimited by <lm$>
.br
   on the left and <rm$> on the right is cut out. The delimiters may contain
.br
   multiple characters. They are not part of the returned result. The <flag>
.br
   is optional (default value is 0) and specifies if <rm$> should either
.br
   indicate the most right match (greedy indication, flag=1), or should
.br
   return a balanced match (flag=2). See also INSERT$ to insert a string and
.br
   INBETWEEN$ to return the delimited substring. Note that OPTION COLLAPSE
.br
   has no impact on this function. Example usage:
.br
.SH ""
   PRINT OUTBETWEEN$("Lorem ipsum dolor sit amet", "ipsum", "sit")
.br
   a$ = OUTBETWEEN$("yes no 123 yes 456 yes", "no", "yes", TRUE)
.br
.SH ""
.SS "  PARSE"
.SH ""
   PARSE <string$> WITH <pattern$> [BY <delim$>] TO <array$> [SIZE <size>]
.br
   [STATIC]
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement can parse a delimited <string$> using a delimited
.br
   <pattern$> containing wildcards. The matched results are stored in
.br
   <array$> mentioned by the TO keyword. As sometimes it cannot be known in
.br
   advance how many elements this resulting array will contain, the array may
.br
   not be declared before with LOCAL or GLOBAL. The optional BY argument
.br
   determines the delimiter. If the BY keyword is omitted then the default
.br
   definition from OPTION DELIM will be used.
.br
.SH ""
   If PARSE is being used in a function or sub, then <array$> will have a
.br
   local scope. Else <array$> will be visible globally, and can be accessed
.br
   within all functions and subs.
.br
.SH ""
   The total amount of elements created in this array is stored in <size>.
.br
   This variable can be declared explicitly using LOCAL or GLOBAL. The SIZE
.br
   keyword is optional and may be omitted.
.br
.SH ""
   If <delim$> occurs in between double quotes, then it is skipped. This
.br
   behavior can be changed by setting OPTION QUOTED to FALSE. If a double
.br
   quote needs to be present in the <string$>, it must be escaped properly.
.br
.SH ""
   The provided <pattern$> must contain a delimited string with wildcards.
.br
   The wildcard symbol '?' will match one delimited item, and the wildcard
.br
   symbol '*' matches one or more items in the delimited string. Each time a
.br
   match is found it will be added to <array$>. Parsing is executed from left
.br
   to right and stops as soon matching the pattern fails.
.br
.SH ""
   Example usage:
.br
.SH ""
   OPTION BASE 1
.br
   PARSE "a b c d e f" WITH "a ? c * f" TO array$
.br
   FOR i = 1 TO UBOUND(array$)
.br
       PRINT array$[i]
.br
   NEXT
.br
.SH ""
   This example will return two array items, one containing a single element
.br
   and the other containing two delimited elements. See also MATCH to compare
.br
   delimited strings using wildcards and COLLAPSE$ to make sure items in a
.br
   string are separated by one delimiter.
.br
.SH ""
.SS "  PEEK"
.SH ""
   PEEK(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns a value stored at memory address x. The type of the returned value
.br
   can be determined with OPTION MEMTYPE.
.br
.SH ""
.SS "  PI"
.SH ""
   PI
.br
.SH ""
   Type: variable
.br
.SH ""
   Reserved variable containing the number for PI: 3.14159265358979323846.
.br
.SH ""
.SS "  POKE"
.SH ""
   POKE <x>, <y> [SIZE range]
.br
.SH ""
   Type: statement
.br
.SH ""
   Stores a value <y> at memory address <x>. The optional SIZE keyword can be
.br
   used to store the value <y> in a complete range of addresses starting from
.br
   address <x>. Use PEEK to retrieve a value from a memory address. Use
.br
   OPTION MEMTYPE to determine the actual size of the type to store.
.br
   Examples:
.br
.SH ""
   OPTION MEMTYPE float
.br
   mem = MEMORY(SIZEOF(float))
.br
   POKE mem, 32.123
.br
   area = MEMORY(1024)
.br
   POKE area, 0 SIZE 1024
.br
.SH ""
.SS "  POW"
.SH ""
   POW(x, y)
.br
.SH ""
   Type: function
.br
.SH ""
   Raise x to the power of y.
.br
.SH ""
.SS "  PRAGMA"
.SH ""
   PRAGMA <OPTIONS x> | <LDFLAGS x> [TRUE] | <COMPILER x> | <INCLUDE x> | <RE
.br
   x [INCLUDE y] [LDFLAGS z]> | <GUI x>
.br
.SH ""
   Type: statement
.br
.SH ""
   Instead of passing command line arguments to influence the behavior of the
.br
   compiler, it is also possible to define these arguments programmatically.
.br
   Mostly these arguments are used when embedding variables or library
.br
   dependent structures into BaCon code. When no valid option to PRAGMA is
.br
   provided, BaCon will translate to the plain compiler directive '#pragma'.
.br
   Example when SDL code is included in the BaCon program:
.br
.SH ""
   PRAGMA LDFLAGS SDL
.br
   PRAGMA INCLUDE SDL/SDL.h
.br
.SH ""
   Example when GTK2 code is included in the BaCon program:
.br
.SH ""
   PRAGMA LDFLAGS `pkg-config --libs gtk+-2.0`
.br
   PRAGMA INCLUDE gtk-2.0/gtk/gtk.h
.br
   PRAGMA COMPILER gcc
.br
.SH ""
   Example on passing optimization parameters to the compiler:
.br
.SH ""
   PRAGMA OPTIONS -O2 -s
.br
.SH ""
   Multiple arguments can be passed too:
.br
.SH ""
   PRAGMA LDFLAGS iup cd iupcd im
.br
   PRAGMA INCLUDE iup.h cd.h cdiup.h im.h im_image.h
.br
.SH ""
   The LDFLAGS argument can specify whether the flags should occur before
.br
   other flags using TRUE:
.br
.SH ""
   PRAGMA LDFLAGS -Wl,--no-as-needed TRUE
.br
.SH ""
   Example specifying a regular expression engine like PCRE (see the chapter
.br
   on Regular Expressions for more details):
.br
.SH ""
   PRAGMA RE pcre INCLUDE <pcreposix.h> LDFLAGS -lpcreposix
.br
.SH ""
   Example using an OpenMP pragma definition:
.br
.SH ""
   PRAGMA omp parallel for private(x)
.br
.SH ""
   Example specifying a GTK backend for the GUI functions:
.br
.SH ""
   PRAGMA GUI gtk3
.br
.SH ""
.SS "  PRINT"
.SH ""
   PRINT [value] | [text] | [variable] | [expression] [FORMAT <format>[TO
.br
   <variable> [SIZE <size>]]] | [,] | [;]
.br
.SH ""
   Type: statement
.br
.SH ""
   Prints a numeric value, text, variable or result from expression to
.br
   standard output. As with most BASICs, the PRINT statement may be
.br
   abbreviated using the '?' symbol. A semicolon at the end of the line
.br
   prevents printing a newline. For printing to stderr, see EPRINT. Examples:
.br
.SH ""
   PRINT "This line does ";
.br
   PRINT "end here: ";
.br
   PRINT linenr + 2
.br
.SH ""
   Multiple arguments maybe used but they must be separated with a comma.
.br
   Examples:
.br
.SH ""
   PRINT "This is operating system: ", OS$
.br
   PRINT "Sum of 1 and 2 is: ", 1 + 2
.br
.SH ""
   The FORMAT argument is optional and can be used to specify different types
.br
   in the PRINT argument. The syntax of FORMAT is similar to the printf
.br
   argument in C. Example:
.br
.SH ""
   PRINT "My age is ", 42, " years which is ", 12 + 30 FORMAT "%s%d%s%d\\n"
.br
.SH ""
   The result also can be printed to a string variable. This has to be done
.br
   in combination with FORMAT. To achieve this, use the keyword TO.
.br
   Optionally, the total amount of resulting characters can be provided with
.br
   the SIZE keyword. If no size is given, BaCon will use its default internal
.br
   buffer size (512 characters).
.br
.SH ""
   PRINT "Hello cruel world" FORMAT "%s" TO hello$
.br
   PRINT mytime FORMAT "Time is now: %d" TO result$ SIZE 32
.br
.SH ""
   t = NOW + 300
.br
   PRINT HOUR(t), MINUTE(t), SECOND(t) FORMAT "%.2ld%.2ld%.2ld" TO time$
.br
   PRINT MONTH$(t) FORMAT "%s" TO current$ SIZE 15
.br
.SH ""
.SS "  PROPER$"
.SH ""
   PROPER$(string$ [,delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Capitalizes the first letter of all elements in a delimited string split
.br
   by delimiter$. By default, other letters are put to lowercase. This
.br
   behavior can be altered by setting OPTION PROPER.
.br
.SH ""
   The delimiter$ is optional. If it is omitted, then the definition from
.br
   OPTION DELIM is assumed. When specified, it may consist of multiple
.br
   characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See the
.br
   chapter on delimited string functions for more information about delimited
.br
   strings. Example:
.br
.SH ""
   PRINT PROPER$("hEllO crUEl wOrLd")
.br
.SH ""
.SS "  PROTO"
.SH ""
   PROTO <function name>[,function name [, ...]] [ALIAS word] [TYPE c-type]
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines a foreign function so it is accepted by the BaCon parser. Multiple
.br
   function names may be mentioned, but these should be separated by a comma.
.br
   Optionally, PROTO accepts an alias which can be used instead of the
.br
   original function name. Also, PROTO can define a c-type to define the type
.br
   of return value for a foreign function.
.br
.SH ""
   During compilation the BaCon program must explicitly be linked with an
.br
   external library to resolve the function name. See also OPTION PARSE to
.br
   allow foreign functions unconditionally. Examples:
.br
.SH ""
   PROTO glClear, glClearColor, glEnable
.br
   PROTO "glutSolidTeapot" ALIAS "TeaPot"
.br
   PROTO "gtk_check_version(int,int,int)" TYPE char*
.br
.SH ""
.SS "  PULL"
.SH ""
   PULL <x>
.br
.SH ""
   Type: statement
.br
.SH ""
   Puts a value from the internal stack into variable <x>. The argument must
.br
   be a variable. The stack will decrease to the next available value.
.br
.SH ""
   If the internal stack has reached its last value, subsequent PULL's will
.br
   retrieve this last value. If no value has been pushed before, a PULL will
.br
   deliver 0 for numeric values and an empty string for string values. See
.br
   PUSH to push values to the stack.
.br
.SH ""
.SS "  PUSH"
.SH ""
   PUSH <x>|<expression>
.br
.SH ""
   Type: statement
.br
.SH ""
   Pushes a value <x> or expression to the internal stack. There is no limit
.br
   to the amount of values which can be put onto the stack other than the
.br
   available memory. The principle of the stack is Last In, First Out. The
.br
   reserved variable SP provides the total amount of elements currently on
.br
   the stack.
.br
.SH ""
   See also PULL to get a value from the stack.
.br
.SH ""
   ' Initially create a new 0 value for stack
.br
   ' This will only be 0 when stack wasn't declared before
.br
   PULL stack
.br
   PUSH stack
.br
   ' Increase and push the stack 2x
.br
   ' Stack has now 3 values
.br
   INCR stack
.br
   PUSH stack
.br
   PUSH "End"
.br
   PULL var$
.br
   ' Print and pull current stack value - will return "end" 1 0
.br
   PRINT var$
.br
   PULL stack
.br
   PRINT stack
.br
   PULL stack
.br
   PRINT stack
.br
.SH ""
.SS "  PUTBYTE"
.SH ""
   PUTBYTE <memory> TO <handle> [CHUNK x] [SIZE y]
.br
.SH ""
   Type: statement
.br
.SH ""
   Store binary data from a memory area to either a file or a device
.br
   identified by handle, with an optional amount of <x> bytes, depending on
.br
   OPTION MEMTYPE (default amount of bytes = 1). Also optionally, the actual
.br
   amount stored can be captured in variable <y>.
.br
.SH ""
   This statement is the inverse of GETBYTE, refer to this command for an
.br
   example.
.br
.SH ""
.SS "  PUTLINE"
.SH ""
   PUTLINE "text"|<variable$> TO <handle>
.br
.SH ""
   Type: statement
.br
.SH ""
   Write a line of string data to a memory area identified by handle. The
.br
   line will be terminated by a newline character. The memory area must be
.br
   set in streaming mode first using OPEN (see also the chapter on ramdisks
.br
   and memory streams). Example:
.br
.SH ""
   PUTLINE "hello world" TO mymemory
.br
.SH ""
   See also GETLINE to retrieve a line of text from a memory area.
.br
.SH ""
.SS "  RAD"
.SH ""
   RAD(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the radian value of x degrees. Example:
.br
.SH ""
   PRINT RAD(45)
.br
.SH ""
.SS "  RANDOM"
.SH ""
   RANDOM (x)
.br
.SH ""
   Type: function
.br
.SH ""
   This is a convenience function to generate a random integer number between
.br
   0 and x - 1. See also RND for more flexibility in creating random numbers.
.br
   Example creating a random number between 1 and 100:
.br
.SH ""
   number = RANDOM(100) + 1
.br
.SH ""
.SS "  READ"
.SH ""
   READ <x1[, x2, x3, ...]>
.br
.SH ""
   Type: statement
.br
.SH ""
   Reads a value from a DATA block into variable <x>. Example:
.br
.SH ""
   LOCAL dat[8]
.br
   FOR i = 0 TO 7
.br
       READ dat[i]
.br
   NEXT
.br
   DATA 10, 20, 30, 40, 50, 60, 70, 80
.br
.SH ""
   Also, multiple variables may be provided:
.br
.SH ""
   READ a, b, c, d$
.br
   DATA 10, 20, 30, "BaCon"
.br
.SH ""
   See RESTORE to define where to start reading the data.
.br
.SH ""
.SS "  READLN"
.SH ""
   READLN <var> FROM <handle>
.br
.SH ""
   Type: statement
.br
.SH ""
   Reads a line of ASCII data from a file identified by <handle> into
.br
   variable <var>. See the GETBYTE statement to read binary data. Example:
.br
.SH ""
   READLN txt$ FROM myfile
.br
.SH ""
.SS "  REALPATH$"
.SH ""
   REALPATH$(filename$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the absolute full path and name of a given filename. Symbolic
.br
   links are resolved as well as relative references like '../'. See also
.br
   CURDIR$.
.br
.SH ""
.SS "  REAP"
.SH ""
   REAP(pid)
.br
.SH ""
   Type: function
.br
.SH ""
   After a forked process has ended, it can turn into a so-called 'zombie'
.br
   process. This function can remove such process from the process list,
.br
   using the process ID as an argument. When the value -1 is used as
.br
   argument, REAP will remove any zombie child process.
.br
.SH ""
   The return value of REAP indicates the process ID of the process which was
.br
   removed from the process list successfully. If the return value is 0, then
.br
   no child process has finished yet, and no process ID has been removed.
.br
   When the return value is -1, an error has occurred (a common mistake is
.br
   providing a wrong process ID value).
.br
.SH ""
   This function does not pause and returns immediately. For an example,
.br
   refer to FORK.
.br
.SH ""
.SS "  RECEIVE"
.SH ""
   RECEIVE <var> FROM <handle> [CHUNK <chunksize>] [SIZE <amount>]
.br
.SH ""
   Type: statement
.br
.SH ""
   Reads data from a network location identified by handle into a string
.br
   variable or memory area. Subsequent reads return more data until the
.br
   network buffer is empty. The chunk size can be determined with the
.br
   optional CHUNK keyword. In case of TLS connections, it is recommended to
.br
   use a multitude of 16k for the chunk size.
.br
.SH ""
   The amount of bytes actually received can be retrieved by using the
.br
   optional SIZE keyword. If the amount of bytes received is 0, then the
.br
   other side has closed the connection in an orderly fashion. In such a
.br
   situation the network connection needs to be reopened. Example:
.br
.SH ""
   OPEN "www.google.com:80" FOR NETWORK AS mynet
.br
   SEND "GET / HTTP/1.1\\r\\nHost: www.google.com\\r\\n\\r\\n" TO mynet
.br
   REPEAT
.br
       RECEIVE dat$ FROM mynet
.br
       total$ = total$ & dat$
.br
   UNTIL ISFALSE(WAIT(mynet, 500))
.br
   CLOSE NETWORK mynet
.br
.SH ""
.SS "  RECORD"
.SH ""
   RECORD <var>[ARRAY <x>]
.br
       LOCAL <member1> TYPE <type>
.br
       LOCAL <member2> TYPE <type>
.br
       ....
.br
   END RECORD
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines a record <var> with members. If the record is defined in the main
.br
   program, it automatically will be visible globally. If the record is
.br
   defined within a function, the record will have a local scope, meaning
.br
   that it is only visible within that function. To declare a global record
.br
   in a function, use the DECLARE or GLOBAL keyword.
.br
.SH ""
   The members of a record should be defined using the LOCAL statement and
.br
   can be accessed with the 'var.member' notation. See the chapter on records
.br
   for more details on the usage of records. Also refer to WITH for assigning
.br
   values to multiple members at the same time. Example:
.br
.SH ""
   RECORD var
.br
       LOCAL x
.br
       LOCAL y
.br
   END RECORD
.br
   var.x = 10
.br
   var.y = 20
.br
   PRINT var.x + var.y
.br
.SH ""
.SS "  REDIM"
.SH ""
   REDIM <var> TO <size>
.br
.SH ""
   Type: statement
.br
.SH ""
   Redimensions a one dimensional dynamic array to a new size. The contents
.br
   of the array will be preserved. If the array becomes smaller then the
.br
   elements at the end of the array will be cleared. The dynamic array has to
.br
   be declared previously using DECLARE or LOCAL. Example:
.br
.SH ""
   REDIM a$ TO 20
.br
.SH ""
.SS "  REGEX"
.SH ""
   REGEX (txt$, expr$)
.br
.SH ""
   Type: function
.br
.SH ""
   Applies a POSIX Extended Regular Expression expr$ to the string txt$. If
.br
   the expression matches, the position of the first match is returned. If
.br
   not, this function returns '0'. The length of the last match is returned
.br
   in the reserved variable REGLEN.
.br
.SH ""
   Use OPTION COMPARE to set case sensitive matching. Note that this function
.br
   does not support non-greedy matching. See the chapter on regular
.br
   expressions to specify different regular expression engines for more
.br
   flexibility. Examples:
.br
.SH ""
   ' Does the string match alfanum character
.br
   PRINT REGEX("Hello world", "[[:alnum:]]")
.br
.SH ""
   ' Does the string *not* match a number
.br
   PRINT REGEX("Hello world", "[^0-9]")
.br
.SH ""
   ' Does the string contain an a, l or z
.br
   PRINT REGEX("Hello world", "a|l|z")
.br
.SH ""
.SS "  REGLEN"
.SH ""
   REGLEN
.br
.SH ""
   Type: variable
.br
.SH ""
   Reserved variable containing the length of the last REGEX match.
.br
.SH ""
.SS "  RELATE"
.SH ""
   RELATE <assocA> TO <assocB>[, assocC, ...]
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement creates a relation between associative arrays. Effectively
.br
   this will result into duplication of settings; an index in array <assocA>
.br
   also will be set in array <assocB>. A previous declaration of the
.br
   associative arrays involved is required. Example:
.br
.SH ""
   DECLARE human, mortal ASSOC int
.br
   RELATE human TO mortal
.br
   human("socrates") = TRUE
.br
   PRINT mortal("socrates")
.br
.SH ""
.SS "  REM"
.SH ""
   REM [remark]
.br
.SH ""
   Type: statement
.br
.SH ""
   Adds a comment to your code. Any type of string may follow the REM
.br
   statement. Instead of REM also the single quote symbol ' maybe used to
.br
   insert comments in the code.
.br
.SH ""
   BaCon also accepts C-style block comments: this can be done by surrounding
.br
   multiple lines using /* and */.
.br
.SH ""
.SS "  RENAME"
.SH ""
   RENAME <filename> TO <new filename>
.br
.SH ""
   Type: statement
.br
.SH ""
   Renames a file. If different paths are included the file is moved from one
.br
   path to the other. Note that an error occurs when the target directory is
.br
   on a different partition. Example:
.br
.SH ""
   RENAME "tmp.txt" TO "real.txt"
.br
.SH ""
.SS "  REPEAT"
.SH ""
   REPEAT
.br
       <body>
.br
       [BREAK]|[CONTINUE]
.br
   UNTIL <equation>
.br
.SH ""
   Type: statement
.br
.SH ""
   The REPEAT/UNTIL construction repeats a body of statements. The difference
.br
   with WHILE/WEND is that the body will be executed at least once. The
.br
   optional BREAK statement can be used to break out the loop. With CONTINUE
.br
   part of the body can be skipped. The BETWEEN operator is allowed in the
.br
   equation. Example:
.br
.SH ""
   REPEAT
.br
       C = GETKEY
.br
   UNTIL C = 27
.br
.SH ""
.SS "  REPLACE$"
.SH ""
   REPLACE$(haystack$, needle$, replacement$ [, flag])
.br
.SH ""
   Type: function
.br
.SH ""
   Substitutes a substring <needle$> in <haystack$> with <replacement$> and
.br
   returns the result. The replacement does not necessarily need to be of the
.br
   same size as the substring. With the optional flag set to 1 the <needle$>
.br
   should be taken as a regular expression, and OPTION COMPARE impacts case
.br
   insensitive matching. With the optional flag set to 2, REPLACE$ will
.br
   behave as a translate, meaning that the characters in <needle$> will be
.br
   replaced by the successive characters in <replacement$>. See also
.br
   EXTRACT$.
.br
.SH ""
   Examples:
.br
.SH ""
   PRINT REPLACE$("Hello world", "l", "p")
.br
   PRINT REPLACE$("Some text", "me", "123")
.br
   PRINT REPLACE$("Goodbye <all>", "<.*>", "123", TRUE)
.br
   PRINT REPLACE$("abc123def", "[[:digit:]]", "x", 1)
.br
   PRINT REPLACE$("Hello world", "old", "pme", 2)
.br
.SH ""
.SS "  RESIZE"
.SH ""
   RESIZE <x> TO <y>
.br
.SH ""
   Type: statement
.br
.SH ""
   Resizes memory area starting at address <x> to an amount of <y> of the
.br
   type determined by OPTION MEMTYPE. If the area is enlarged, the original
.br
   contents of the area remain intact.
.br
.SH ""
.SS "  RESTORE"
.SH ""
   RESTORE [label]
.br
.SH ""
   Type: statement
.br
.SH ""
   Restores the internal DATA pointer(s) to the beginning of the first DATA
.br
   statement.
.br
.SH ""
   Optionally, the restore statement allows a LABEL from where the internal
.br
   DATA pointer needs to be restored. See also READ. Example:
.br
.SH ""
   DATA 1, 2, 3, 4, 5
.br
   LABEL txt
.br
   DATA "Hello", "world", "this", "is", "BaCon"
.br
   RESTORE txt
.br
   READ dat$
.br
.SH ""
.SS "  RESUME"
.SH ""
   RESUME
.br
.SH ""
   Type: function
.br
.SH ""
   When an error is caught, this statement tries to continue after the
.br
   statement where an error occurred. Example:
.br
.SH ""
   TRAP LOCAL
.br
   CATCH GOTO print_err
.br
   DELETE FILE "somefile.txt"
.br
   PRINT "Resumed..."
.br
   END
.br
   LABEL print_err
.br
       PRINT ERR$(ERROR)
.br
       RESUME
.br
.SH ""
.SS "  RETURN"
.SH ""
   RETURN [value]
.br
.SH ""
   Type: statement
.br
.SH ""
   If RETURN has no argument it will return to the last invoked GOSUB. If no
.br
   GOSUB was invoked previously then RETURN has no effect.
.br
.SH ""
   Only in case of functions the RETURN statement must contain a value. This
.br
   is the value which is returned when the FUNCTION is finished.
.br
.SH ""
.SS "  RETVAL"
.SH ""
   RETVAL
.br
.SH ""
   Type: variable
.br
.SH ""
   Reserved variable containing the return status of the operating system
.br
   commands executed by SYSTEM or EXEC$.
.br
.SH ""
.SS "  REV$"
.SH ""
   REV$(string$ [,delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Puts all elements in a delimited string split by delimiter$ in reverse
.br
   order. The delimiter$ is optional. If it is omitted, then the definition
.br
   from OPTION DELIM is assumed. When specified, it may consist of multiple
.br
   characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See also
.br
   the chapter on delimited string functions for more information about
.br
   delimited strings. Example:
.br
.SH ""
   PRINT "Reverted members: ", REV$("Rome Amsterdam Kiev Bern Paris London")
.br
.SH ""
.SS "  REVERSE$"
.SH ""
   REVERSE$(x$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the reverse of x$.
.br
.SH ""
.SS "  REWIND"
.SH ""
   REWIND <handle>
.br
.SH ""
   Type: statement
.br
.SH ""
   Returns to the beginning of a file opened with <handle>.
.br
.SH ""
.SS "  RIGHT$"
.SH ""
   RIGHT$(string$[, amount])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns <amount> characters from the right of <string$>. The <amount>
.br
   argument is optional. If omitted, then RIGHT$ by default will return 1
.br
   character. See also LEFT$ and MID$.
.br
.SH ""
.SS "  RIP$"
.SH ""
   RIP$(x$, y, [z])
.br
.SH ""
   Type: function
.br
.SH ""
   This function is the complement of MID$. It returns the characters which
.br
   are left after position <y> in <x$> with optional length <z> is omitted.
.br
   If y is a negative number, then start counting the position from the end
.br
   of x$. The parameter 'z' is optional. When this parameter is 0, negative
.br
   or left out, then everything from position 'y' until the end of the string
.br
   is omitted. Example:
.br
.SH ""
   txt$ = "Hello cruel world"
.br
   PRINT RIP$(txt$, 7, 5)
.br
   PRINT RIP$(txt$, -11)
.br
   PRINT RIP$(txt$, 12, -1)
.br
.SH ""
.SS "  RND"
.SH ""
   RND
.br
.SH ""
   Type: function
.br
.SH ""
   Returns a random number between 0 and the reserved variable MAXRANDOM. The
.br
   generation of random numbers can be seeded with the statement SEED. See
.br
   also the function RANDOM for a more convenient way of generating random
.br
   numbers. Example:
.br
.SH ""
   SEED NOW
.br
   x = RND
.br
.SH ""
.SS "  ROL"
.SH ""
   ROL(nr)
.br
.SH ""
   Type: function
.br
.SH ""
   This function performs a binary shift to the left. The highest bit will be
.br
   recycled into bit 0. The total amount of bits in a value is determined by
.br
   the MEMTYPE option.
.br
.SH ""
   OPTION MEMTYPE short
.br
   PRINT ROL(32768)
.br
.SH ""
.SS "  ROR"
.SH ""
   ROR(nr)
.br
.SH ""
   Type: function
.br
.SH ""
   This function performs a binary shift to the right. The lowest bit will be
.br
   recycled into the highest, depending on the setting of the MEMTYPE option.
.br
.SH ""
   OPTION MEMTYPE int
.br
   PRINT ROR(1)
.br
.SH ""
.SS "  ROTATE$"
.SH ""
   ROTATE$(string$, step [,delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Rotates all elements in a delimited string split by delimiter$ <step>
.br
   positions forward. In case the <step> parameter is a negative number, the
.br
   rotation will be backwards. The delimiter$ is optional. If it is omitted,
.br
   then the definition from OPTION DELIM is assumed. When specified, it may
.br
   consist of multiple characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See also
.br
   the chapter on delimited string functions for more information about
.br
   delimited strings. Example:
.br
.SH ""
   PRINT ROTATE$("Rome Amsterdam Kiev Bern Paris London", 2)
.br
.SH ""
.SS "  ROUND"
.SH ""
   ROUND(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Rounds x to the nearest integer number. For compatibility reasons, the
.br
   keyword INT may be used instead. Note that this function always returns an
.br
   integer value.
.br
.SH ""
   See also FLOOR to round down to the nearest the integer and MOD to get the
.br
   fraction from a fractional number.
.br
.SH ""
.SS "  ROWS"
.SH ""
   ROWS
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the amount of rows in the current ANSI compliant terminal. Use
.br
   COLUMNS to get the amount of columns.
.br
.SH ""
.SS "  RUN"
.SH ""
   RUN <command$>
.br
.SH ""
   Type: statement
.br
.SH ""
   Executes an operating system command thereby transferring control. This
.br
   effectively means that the current program is left permanently, the
.br
   process ID is preserved and that this statement does not return to the
.br
   BaCon program. Typically, the RUN statement is used at the end of a BaCon
.br
   program. It can only execute one system command at a time.
.br
.SH ""
   The behavior of RUN differs from the SYSTEM statement, which can execute a
.br
   set of compound commands in a shell and can query the exit status. See
.br
   also EXEC$ and RUN$.
.br
.SH ""
   Example:
.br
.SH ""
   RUN "ls -l"
.br
.SH ""
.SS "  RUN$"
.SH ""
   RUN$(command$ [, stdin$[, out]])
.br
.SH ""
   Type: function
.br
.SH ""
   Executes an operating system command in a coprocess and returns the
.br
   resulting output to the BaCon program. Because the coprocess PID is not a
.br
   shell, but the PID of the executed command itself, this function cannot
.br
   return a system command exit status, and can only execute one system
.br
   command at a time. Optionally, a second argument may be used to feed to
.br
   STDIN. Also optionally, a third argument can be specified to determine
.br
   whether all output needs to be captured (0 = default), only stdout (1) or
.br
   only stderr (2). See RUN and SYSTEM to plainly execute a system command.
.br
   Example:
.br
.SH ""
   result$ = RUN$("ps x")
.br
   PRINT RUN$("rev", "This is a string", 1)
.br
   PRINT RUN$("ls -z", NULL, 2)
.br
.SH ""
.SS "  SAVE"
.SH ""
   SAVE string$ TO filename$
.br
.SH ""
   Type: statement
.br
.SH ""
   Saves a string to disk in one step. If the file already exists it is
.br
   overwritten. See BSAVE for saving binary files in one step, and
.br
   OPEN/WRITELN/READLN/CLOSE to read and write to a file using a filehandle.
.br
   Example:
.br
.SH ""
   SAVE result$ TO "/tmp/data.txt"
.br
   SAVE "Hello", "world" TO file$
.br
.SH ""
.SS "  SCREEN"
.SH ""
   SCREEN <SAVE> | <RESTORE>
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement can save the state of the current ASCII screen into memory
.br
   so it can be restored at a later moment in time. It only works with ANSI
.br
   compliant terminals. Example:
.br
.SH ""
   SCREEN SAVE
.br
   PRINT "Hello world"
.br
   SCREEN RESTORE
.br
.SH ""
.SS "  SCROLL"
.SH ""
   SCROLL <UP [x]|DOWN [x]>
.br
.SH ""
   Type: statement
.br
.SH ""
   Scrolls the current ANSI compliant terminal up or down one line.
.br
   Optionally, the amount of lines to scroll can be provided.
.br
.SH ""
.SS "  SEARCH"
.SH ""
   SEARCH(handle, string [,flag])
.br
.SH ""
   Type: function
.br
.SH ""
   Searches for <string> in file opened with <handle>. The search returns the
.br
   byte offset in the file where the first occurrence of <string> is located.
.br
   Use SEEK to effectively put the filepointer at this position. If the
.br
   string data is not found, then the value '-1' is returned.
.br
.SH ""
   Optionally, a third argument can be used to determine where to start the
.br
   search and in which direction the search should take place. The following
.br
   values are accepted:
.br
.SH ""
   0: start at the beginning of the file, search forward (default)
.br
   1: start at the current position of the filepointer, search forward
.br
   2: start at the current position of the filepointer, search backward
.br
   3: start at the end of the file, search backward.
.br
.SH ""
   Note that when searching backwards, the actual search begins at the start
.br
   position minus the length of the searched string.
.br
.SH ""
.SS "  SECOND"
.SH ""
   SECOND(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the second (0-59) where x is the amount of seconds since January
.br
   1, 1970.
.br
.SH ""
.SS "  SEED"
.SH ""
   SEED x
.br
.SH ""
   Type: statement
.br
.SH ""
   Seeds the random number generator with some value. After that, subsequent
.br
   usages of RND and RANDOM will return numbers in a random order. Note that
.br
   seeding the random number generator with the same number also will result
.br
   in the same sequence of random numbers.
.br
.SH ""
   By default, a BaCon program will automatically seed the random number
.br
   generator as soon as it is executed, so it may not be needed to use this
.br
   function explicitly. Example:
.br
.SH ""
   SEED NOW
.br
.SH ""
.SS "  SEEK"
.SH ""
   SEEK <handle> OFFSET <offset> [WHENCE START|CURRENT|END]
.br
.SH ""
   Type: statement
.br
.SH ""
   Puts the filepointer to new position at <offset>, optionally starting from
.br
   <whence>.
.br
.SH ""
.SS "  SELECT"
.SH ""
   SELECT <variable> CASE <body>[;] [DEFAULT <body>] END SELECT
.br
.SH ""
   Type: statement
.br
.SH ""
   With this statement a variable can be examined on multiple values.
.br
   Optionally, if none of the values match the SELECT statement may fall back
.br
   to the DEFAULT clause. Example:
.br
.SH ""
   SELECT myvar
.br
       CASE 1
.br
           PRINT "Value is 1"
.br
       CASE 5
.br
           PRINT "Value is 5"
.br
       CASE 2*3
.br
           PRINT "Value is ", 2*3
.br
       DEFAULT
.br
           PRINT "Value not found"
.br
   END SELECT
.br
.SH ""
   Contrary to most implementations, in BaCon the CASE keyword also may refer
.br
   to expressions and variables. Note that in such situation, each CASE
.br
   keyword will re-evaluate the expression at each occurrence.
.br
.SH ""
   Also, BaCon knows how to 'fall through' by either using a semicolon or a
.br
   comma separated list, in case multiple values lead to the same result:
.br
.SH ""
   SELECT human$
.br
       CASE "Man"
.br
           PRINT "It's male"
.br
       CASE "Woman", "Girl"
.br
           PRINT "It's female"
.br
       CASE "Child";
.br
       CASE "Animal"
.br
           PRINT "It's an it"
.br
       DEFAULT
.br
           PRINT "Alien detected"
.br
   END SELECT
.br
.SH ""
.SS "  SEND"
.SH ""
   SEND <var> TO <handle> [CHUNK <chunk>] [SIZE <size>]
.br
.SH ""
   Type: statement
.br
.SH ""
   Sends data in <var> to a network location identified by <handle>.
.br
   Optionally, the amount of bytes to send can be specified with the CHUNK
.br
   keyword. As by default SEND will consider the <var> to be a string, the
.br
   default amount of data is the string length of <var>. However, instead of
.br
   a string, also binary data can be sent by using a memory area created by
.br
   the MEMORY function. In such a situation it is obligatory to also specify
.br
   the chunk size.
.br
.SH ""
   The amount of bytes actually sent can be retrieved by using the optional
.br
   SIZE keyword. For an example of SEND, see the RECEIVE statement.
.br
.SH ""
.SS "  SETENVIRON"
.SH ""
   SETENVIRON var$, value$
.br
.SH ""
   Type: statement
.br
.SH ""
   Sets the environment variable 'var$' to 'value$'. If the environment
.br
   variable already exists, this statement will overwrite a previous value.
.br
   See GETENVIRON$ to retrieve the value of an environment variable. Example:
.br
.SH ""
   SETENVIRON "LANG", "C"
.br
.SH ""
.SS "  SETSERIAL"
.SH ""
   SETSERIAL <device> IMODE|OMODE|CMODE|LMODE|SPEED|OTHER <value>
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement can set the properties of a serial device. The Input Mode
.br
   (IMODE), Output Mode (OMODE), Control Mode (CMODE) and Local Mode (LMODE)
.br
   can be set, as well as the speed and the special properties on the serial
.br
   device. A discussion on the details of all these options is outside the
.br
   scope of this manual. Please refer to the TermIOS documentation of your C
.br
   compiler instead.
.br
.SH ""
   Example usage opening a serial port in 8N1, ignoring 0-byte as a break,
.br
   canonical, and non-blocking with a timeout of 0.5 seconds:
.br
.SH ""
   OPEN "/dev/ttyUSB0" FOR DEVICE AS myserial
.br
   SETSERIAL myserial SPEED B9600
.br
   SETSERIAL myserial IMODE ~IGNBRK
.br
   SETSERIAL myserial CMODE ~CSIZE
.br
   SETSERIAL myserial CMODE CS8
.br
   SETSERIAL myserial CMODE ~PARENB
.br
   SETSERIAL myserial CMODE ~CSTOPB
.br
   SETSERIAL myserial LMODE ICANON
.br
   SETSERIAL myserial OTHER VMIN = 0
.br
   SETSERIAL myserial OTHER VTIME = 5
.br
.SH ""
   Example setting the terminal to raw input mode (no echo and no line based
.br
   input):
.br
.SH ""
   SETSERIAL STDIN_FILENO LMODE ~ECHO
.br
   SETSERIAL STDIN_FILENO LMODE ~ICANON
.br
.SH ""
.SS "  SGN"
.SH ""
   SGN(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the sign of x. If x is a negative value, this function returns -1.
.br
   If x is a positive value, this function returns 1. If x is 0 then a 0 is
.br
   returned.
.br
.SH ""
.SS "  SIGNAL"
.SH ""
   SIGNAL <sub>, <signal>
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement connects a Unix signal to a callback function. Plain POSIX
.br
   signal names can be used, for example SIGINT, SIGTERM, SIGCHLD and so on.
.br
   Next to that, this statement accepts the SIG_DFL (default action) and
.br
   SIG_IGN (ignore signal) symbols for a callback also.
.br
.SH ""
   Example to ignore the SIGCHLD signal, preventing zombie processes to
.br
   occur:
.br
.SH ""
   SIGNAL SIG_IGN, SIGCHLD
.br
.SH ""
   Example connecting the <CTRL>+<C> signal to a SUB:
.br
.SH ""
   SUB Cleanup                    : ' Signal callback function
.br
       SIGNAL SIG_DFL, SIGINT     : ' Restore CTRL+C
.br
       PRINT "Cleaning up"        : ' Do your cleanup here
.br
       STOP SIGINT                : ' Send the SIGINT to myself
.br
   ENDSUB
.br
   SIGNAL Cleanup, SIGINT         : ' Catch CTRL+C
.br
   PRINT "Waiting..."
.br
   key = GETKEY
.br
.SH ""
.SS "  SIN"
.SH ""
   SIN(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the calculated SINUS of x, where x is a value in radians.
.br
.SH ""
.SS "  SIZEOF"
.SH ""
   SIZEOF(type)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the bytesize of a C type.
.br
.SH ""
.SS "  SLEEP"
.SH ""
   SLEEP <x>
.br
.SH ""
   Type: statement
.br
.SH ""
   Sleeps <x> milliseconds (sleep 1000 is 1 second).
.br
.SH ""
.SS "  SORT"
.SH ""
   SORT <x> [SIZE <x>] [DOWN]
.br
.SH ""
   Type: statement
.br
.SH ""
   Sorts the one-dimensional array <x> in ascending order. Only the basename
.br
   of the array should be mentioned, not the dimension. The array may be
.br
   indexed or associative.
.br
.SH ""
   For indexed arrays, the amount of elements to sort can be specified with
.br
   the optional keyword SIZE. Also optionally, the keyword DOWN can be used
.br
   to sort in descending order.
.br
.SH ""
   For associative arrays, sorting means changing the insertion order of the
.br
   key/value pairs in the hash table. The ordered keys can be retrieved by
.br
   LOOKUP or OBTAIN$. The SIZE keyword has no impact.
.br
.SH ""
   Examples:
.br
.SH ""
   GLOBAL a$[5] TYPE STRING
.br
   a$[0] = "Hello"
.br
   a$[1] = "my"
.br
   a$[2] = "good"
.br
   a$[4] = "friend"
.br
   SORT a$
.br
.SH ""
   Sorting an associative array:
.br
.SH ""
   DECLARE aa ASSOC short
.br
   aa("one") = 33
.br
   aa("two") = 12
.br
   aa("three") = 44
.br
   aa("four") = 15
.br
   aa("five") = 8
.br
   SORT aa DOWN
.br
.SH ""
.SS "  SORT$"
.SH ""
   SORT$(string$ [,delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Sorts all elements in a delimited string split by delimiter$. The
.br
   delimiter$ is optional. If it is omitted, then the definition from OPTION
.br
   DELIM is assumed. When specified, it may consist of multiple characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See also
.br
   the chapter on delimited string functions for more information about
.br
   delimited strings. Example:
.br
.SH ""
   PRINT "Sorted members: ", SORT$("f,q,a,c,i,b,r,t,e,d,z,", ",")
.br
.SH ""
.SS "  SOURCE$"
.SH ""
   SOURCE$
.br
.SH ""
   Type: variable
.br
.SH ""
   Reserved variable which contains the BaCon source code of the current
.br
   running program. Note that for commercial programs this variable should
.br
   not be used, because it stores the source code as plain text in the
.br
   resulting binary.
.br
.SH ""
.SS "  SP"
.SH ""
   SP
.br
.SH ""
   Type: variable
.br
.SH ""
   Reserved variable containing the amount of elements currently in the
.br
   stack. See also PUSH and PULL.
.br
.SH ""
.SS "  SPC$"
.SH ""
   SPC$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns an x amount of spaces.
.br
.SH ""
.SS "  SPLIT"
.SH ""
   SPLIT <string$> [BY <substr$>|<nr>] TO <array$> [SIZE <variable>] [STATIC]
.br
.SH ""
   Type: statement
.br
.SH ""
   This statement can split a string into smaller pieces. The optional BY
.br
   argument determines where the string is being split. If the BY keyword is
.br
   omitted then the definition from OPTION DELIM is used to split string$.
.br
   The results are stored in the argument <array$> mentioned by the TO
.br
   keyword. As sometimes it cannot be known in advance how many elements this
.br
   resulting array will contain, the array may not be declared before with
.br
   LOCAL or GLOBAL.
.br
.SH ""
   If <substr$> occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See the
.br
   chapter on delimited string functions for more information about delimited
.br
   strings.
.br
.SH ""
   If SPLIT is being used in a function or sub, then <array$> will have a
.br
   local scope. Else <array$> will be visible globally, and can be accessed
.br
   within all functions and subs.
.br
.SH ""
   The total amount of elements created in this array is stored in
.br
   <variable>. This variable can be declared explicitly using LOCAL or
.br
   GLOBAL. The SIZE keyword is optional and may be omitted.
.br
.SH ""
   If the <substr$> delimiter occurs in between double quotes, then it is
.br
   skipped. This behavior can be changed by setting OPTION QUOTED to FALSE.
.br
   If a double quote needs to be present in the <string$>, it must be escaped
.br
   properly.
.br
.SH ""
   If the value for BY is numeric, then string$ will be cut in pieces each
.br
   containing <nr> characters. If <nr> is 0 then there are no results. If
.br
   <nr> is equal to or bigger than the length of the string, then the
.br
   original string will be returned as an array with one element.
.br
.SH ""
   Example usage:
.br
.SH ""
   OPTION BASE 1
.br
   LOCAL dimension
.br
   SPLIT "one,two,,three" BY "," TO array$ SIZE dimension
.br
   FOR i = 1 TO dimension
.br
       PRINT array$[i]
.br
   NEXT
.br
.SH ""
   The above example will return four elements, of which the third element is
.br
   empty. If OPTION COLLAPSE is put to 1, the above example will return three
.br
   elements, ignoring empty entries.
.br
.SH ""
   SPLIT "one,two,\\"three,four\\",five" BY "," TO array$ SIZE dim
.br
.SH ""
   This will return 4 elements, because one separator (the comma) lies in
.br
   between double quotes.
.br
.SH ""
   The optional STATIC keyword allows the created <array> to be returned from
.br
   a function. See also EXPLODE$ to split text returning a delimited string,
.br
   TOKEN$ to retrieve one single element from a delimited string, and JOIN to
.br
   join array elements into a string.
.br
.SH ""
.SS "  SQR"
.SH ""
   SQR(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Calculates the square root from a number.
.br
.SH ""
.SS "  STOP"
.SH ""
   STOP [signal]
.br
.SH ""
   Type: statement
.br
.SH ""
   Halts the current program and returns to the Unix prompt. The program can
.br
   be resumed by performing the Unix command 'fg', or by sending the CONT
.br
   signal to its pid: kill -CONT <pid>.
.br
.SH ""
   The STOP statement actually sends the 'STOP' signal to the current
.br
   program. Optionally, a different signal can be defined. The signal can be
.br
   a number or a predefined name from libc, like SIGQUIT, SIGKILL, SIGTERM
.br
   and so on. Example sending the <CTRL>+<C> signal:
.br
.SH ""
   STOP SIGINT
.br
.SH ""
.SS "  STR$"
.SH ""
   STR$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Convert numeric value x to a string (opposite of VAL). Example:
.br
.SH ""
   PRINT STR$(123)
.br
.SH ""
.SS "  SUB"
.SH ""
   SUB <name>[(STRING s, NUMBER i, FLOATING f, VAR v SIZE t)]
.br
       <body>
.br
   ENDSUB | END SUB
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines a subprocedure. A subprocedure never returns a value (use FUNCTION
.br
   instead).
.br
.SH ""
   Variables used in a sub are visible globally, unless declared with LOCAL.
.br
   The incoming arguments are always local. Instead of the BaCon types
.br
   STRING, NUMBER and FLOATING for the incoming arguments, also regular
.br
   C-types also can be used. If no type is specified, then BaCon will
.br
   recognize the argument type from the variable suffix. In case no suffix is
.br
   available, plain NUMBER type is assumed. With VAR a variable amount of
.br
   arguments can be defined. Example:
.br
.SH ""
   SUB add(NUMBER x, NUMBER y)
.br
       LOCAL result
.br
       PRINT "The sum of x and y is: ";
.br
       result = x + y
.br
       PRINT result
.br
   END SUB
.br
.SH ""
.SS "  SUM / SUMF"
.SH ""
   SUM(array, amount [,minimum])
.br
   SUMF(array, amount [,minimum])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the sum of <amount> elements in <array>. Optionally, a check can
.br
   be added which specifies the minimum value for each element to be added.
.br
   If an array element falls below the specified value then it is excluded
.br
   from the sum calculation.
.br
.SH ""
   The SUM and SUMF functions perform the same task, but SUM requires an
.br
   array with integers and SUMF an array with floating values. See also MAP.
.br
   Example:
.br
.SH ""
   PRINT SUM(ages, 10)
.br
   PRINT SUMF(temperatures, 100, 25.5)
.br
.SH ""
.SS "  SWAP"
.SH ""
   SWAP x, y
.br
.SH ""
   Type: statement
.br
.SH ""
   Swaps the contents of the variables x and y. The types of the variables
.br
   can be mixed. Note that when swapping an integer with a float precision
.br
   may be lost.
.br
.SH ""
   Numeric variables can be swapped with string variables, thereby
.br
   effectively converting types. Example:
.br
.SH ""
   SWAP x%, y#
.br
   SWAP number, string$
.br
.SH ""
.SS "  SYSTEM"
.SH ""
   SYSTEM <command$>
.br
.SH ""
   Type: statement
.br
.SH ""
   Executes an operating system command. It causes the BaCon program to hold
.br
   until the command has been completed. The exit status of the executed
.br
   command itself is stored in the reserved variable RETVAL. Use EXEC$ to
.br
   catch the result of an operating system command. Example:
.br
.SH ""
   SYSTEM "ls -l"
.br
.SH ""
.SS "  TAB$"
.SH ""
   TAB$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns an x amount of tabs.
.br
.SH ""
.SS "  TAIL$"
.SH ""
   TAIL$(string$, amount [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Retrieves the last <amount> elements from a delimited string$ split by
.br
   delimiter$. The delimiter$ is optional. If it is omitted, then the
.br
   definition from OPTION DELIM is assumed. When specified, it may consist of
.br
   multiple characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE.
.br
.SH ""
   See also FIRST$ to obtain the remaining elements from the delimited
.br
   string, and HEAD$ to obtain elements counting from the start. Refer to the
.br
   chapter on delimited string functions for more information about delimited
.br
   strings. Example:
.br
.SH ""
   PRINT "Last 2 members: ", TAIL$("Rome Amsterdam Kiev Bern Paris London",
.br
   2)
.br
.SH ""
.SS "  TALLY"
.SH ""
   TALLY(haystack$, needle$ [,z])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the amount of times needle$ occurs in haystack$, optionally
.br
   starting at position z. If the needle$ is not found, then this function
.br
   returns the value '0'. See INSTR to find the position of a string.
.br
   Example:
.br
.SH ""
   amount = TALLY("Hello world are we all happy?", "ll")
.br
   PRINT TALLY("Don't take my ticket", "t", 10)
.br
.SH ""
.SS "  TAN"
.SH ""
   TAN(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the calculated tangent of x, where x is a value in radians.
.br
.SH ""
.SS "  TELL"
.SH ""
   TELL(handle)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns current position in file opened with <handle>.
.br
.SH ""
.SS "  TEXTDOMAIN"
.SH ""
   TEXTDOMAIN <domain$>, <directory$>
.br
.SH ""
   Type: statement
.br
.SH ""
   When OPTION INTERNATIONAL is enabled, BaCon by default configures a
.br
   textdomain with the current filename and a base directory
.br
   "/usr/share/locale" for the message catalogs. With this statement it is
.br
   possible to explicitly specify a different textdomain and base directory.
.br
.SH ""
.SS "  TIMER"
.SH ""
   TIMER
.br
.SH ""
   Type: function
.br
.SH ""
   Keeps track of the amount of milliseconds the current program is running.
.br
   See NANOTIMER to measure nanoseconds. Example:
.br
.SH ""
   iter = 1
.br
   WHILE iter > 0 DO
.br
       IF TIMER = 1 THEN BREAK
.br
       INCR iter
.br
   WEND
.br
   PRINT "Got ", iter-1, " iterations in 1 millisecond!"
.br
.SH ""
.SS "  TIMEVALUE"
.SH ""
   TIMEVALUE(a,b,c,d,e,f)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the amount of seconds since January 1 1970, from year (a), month
.br
   (b), day (c), hour (d), minute (e), and seconds (f). Example:
.br
.SH ""
   PRINT TIMEVALUE(2009, 11, 29, 12, 0, 0)
.br
.SH ""
.SS "  TOASCII$"
.SH ""
   TOASCII$(string$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the same string of which each byte has bit 7 set to 0. Note that
.br
   this can lead to unpredictable results. See also ISASCII or ISUTF8.
.br
   Example:
.br
.SH ""
   PRINT TOASCII$("Hello world")
.br
.SH ""
.SS "  TOKEN$"
.SH ""
   TOKEN$(haystack$, n [, delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the n^th token in haystack$ split by delimiter$. The delimiter$ is
.br
   optional. If it is omitted, then the definition from OPTION DELIM is
.br
   assumed. When specified, it may consist of multiple characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in haystack$, then it is
.br
   ignored. This behavior can be changed by setting OPTION QUOTED to FALSE.
.br
.SH ""
   If the indicated position is outside a valid range, the result will be an
.br
   empty string. Use the FLATTEN$ function to flatten out the returned token.
.br
   See also ISTOKEN, AMOUNT and SPLIT.
.br
.SH ""
   Examples:
.br
.SH ""
   PRINT TOKEN$("a b c d \\"e f\\" g h i j", 6)
.br
   PRINT TOKEN$("Dog Cat @@@ Mouse Bird@@@ 123@@@", 3, "@@@")
.br
   PRINT TOKEN$("1,2,3,4,5", 3, ",")
.br
   PRINT TOKEN$("1,2," & CHR$(34) & "3,4" & CHR$(34) & ",5,", 6, ",")
.br
.SH ""
.SS "  TOTAL"
.SH ""
   TOTAL(binary_tree)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the amount of nodes in <binary_tree>. See the chapter on binary
.br
   trees for more information. Example:
.br
.SH ""
   PRINT "Amount of elements: ", TOTAL(mytree)
.br
.SH ""
.SS "  TRACE"
.SH ""
   TRACE <ON|MONITOR <var1, var2, ...>|OFF>
.br
.SH ""
   Type: statement
.br
.SH ""
   The ON keyword starts trace mode. The program will wait for a key to
.br
   continue. After each key press, the next line of source code is displayed
.br
   on the screen, and then executed. A double quote symbol will be replaced
.br
   for a single quote, a back slash symbol will be replaced by a forward
.br
   slash and a percentage symbol will be replaced by a hash symbol to avoid
.br
   clashes with the C printf function. Pressing the ESCAPE key will exit the
.br
   program.
.br
.SH ""
   The MONITOR keyword also starts trace mode, but allows monitoring values
.br
   of variables. After each line of source code the content of the specified
.br
   variables is displayed.
.br
.SH ""
   If TRACE is used within a function, make sure to also add TRACE OFF at the
.br
   end of the function.
.br
.SH ""
   Example:
.br
.SH ""
   LOCAL var
.br
   TRACE MONITOR var
.br
   FOR var = 1 TO 10
.br
       INCR var
.br
   NEXT
.br
.SH ""
.SS "  TRAP"
.SH ""
   TRAP <LOCAL|SYSTEM>
.br
.SH ""
   Type: statement
.br
.SH ""
   Sets the runtime error trapping. By default, BaCon performs error trapping
.br
   (LOCAL). BaCon tries to examine statements and functions where possible,
.br
   and will display an error message based on the operating system internals,
.br
   indicating which statement or function causes a problem. Optionally, when
.br
   a CATCH is set, BaCon can jump to a LABEL instead, where a self-defined
.br
   error function can be executed, and from where a RESUME is possible.
.br
.SH ""
   When set to SYSTEM, error trapping is performed by the operating system.
.br
   This means that if an error occurs, a signal will be caught by the program
.br
   and a generic error message is displayed on the prompt. The program will
.br
   then exit gracefully
.br
.SH ""
   The setting LOCAL decreases the performance of the program, because
.br
   additional runtime checks are carried out when the program is executed.
.br
.SH ""
.SS "  TREE"
.SH ""
   TREE <binary tree> ADD <value> [TYPE <type>]
.br
.SH ""
   Type: statement
.br
.SH ""
   The TREE statement adds a value to a binary tree. Adding a duplicate value
.br
   to the tree will not have any effect, and will silently be ignored. For
.br
   more information and examples, see the chapter on binary trees. See also
.br
   FIND to verify the presence of a node in a binary tree or TOTAL to
.br
   determine the total amount of nodes in a tree. Example:
.br
.SH ""
   DECLARE mytree TREE STRING
.br
   IF NOT(FIND(mytree, "hello world")) THEN TREE mytree ADD "hello world"
.br
.SH ""
.SS "  TRUE"
.SH ""
   TRUE
.br
.SH ""
   Type: variable
.br
.SH ""
   Represents and returns the value of '1'. This is the opposite of the FALSE
.br
   variable.
.br
.SH ""
.SS "  TYPE"
.SH ""
   TYPE [SET|UNSET|RESET] [BOLD|ITALIC|UNDERLINE|INVERSE|BLINK|STRIKE]
.br
.SH ""
   Type: statement
.br
.SH ""
   The TYPE statement sets the font type in an ANSI compliant console. It is
.br
   allowed to specify multiple types on the same line. Changes can be undone
.br
   per type using the UNSET keyword. The RESET keyword will restore the
.br
   default font settings. Note that not all Linux shells implement every
.br
   console font type. See also the COLOR statement to set the color.
.br
   Examples:
.br
.SH ""
   TYPE SET ITALIC BLINK
.br
   PRINT "This is blinking italic!"
.br
   TYPE UNSET BLINK
.br
   PRINT "Italic left!"
.br
   TYPE RESET
.br
.SH ""
.SS "  TYPEOF$"
.SH ""
   TYPEOF$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the type of a variable.
.br
.SH ""
.SS "  UBOUND"
.SH ""
   UBOUND(array)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the total elements available in a static, dynamic or associative
.br
   array. In case of multi-dimensional static arrays, the total amount of
.br
   elements in the array is returned. Example:
.br
.SH ""
   LOCAL array[] = { 2, 4, 6, 8, 10 }
.br
   PRINT UBOUND(array)
.br
.SH ""
.SS "  UCASE$"
.SH ""
   UCASE$(x$)
.br
.SH ""
   Type: function
.br
.SH ""
   Converts x$ to uppercase characters and returns the result. See LCASE$ to
.br
   do the opposite.
.br
.SH ""
.SS "  UCS"
.SH ""
   UCS(char)
.br
.SH ""
   Type: function
.br
.SH ""
   Calculates the Unicode value of the given UTF8 character (opposite of
.br
   UTF8$). See also ASC for plain ASCII characters. Example:
.br
.SH ""
   PRINT UCS("")
.br
.SH ""
.SS "  ULEN"
.SH ""
   ULEN(x$ [, y])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the length of the UTF8 string x$. Optionally, the position at y
.br
   can be specified. See LEN for plain ASCII strings.
.br
.SH ""
.SS "  UNESCAPE$"
.SH ""
   UNESCAPE$(string$)
.br
.SH ""
   Type: function
.br
.SH ""
   Parses the text in <string$> and converts escape sequences into actual
.br
   special characters (like newline or Unicode). This functionality comes
.br
   handy when reading C text or JSON text containing escape sequences. Escape
.br
   sequences for actual binary data (like '\\x') are not converted. See also
.br
   ESCAPE$ to do the opposite. Example:
.br
.SH ""
   OPTION UTF8 TRUE
.br
   PRINT UNESCAPE$("Hello\\\\nworld\\\\t\\\\U0001F600")
.br
.SH ""
.SS "  UNFLATTEN$"
.SH ""
   UNFLATTEN$(txt$ [, groupingchar$])
.br
.SH ""
   Type: function
.br
.SH ""
   Unflattens a string where the double quote symbol is used to group parts
.br
   of the string together. The string will be surrounded with double quotes
.br
   and any existing escapes will be escaped. Instead of the double quote
.br
   symbol a different character can be specified (optional). See also
.br
   FLATTEN$ for the reverse operation. Examples:
.br
.SH ""
   PRINT UNFLATTEN$("\\"Hello \\\\\\"cruel\\\\\\" world\\"")
.br
   PRINT UNFLATTEN$("\\'Hello world\\'", "'")
.br
.SH ""
.SS "  UNIQ$"
.SH ""
   UNIQ$(string$ [,delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Unifies all elements in a delimited string split by delimiter$. The
.br
   delimiter$ is optional. If it is omitted, then the definition from OPTION
.br
   DELIM is assumed. When specified, it may consist of multiple characters.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See also
.br
   the chapter on delimited string functions for more information about
.br
   delimited strings. Example:
.br
.SH ""
   PRINT "A sequence with unique members: ", UNIQ$("a a b c c d e f a c f")
.br
.SH ""
.SS "  USEC"
.SH ""
   USEC
.br
       <body>
.br
   ENDUSEC | END USEC
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines a body with C code. This code is put unmodified into the generated
.br
   C source file. Example:
.br
.SH ""
   USEC
.br
       char *str;
.br
       str = strdup("Hello");
.br
       printf("%s\\n", str);
.br
   END USEC
.br
.SH ""
.SS "  USEH"
.SH ""
   USEH
.br
       <body>
.br
   ENDUSEH | END USEH
.br
.SH ""
   Type: statement
.br
.SH ""
   Defines a body with C declarations and/or definitions. This code is put
.br
   unmodified into the generated global header source file. This can
.br
   particularly be useful in case of using variables from external libraries.
.br
   See also USEC to pass C source code. Example:
.br
.SH ""
   USEH
.br
       char *str;
.br
       extern int pbl_errno;
.br
   END USEH
.br
.SH ""
.SS "  UTF8$"
.SH ""
   UTF8$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the character belonging to Unicode number x. This function does
.br
   the opposite of UCS. The value for x can lie between 0 and 0x10FFFF. Note
.br
   that the result only will be visible in a valid UTF8 environment, and also
.br
   that the installed character set should support the character. See also
.br
   CHR$ for plain ASCII characters. The following should print a smiley
.br
   emoticon:
.br
.SH ""
   LET a$ = UTF8$(0x1F600)
.br
   PRINT a$
.br
.SH ""
.SS "  VAL"
.SH ""
   VAL(x$)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the actual value of x$. This is the opposite of STR$. Example:
.br
.SH ""
   nr$ = "456"
.br
   q = VAL(nr$)
.br
.SH ""
.SS "  VAR"
.SH ""
   VAR <array$>|<array#>|<array%>|<array>  [TYPE c-type]  SIZE <total>
.br
.SH ""
   Type: statement
.br
.SH ""
   Declares a variable argument list in a FUNCTION or SUB. There may be no
.br
   other variable declarations in the function header. The arguments to the
.br
   function are put into an <array> which is visible within the FUNCTION or
.br
   SUB. The type can be defined either by the optional TYPE keyword or by a
.br
   variable suffix. If no type is specified then VAR will assume NUMBER. The
.br
   SIZE keyword defines where the resulting amount of elements will be
.br
   stored. Example:
.br
.SH ""
   OPTION BASE 1
.br
   SUB demo (VAR arg$ SIZE amount)
.br
       LOCAL x
.br
       PRINT "Amount of incoming arguments: ", amount
.br
       FOR x = 1 TO amount
.br
           PRINT arg$[x]
.br
       NEXT
.br
   END SUB
.br
.SH ""
   ' No argument
.br
   demo(0)
.br
   ' One argument
.br
   demo("abc")
.br
   ' Three arguments
.br
   demo("123", "456", "789")
.br
.SH ""
.SS "  VERIFY"
.SH ""
   VERIFY(connection, file$)
.br
.SH ""
   Type: function
.br
.SH ""
   Verifies the certificates of the current TLS connection against file$. The
.br
   file$ should be in PEM format and should contain all root CA certificates.
.br
   Usually this information can be extracted from a web browser. See also the
.br
   chapter on secure network connections.
.br
.SH ""
   In case of an invalid certificate, OpenSSL and GnuTLS will not drop the
.br
   active TLS connection, and the VERIFY function will return the TLS error
.br
   code.
.br
.SH ""
   For WolfSSL, the connection will be dropped immediately, and the reserved
.br
   ERROR variable will contain the actual TLS error code. Use CATCH GOTO to
.br
   prevent the program from stopping and workaround the TLS problem.
.br
.SH ""
.SS "  VERSION$"
.SH ""
   VERSION$
.br
.SH ""
   Type: variable
.br
.SH ""
   Reserved variable which contains the BaCon version text.
.br
.SH ""
.SS "  WAIT"
.SH ""
   WAIT(handle, milliseconds)
.br
.SH ""
   Type: function
.br
.SH ""
   Suspends the program for a maximum of <milliseconds> until data becomes
.br
   available on <handle>.
.br
.SH ""
   This is especially useful in network programs where a RECEIVE will block
.br
   if there is no data available. The WAIT function checks the handle and if
.br
   there is data in the queue, it returns with value '1'. If there is no data
.br
   then it waits for at most <milliseconds> before it returns. If there is no
.br
   data available, WAIT returns '0'. Refer to the RECEIVE statement for an
.br
   example.
.br
.SH ""
   This statement also can be used to find out if a key is pressed without
.br
   actually waiting for a key, so without interrupting the current program.
.br
   In this case, use the STDIN file descriptor (0) as the handle. Example:
.br
.SH ""
   REPEAT
.br
       PRINT "Press Escape... waiting..."
.br
       key = WAIT(STDIN_FILENO, 50)
.br
   UNTIL key = 27
.br
.SH ""
   As can be observed in this code, instead of '0' the reserved POSIX
.br
   variable STDIN_FILENO can be used also. See also appendix B for more
.br
   standard POSIX variables.
.br
.SH ""
.SS "  WALK$"
.SH ""
   WALK$(directory$, filetype, regex, recursive [,delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   This function returns a delimited string with all the file names located
.br
   in <directory$>. The <filetype> argument can contain a number and
.br
   determines the kind of file to look for. These values can be combined in a
.br
   binary OR:
.br
.SH ""
         Value                Meaning            
.br
           1                Regular file         
.br
           2                 Directory           
.br
           4              Character device       
.br
           8                Block device         
.br
          16             Named pipe (FIFO)       
.br
          32               Symbolic link         
.br
          64                   Socket            
.br
.SH ""
   The <regex> argument defines a regular expression and acts as an
.br
   additional filter to narrow down the resulting list further. The
.br
   <recursive> argument can either be TRUE or FALSE to define whether or not
.br
   underlying directories should be searched as well.
.br
.SH ""
   The delimiter$ argument is optional. If it is omitted, then the definition
.br
   from OPTION DELIM is assumed. When specified, it may consist of multiple
.br
   characters. Note that the default delimiter used by BaCon is a single
.br
   whitespace, while file names can contain whitespaces as well. It is
.br
   therefore recommended to specify a delimiter like NL$ which usually does
.br
   not occur in file names.
.br
.SH ""
   If delimiter$ occurs between double quotes in string$, then it is ignored.
.br
   This behavior can be changed by setting OPTION QUOTED to FALSE. See also
.br
   the chapter on delimited string functions for more information about
.br
   delimited strings.
.br
.SH ""
   Example to list files and directories in the current directory using a
.br
   binary OR:
.br
.SH ""
   PRINT WALK$(".", 1|2, ".+", FALSE, NL$)
.br
.SH ""
   Example to list all directories in /tmp containing an underscore symbol:
.br
.SH ""
   PRINT WALK$("/tmp", 2, "[_]+", FALSE, NL$)
.br
.SH ""
   Example to recursively list all files ending in ".jpg" and also start with
.br
   a number:
.br
.SH ""
   PRINT WALK$(".", 1, "^[[:digit:]]+.*.jpg$", TRUE, NL$)
.br
.SH ""
.SS "  WEEK"
.SH ""
   WEEK(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the week number (1-53) in a year, where x is the amount of seconds
.br
   since January 1, 1970. Example:
.br
.SH ""
   PRINT WEEK(NOW)
.br
.SH ""
.SS "  WEEKDAY$"
.SH ""
   WEEKDAY$(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the day of the week as a string in the system's locale ("Monday",
.br
   "Tuesday", etc), where x is the amount of seconds since January 1, 1970.
.br
.SH ""
.SS "  WHERE"
.SH ""
   WHERE(string$, position [,delimiter$])
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the actual numerical character position in a delimited string
.br
   split by delimiter$. The delimiter$ is optional. If it is omitted, then
.br
   the definition from OPTION DELIM is assumed. When specified, it may
.br
   consist of multiple characters. If delimiter$ occurs between double quotes
.br
   in string$ then it is ignored. Example:
.br
.SH ""
   PRINT WHERE("a b c d \\"e f\\" g h i j", 6)
.br
.SH ""
.SS "  WHILE"
.SH ""
   WHILE <equation> [DO]
.br
       <body>
.br
       [BREAK]|[CONTINUE]
.br
   WEND
.br
.SH ""
   Type: statement
.br
.SH ""
   The WHILE/WEND is used to repeat a body of statements and functions. The
.br
   DO keyword is optional. The optional BREAK statement can be used to break
.br
   out the loop. With the optional CONTINUE part of the body can be skipped.
.br
   Example:
.br
.SH ""
   LET a = 5
.br
   WHILE a > 0 DO
.br
       PRINT a
.br
       a = a - 1
.br
   WEND
.br
.SH ""
   As the WHILE statement uses an equation to evaluate, it also allows the
.br
   BETWEEN operator:
.br
.SH ""
   a = 2
.br
   WHILE a BETWEEN 1;10
.br
       PRINT a
.br
       INCR a
.br
   WEND
.br
.SH ""
.SS "  WITH"
.SH ""
   WITH <var>
.br
       .<var> = <value>
.br
       .<var> = <value>
.br
       ....
.br
   END WITH
.br
.SH ""
   Type: statement
.br
.SH ""
   Assign values to individual members of a RECORD. For example:
.br
.SH ""
   WITH myrecord
.br
       .name$ = "Peter"
.br
       .age = 41
.br
       .street = Falkwood Area 1
.br
       .city = The Hague
.br
   END WITH
.br
.SH ""
.SS "  WRITELN"
.SH ""
   WRITELN "text"|<var> TO <handle>
.br
.SH ""
   Type: statement
.br
.SH ""
   Write a line of ASCII data to a file identified by handle. A semicolon at
.br
   the end of the line prevents writing a newline. Refer to the PUTBYTE
.br
   statement to write binary data. Examples:
.br
.SH ""
   WRITELN "Hello world with a newline" TO myfile
.br
   WRITELN "Without newline"; TO myfile
.br
.SH ""
.SS "  YEAR"
.SH ""
   YEAR(x)
.br
.SH ""
   Type: function
.br
.SH ""
   Returns the year where x is amount of seconds since January 1, 1970.
.br
   Example:
.br
.SH ""
   PRINT YEAR(NOW)
.br
.SH ""
.SH "Appendix A: Runtime error codes"
.SH ""
      Code    Meaning                                                         
.br
       0      Success                                                         
.br
       1      Trying to access illegal memory                                 
.br
       2      Error opening file                                              
.br
       3      Could not open library                                          
.br
       4      Symbol not found in library                                     
.br
       5      Wrong value                                                     
.br
       6      Unable to claim memory                                          
.br
       7      Unable to delete file                                           
.br
       8      Could not open directory                                        
.br
       9      Unable to rename file                                           
.br
       10     NETWORK argument should contain colon with port number          
.br
       11     Could not resolve hostname                                      
.br
       12     Socket error                                                    
.br
       13     Unable to open address                                          
.br
       14     Error reading from socket                                       
.br
       15     Error sending to socket                                         
.br
       16     Error checking socket                                           
.br
       17     Unable to bind the specified socket address                     
.br
       18     Unable to listen to socket address                              
.br
       19     Cannot accept incoming connection                               
.br
       20     Unable to remove directory                                      
.br
       21     Unable to create directory                                      
.br
       22     Unable to change to directory                                   
.br
       23     GETENVIRON argument does not exist as environment variable      
.br
       24     Unable to stat file                                             
.br
       25     Search contains illegal string                                  
.br
       26     Cannot return OS name                                           
.br
       27     Illegal regex expression                                        
.br
       28     Unable to create bidirectional pipes                            
.br
       29     Unable to fork process                                          
.br
       30     Cannot read from pipe                                           
.br
       31     Gosub nesting too deep                                          
.br
       32     Could not open device                                           
.br
       33     Error configuring serial port                                   
.br
       34     Error accessing device                                          
.br
       35     Error in INPUT                                                  
.br
       36     Illegal value in SORT dimension                                 
.br
       37     Illegal option for SEARCH                                       
.br
       38     Invalid UTF8 string                                             
.br
       39     Illegal EVAL expression                                         
.br
       40     SSL file descriptor error                                       
.br
       41     Error loading certificate                                       
.br
       42     Widget not found                                                
.br
       43     Unsupported array type                                          
.br
.SH ""
.SH "Appendix B: standard POSIX variables"
.SH ""
           Variable                       Value                
.br
         EXIT_SUCCESS                       0                  
.br
         EXIT_FAILURE                       1                  
.br
         STDIN_FILENO                       0                  
.br
         STDOUT_FILENO                      1                  
.br
         STDERR_FILENO                      2                  
.br
           RAND_MAX                  System dependent          
.br
.SH ""
.SH "Appendix C: reserved keywords and functions"
.SH ""
   All keywords belonging to the C language cannot be redefined in a BaCon
.br
   program:
.br
.SH ""
   auto, break, case, char, const, continue, default, do, double, else, enum,
.br
   extern, float, for, goto, if, int, long, register, return, short, signed,
.br
   sizeof, static, struct, switch, typedef, union, unsigned, void, volatile,
.br
   while.
.br
.SH ""
   Functions defined in libc, libm or libdl cannot be redefined in a BaCon
.br
   program, most notorious being:
.br
.SH ""
   exit, index, y0, y0f, y0l, y1, y1f, y1l, yn, ynf, ynl, dlopen, dlsym,
.br
   dlclose.
.br
.SH ""
   Internal symbols and macro definitions cannot be reused. These start with
.br
   '__b2c_'.
.br
.SH ""
   All symbols mentioned in the paragraph "Reserved Names" of any C manual
.br
   cannot be redefined.
.br
.SH ""
.SH "Appendix D: details on string optimization in BaCon"
.SH ""
   As BaCon is a plain Basic-to-C converter, the resulting code depends on
.br
   the C implementation of strings, which, in fact, comes down to the known
.br
   concept of character arrays. A string is nothing more than a series of
.br
   values in memory which ends with a '0' value.
.br
.SH ""
   Plain C code is notorious for its bad performance on strings, especially
.br
   when it needs to calculate the length of a string. Usually, the bytes in
.br
   memory are verified until the terminating '0' value is encountered. For
.br
   large strings this will take a considerable amount of time, especially in
.br
   repetitive operations.
.br
.SH ""
   In the ongoing attempt to improve the performance of string operations,
.br
   several approaches for the BaCon project have been investigated. The below
.br
   report is a short summary of techniques which were tried.
.br
.SH ""
.SS "  Different binary layout"
.SH ""
   A common implementation stores the actual string length in the beginning
.br
   of the string. This means that, for example, the first 4 bytes contain the
.br
   length of the string, and the next 4 bytes contain the size of the buffer
.br
   holding the string. (This would limit the size of the string to 4294967295
.br
   bytes (4Gb), which, for most purposes, should be enough.) After that, the
.br
   actual characters of the string itself are stored.
.br
.SH ""
     b1    b2    b3   b4   l1   l2   l3   l4    char1     char2     char<n>   
.br
        String length        Buffer length      Actual bytes of the string
.br
.SH ""
   Programming languages like Pascal and Basic usually implement their
.br
   strings this way. They change the binary layout of the actual string,
.br
   where, as mentioned, the first 8 bytes contain meta information about
.br
   length and buffer size.
.br
.SH ""
   For BaCon this seems a promising approach, however, as BaCon is a
.br
   Basic-to-C converter, it makes use of the string functions provided by
.br
   libc. I am referring to functions like printf, strcat, strcpy and friends.
.br
   If strings are being fed to standard C functions like these, then this
.br
   would cause unpredictable results. The libc string functions always assume
.br
   character arrays in a correct format, otherwise they will not work
.br
   properly - encountering binary values would cause printf to print garbage
.br
   on the screen, for example.
.br
.SH ""
   Now, it is possible to add a default offset of 8 bytes to the beginning of
.br
   the memory address to overcome this problem. However, we do not know in
.br
   advance what type of string comes in. For example, the used string very
.br
   well may contain a string literal. This is plain text hard coded in the
.br
   BaCon program.
.br
.SH ""
   PRINT "Hello" & world$
.br
.SH ""
   In this example, both a string literal and also a memory address are used.
.br
   Clearly, such string literal does not have the 8 bytes offset with meta
.br
   information. So how can we check whether a string consists of a string
.br
   literal, or whether it contains a memory address with the 8 byte offset?
.br
.SH ""
   I will come back to the concept of using a pre-buffer shortly.
.br
.SH ""
.SS "  Hash table"
.SH ""
   Another idea is to use hash values paired with the string length. The
.br
   approach is to take the actual memory address of a string, which is a
.br
   unique value. This unique memory address then can be put into a hash table
.br
   which also can store a string length value (key-value store).
.br
.SH ""
   For performance reasons it would be nice if the table would provide values
.br
   in a sequence starting from 1 to have indexes available for an array. This
.br
   is called a minimal hash.
.br
.SH ""
   Furthermore, as we do not know in advance how many memory addresses the
.br
   BaCon program is going to use, the hash table should be able to grow and
.br
   shrink dynamically.
.br
.SH ""
   When it comes to performance, it turns out that has tables are too slow.
.br
   The implementations of a dynamic hash table often make use of linked
.br
   lists, and the unavoidable memory inserts and deletions simply take too
.br
   much time. Eventually, it was established that they take more time than a
.br
   string length calculation.
.br
.SH ""
.SS "  Pointer swap"
.SH ""
   In BaCon, all string operating functions make use of a temporary buffer to
.br
   store their (intermediate) results. This is to ensure that nested string
.br
   functions can pass their results to a higher level.
.br
.SH ""
 text$ = MID$("Goodbye, Hello", 9) & CHR$(32) & RIGHT$("The World", 5)
.br
.SH ""
   The above example concatenates three string operations into one resulting
.br
   string. The functions MID$, CHR$ and RIGHT$ first will store their result
.br
   into temporary buffers, which then are passed to the '&' operator, which,
.br
   in its turn, stores the result of the concatenation into another temporary
.br
   buffer. The final result then is assigned to the variable 'text$'. The
.br
   assignment is performed by copying the contents from the temporary buffer
.br
   to the variable 'text$'.
.br
.SH ""
   So, instead of copying the result into a variable, it also is possible to
.br
   swap the memory addresses of the variable and the temporary buffer. The
.br
   variable 'text$' will point to the result, and the contents of the
.br
   temporary buffer will be changed to the previous character array of the
.br
   variable. And because the buffer is temporary, it is going to be
.br
   overwritten anyway in a next string operation, so there's no need to care
.br
   about that.
.br
.SH ""
   This technique of pointer swapping will save some time, because it avoids
.br
   a needless copy of bytes from one memory area to another. Even though it
.br
   does not help us with string length calculation, it can help to improve
.br
   the performance of string operations.
.br
.SH ""
.SS "  Static character pointers"
.SH ""
   When using character pointers in functions, it is a good idea to declare
.br
   them as static. Such pointers keep their value, e.g. the memory address
.br
   they are pointing to, so the next time when the function is called, the
.br
   pointer still points to the allocated memory. Therefore, there is no need
.br
   to free a pointer at the end of a function, or to allocate new memory when
.br
   entering the function. This will save a lot of system calls and kernel
.br
   activity.
.br
.SH ""
   Note that it may be needed to set the memory of the string to an empty
.br
   string at the beginning of the function.
.br
.SH ""
   Also note that because static pointers always will point to the same
.br
   memory, recursive functions may not work properly. So in each level of
.br
   recursion, the same memory is overwritten.
.br
.SH ""
   The technique of static pointers is partly implemented in BaCon: static
.br
   pointers are used for string variables and string arrays which get their
.br
   value assigned at declaration time. This technique is not suitable for
.br
   regular string variables, because of the aforementioned problems with
.br
   recursion.
.br
.SH ""
.SS "  Using a pre-buffer"
.SH ""
   The last technique to discuss, which actually has been implemented, is
.br
   using a pre-buffer. It is similar to the binary layout discussed earlier.
.br
   In this approach, a block of memory is allocated, of which the first bytes
.br
   contain meta information about length and buffer size. However, the
.br
   returned pointer itself is a pointer to the start of the actual string.
.br
   The benefit of this is that the string functions from libc will work
.br
   properly, because they see the actual string.
.br
.SH ""
   As mentioned, this concept is used in BaCon. However, there is a severe
.br
   problem which needs to be solved: how do we know if an incoming string
.br
   already uses a pre-buffer?
.br
.SH ""
 PRINT a$ & b$ & c$ & "Hello"
.br
.SH ""
   In this example, we have three variables and a string literal. If one of
.br
   the variables does not have a pre-buffer, and BaCon likes to look into it,
.br
   then a crash will occur (segfault). BaCon cannot simply look into memory
.br
   which is not allocated. Nor into a non-existing pre-buffer in case of a
.br
   string literal.
.br
.SH ""
   To solve this problem, we have to think of a trick. The memory addresses
.br
   which point to the strings are in fact numbers, each of which must be
.br
   unique. If the addresses were not unique, then the program would overwrite
.br
   one string with another. Therefore, the uniqueness of memory addresses is
.br
   a property which can be used to identify a string with a pre-buffer: if
.br
   the address is taken as a plain number it can be used as an index in a
.br
   lookup table. That table contains a list of addresses for which BaCon has
.br
   created a pre-buffer.
.br
.SH ""
   Obviously, such table cannot be as large as the amount of possible memory
.br
   addresses. But this is not necessary. The biggest BaCon program at the
.br
   time of writing is the implementation of BaCon in BaCon itself. It
.br
   contains more than 10.000 lines of code, and when compiled with the '-@'
.br
   debug parameter it can be observed that there are  less than 400 strings
.br
   in use, simultaneously, at any moment in time. It is therefore not
.br
   realistic to implement a lookup table for all possible memory addresses,
.br
   since it is unlikely that actual programs will use that amount of string
.br
   data anyway. Currently, the size of the lookup table is 1Mb, which means
.br
   that theoretically a program can identify a little over 1 million memory
.br
   addresses during runtime.
.br
.SH ""
   The index in the table is determined by taking the modulo from the address
.br
   by 1 million and then performing a binary 'AND' with '1 million minus 1'.
.br
   This is a very fast algorithm but allows collisions to happen: some memory
.br
   addresses will deliver the same index in the lookup table as other address
.br
   will. The approach to solve this situation is called linear probing: in
.br
   case of a collision, BaCon will take the next slot in the lookup table. If
.br
   this slot is occupied with some other address, again it will take the
.br
   next. The maximum probe depth currently is set to 16 steps. If the probe
.br
   depth is exceeded then the program simply will generate an internal error
.br
   and stop.
.br
.SH ""
   String operations now can lookup the address in the lookup table and
.br
   quickly fetch information from each pre-buffer, saving time which
.br
   otherwise would have been needed for length calculations.
.br
.SH ""
   <n> bytes   1    2   3  4  1  2  3  4 1    2   3   4   <n> bytes           
.br
   Left buffer String length  Size right Size left buffer Right buffer        
.br
                              buffer
.br
               <------- area containing metadata -------> Actual string data  
.br
                                                          ---> Returned       
.br
                                                          pointer             
.br
.SH ""
   The above picture represents the new layout. Meta information is stored in
.br
   an area which floats freely between two memory buffers. The returned
.br
   pointer is the start of the right buffer which contains the actual string
.br
   data. The left buffer is used for string concatenations, to insert text
.br
   before an existing string, which allows a very fast concatenation of data
.br
   (this works by first moving the area with meta data to the left and then
.br
   inserting the text).
.br
.SH ""
   The parameters for the lookup table can be altered by the command line
.br
   parameter '-t' (see the chapter on Basic Usage and Parameters).
.br
.SH ""
.SS "  Memory pool"
.SH ""
   As strings are stored in memory, it sometimes can be a good idea to
.br
   allocate a block of memory before the actual program starts. A private
.br
   function to share and administer can assign parts of that allocated memory
.br
   to the program. This could save time, because the real memory allocation
.br
   on the heap already took place, and the private memory allocation simply
.br
   has to administer small chunks.
.br
.SH ""
   Note that it only saves time in case a lot of subsequent allocations and
.br
   frees take place in the program. Previously, BaCon performed almost
.br
   500,000 allocations consuming a total of 80 Mb of memory. A memory pool
.br
   helps to decrease the allocations requested by BaCon to the kernel and it
.br
   also lowers the overall memory usage by reusing existing slots.
.br
.SH ""
   The core string allocation engine now uses a basic memory pool, which, by
.br
   default, is defined by 2048 slots each occupying 1024 bytes. This
.br
   decreases the amount of memory allocations with more than 85% and
.br
   decreases the total memory usage with approximately 45%.
.br
.SH ""
   The parameters for the memory pool dimensions can be altered by the
.br
   command line parameter '-t' (see the chapter on Basic Usage and
.br
   Parameters).
.br
.SH ""
.SH LICENSE
MIT License.
.SH BUGS
Please report bugs to: bugs@basic-converter.org
.SH AUTHOR
Peter van Eerten (peter@basic-converter.org)

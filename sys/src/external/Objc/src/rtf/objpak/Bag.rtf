{\rtf1\ansi{\fonttbl\f0\fnil Times-Roman;\f1\fswiss Helvetica;\f2\fmodern Courier;}\paperw12000\paperh8000\margl40\margr40
\pard\f0\fs24\cf0 Portable Object Compiler (c) 1997,98.  All Rights Reserved.\fs16\
\
\
\
\
\
\
\f1\b\fs56\li2200 Bag\f0\b0\fs16\
\
\
\
\
\
\f0\fs28\li2200 {\b {\f1 Inherits from:}} Cltn\fs16\
\
\fs16\
\
\f1\b\fs36\li1400 Class Description\b0\f0\fs16\
\
\f0\fs28\li2200 {\b Bag} instances are unordered sets of objects, with possibly duplicate elements.  A {\b Bag} can be thought of, as a {\b Set}, assigning to each element, a count of how many times that element was added ({\i multiplicity} of the element).\fs16\
\
\f0\fs28\li2200 The multiplicity of a particular element is returned by the {\f2 occurrencesOf:} message.  Repeatedly adding the same (in the sense of {\f2 hash} and {\f2 isEqual}) object, simply increases the multiplicity of the element.  Sending {\f2 remove:} messages, will not remove the element until the multiplicity of the element is zero.\fs16\
\
\fs16\
\
\f1\b\fs36\li1400 Adding Objects\b0\f0\fs16\
\
\f0\fs28\li2200 The methods {\f2 add:}, {\f2 addNTest:}, {\f2 filter:}, {\f2 replace:} and {\f2 add:ifDuplicate:} are used to add objects to a Bag.  The difference between these methods is the procedure used in adding, how duplicates are handled and what value is returned.\fs16\
\
\fs16\
\
\f1\b\fs36\li1400 Difference with OrdCltn\b0\f0\fs16\
\
\f0\fs28\li2200 Users should realize that, unlike {\b OrdCltn}, {\b Bag} does not preserve pointer equality (equality in the {\f2 isSame} sense).  Bag's instance method {\f2 eachElement} will return a sequence of objects, possibly containing duplicate elements, but those so-called duplicates will simply be pointers to the same element.  Also, since {\b Bag} is unordered, the order in which elements will be returned, is not the same as the order in which they were added.\fs16\
\
\fs16\
\
\f1\b\fs36\li1400 Method types\b0\f0\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Creation}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- new\
	- new:\
	- with:\
	- with:with:\
	- add:\
	- copy\
	- deepCopy\
	- emptyYourself\
	- freeContents\
	- free\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Interrogation}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- size\
	- isEmpty\
	- eachElement\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Comparing}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- isEqual:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Adding}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- add:\
	- addNTest:\
	- filter:\
	- add:ifDuplicate:\
	- replace:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Removing}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- remove:\
	- remove:ifAbsent:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Testing Contents}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- includesAllOf:\
	- includesAnyOf:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Adding and Removing Contents}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- addAll:\
	- addContentsOf:\
	- addContentsTo:\
	- removeAll:\
	- removeContentsFrom:\
	- removeContentsOf:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Combining}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- intersection:\
	- union:\
	- difference:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Converting}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- asSet\
	- asOrdCltn\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Using Blocks}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- detect:\
	- detect:ifNone:\
	- select:\
	- reject:\
	- collect:\
	- count:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Making elements perform}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- elementsPerform:\
	- elementsPerform:with:\
	- elementsPerform:with:with:\
	- elementsPerform:with:with:with:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Do Blocks}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- do:\
	- do:until:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Locating}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- find:\
	- contains:\
	- includes:\
	- occurrencesOf:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Printing}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- printOn:\
\pard\fs16\
\
\pard\tx2600\fs28\li2600\cf0
{\b Archiving}
\pard\tx6000\fs28\fi-3800\li6000\cf0
	- fileOutOn:\
	- fileInFrom:\
	- awakeFrom:\
\pard\fs16\
\
\fs16\
\
\f1\b\fs36\li1400 Methods\b0\f0\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 new\f0\b0\
\f0\fs28\li2500 +{\b new}\fs16\
\
\f0\fs28\li2200 Returns a new empty Bag.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 new:\f0\b0\
\f0\fs28\li2500 +{\b new}:(unsigned){\i n}\fs16\
\
\f0\fs28\li2200 Returns a new empty Bag, which can hold at least {\i n} different elements.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 with:\f0\b0\
\f0\fs28\li2500 +{\b with}:(int){\i nArgs,...}\fs16\
\
\f0\fs28\li2200 Returns a new object with {\i nArgs} elements.  For example,\fs16\
\
\f2\fs24\li2800 id aCltn = [OrdCltn with:2,anObject,otherObject];\
\f0\fs16\
\f0\fs28\li2200 creates a collection and adds {\i anObject} and {\i otherObject} to it.  In a similar way, {\b Set} or {\b SortCltn} instances can be created like this.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 with:with:\f0\b0\
\f0\fs28\li2500 +{\b with}:{\i firstObject}{\b with}:{\i nextObject}\fs16\
\
\f0\fs28\li2200 This method is equivalent to {\f2 with:} 2,{\i firstObject},{\i nextObject}. \fs16\
\
\fs16\
\
\f1\b\fs28\li2200 add:\f0\b0\
\f0\fs28\li2500 +{\b add}:{\i firstObject}\fs16\
\
\f0\fs28\li2200 This method is equivalent to {\f2 with:} 1,{\i firstObject}. \fs16\
\
\f0\fs28\li2200 This (factory) method has the same name as the instance method {\f2 add:} and can be used as follows, in circumstances when the user does not want to allocate a collection unless it is actually used :\fs16\
\
\f2\fs24\li2800 aCltn = [ (aCltn)?aCltn:OrdCltn add:myObject ];\
\f0\fs16\
\f0\fs28\li2200 This shows that creation of the collection is delayed until it is actually needed.  If the collection already exists, objects are simply added, using the instance method {\f2 add:}.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 copy\f0\b0\
\f0\fs28\li2500 -{\b copy}\fs16\
\
\f0\fs28\li2200 Returns a new copy of the Bag.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 deepCopy\f0\b0\
\f0\fs28\li2500 -{\b deepCopy}\fs16\
\
\f0\fs28\li2200 Returns a new copy of the Bag.  The elements in the new Bag are deep copies of the elements in the original Bag.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 emptyYourself\f0\b0\
\f0\fs28\li2500 -{\b emptyYourself}\fs16\
\
\f0\fs28\li2200 Empties all the members of the Bag (without freeing them).  Returns the receiver.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 freeContents\f0\b0\
\f0\fs28\li2500 -{\b freeContents}\fs16\
\
\f0\fs28\li2200 Removes and frees all the members of the Bag, but doesn't free the Bag itself.  Returns the receiver.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 free\f0\b0\
\f0\fs28\li2500 -{\b free}\fs16\
\
\f0\fs28\li2200 Frees the Bag, but not its elements.  Returns {\b nil}.  Do :\fs16\
\
\f2\fs24\li2800 bag = [[bag freeContents] free];\
\f0\fs16\
\f0\fs28\li2200 if you want to free the Bag and its contents.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 size\f0\b0\
\f0\fs28\li2500 - (unsigned){\b size}\fs16\
\
\f0\fs28\li2200 Returns the number of elements in the Bag.\fs16\
\
\f0\fs28\li2200 If an Object was added twice, then {\f2 size} returns two, not one, although that the Bag internally stores only one occurence of the Object.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 isEmpty\f0\b0\
\f0\fs28\li2500 - (BOOL){\b isEmpty}\fs16\
\
\f0\fs28\li2200 Whether the number of objects in the Bag is equal to zero.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 eachElement\f0\b0\
\f0\fs28\li2500 -{\b eachElement}\fs16\
\
\f0\fs28\li2200 Returns a sequence of elements in the Bag.  If the multiplicity of an object in the Bag is greater than one, pointers to the same object will occur multiple times in the Sequence.\fs16\
\
\f2\fs24\li2800 aSeq = [aBag eachElement];\
while ((anElement = [aSeq next])) \{\
    /* do something */\
\}\
aSeq = [aSeq free];\
\f0\fs16\
\fs16\
\
\f1\b\fs28\li2200 isEqual:\f0\b0\
\f0\fs28\li2500 - (BOOL){\b isEqual}:{\i bag}\fs16\
\
\f0\fs28\li2200 Returns YES if {\i bag} is a Bag, if {\i bag} has the same number of elements as the receiver, and if each member of the contents of {\i bag} is contained in the receiver's contents.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 add:\f0\b0\
\f0\fs28\li2500 -{\b add}:{\i anObject}\fs16\
\
\f0\fs28\li2200 Adds {\i anObject} to the Bag, and, if it's a duplicate, simply increases the multiplicity of the element.  This method doesn't inform the caller about whether the Object was a duplicate, because the receiver is always returned.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 addNTest:\f0\b0\
\f0\fs28\li2500 -{\b addNTest}:{\i anObject}\fs16\
\
\f0\fs28\li2200 Adds {\i anObject} if it was not previously in the Bag, otherwise increases the multiplicity of the matching element.  Returns {\i anObject} if it was not a duplicate, otherwise returns {\b nil}, but in either case adds the object to the Bag.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 filter:\f0\b0\
\f0\fs28\li2500 -{\b filter}:{\i anObject}\fs16\
\
\f0\fs28\li2200 The {\f2 filter:} method has a special purpose.  If there is a matching object in the Bag, then {\i anObject} is freed, the multiplicity of the matching element is increased, and the matching object is returned.  Otherwise, {\i anObject} is added and returned.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 add:ifDuplicate:\f0\b0\
\f0\fs28\li2500 -{\b add}:{\i anObject}{\b ifDuplicate}:{\i aBlock}\fs16\
\
\f0\fs28\li2200 Adds and returns {\i anObject}, if there was no duplicate previously in the Bag.\fs16\
\
\f0\fs28\li2200 Otherwise, this method evalutes {\i aBlock} and returns the matching object (the object that was already in the Bag).\fs16\
\
\f0\fs28\li2200 For example, the {\f2 filter:} method is equivalent to :\fs16\
\
\f2\fs24\li2800 [ Bag add: anObject ifDuplicate: \{ [anObject free] \}];\
\f0\fs16\
\fs16\
\
\f1\b\fs28\li2200 replace:\f0\b0\
\f0\fs28\li2500 -{\b replace}:{\i anObject}\fs16\
\
\f0\fs28\li2200 If a matching object is found, then {\i anObject} replaces that object, and the matching object is returned.  If there is no matching object, {\i anObject} is added to the receiver, and {\b nil} is returned.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 remove:\f0\b0\
\f0\fs28\li2500 -{\b remove}:{\i oldObject}\fs16\
\
\f0\fs28\li2200 Removes {\i oldObject} or the element which matches it using {\f2 isEqual:}.  Returns the removed entry, or {\b nil} if there is no matching entry.\fs16\
\
\f0\fs28\li2200 {\b {\f1 Note:}} The {\f2 remove:} method of the {\b OrdCltn} class is implemented to remove an exact match.  The {\b Set} class uses a match in the sense of {\f2 isEqual:} instead. \fs16\
\
\fs16\
\
\f1\b\fs28\li2200 remove:ifAbsent:\f0\b0\
\f0\fs28\li2500 -{\b remove}:{\i oldObject}{\b ifAbsent}:{\i exceptionBlock}\fs16\
\
\f0\fs28\li2200 Removes {\i oldObject} or the element which matches it using {\f2 isEqual:}.  Returns the removed entry, or return value of {\i exceptionBlock} if there is no matching entry.\fs16\
\
\f0\fs28\li2200 For example, the method {\f2 remove:} is equivalent to :\fs16\
\
\f2\fs24\li2800 [ aBag remove: oldObject ifAbsent: \{ nil \} ];\
\f0\fs16\
\f0\fs28\li2200 {\b {\f1 Note:}} The {\f2 remove:} method of the {\b OrdCltn} class is implemented to remove an exact match.  The {\b Set} class uses a match in the sense of {\f2 isEqual:} instead. \fs16\
\
\fs16\
\
\f1\b\fs28\li2200 includesAllOf:\f0\b0\
\f0\fs28\li2500 - (BOOL){\b includesAllOf}:{\i aCltn}\fs16\
\
\f0\fs28\li2200 Answer whether all the elements of {\i aCltn} are in the receiver, by sending {\f2 includes:} for each individual element.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 includesAnyOf:\f0\b0\
\f0\fs28\li2500 - (BOOL){\b includesAnyOf}:{\i aCltn}\fs16\
\
\f0\fs28\li2200 Answer whether any element of {\i aCltn} is in the receiver, by sending {\f2 includes:} for each individual element.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 addAll:\f0\b0\
\f0\fs28\li2500 -{\b addAll}:{\i aCltn}\fs16\
\
\f0\fs28\li2200 Adds each member of {\i aCltn} to the receiver.  If {\i aCltn} is {\b nil}, no action is taken.  The argument {\i aCltn} need not be a collection, so long as it responds to {\f2 eachElement} in the same way as collections do.  Returns the receiver.\fs16\
\
\f0\fs28\li2200 {\b {\f1 Note:}} If {\i aCltn} is the same object as the receiver, a {\f2 addYourself} message is sent to the object.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 addContentsOf:\f0\b0\
\f0\fs28\li2500 -{\b addContentsOf}:{\i aCltn}\fs16\
\
\f0\fs28\li2200 This method is equivalent to {\f2 addAll:} and is provided for Stepstone ICpak101 compatibility.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 addContentsTo:\f0\b0\
\f0\fs28\li2500 -{\b addContentsTo}:{\i aCltn}\fs16\
\
\f0\fs28\li2200 This method is equivalent to {\f2 addAll:}, but with argument and receiver interchanged, and is provided for Stepstone ICpak101 compatibility.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 removeAll:\f0\b0\
\f0\fs28\li2500 -{\b removeAll}:{\i aCltn}\fs16\
\
\f0\fs28\li2200 Removes all of the members of {\i aCltn} from the receiver. The argument {\i aCltn} need not be a collection, as long as it responds to {\f2 eachElement} as collections do.  Returns the receiver. \fs16\
\
\f0\fs28\li2200 {\b {\f1 Note:}} If {\i aCltn} is the same object as the receiver, it empties itself using {\f2 emptyYourself} and returns the receiver.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 removeContentsFrom:\f0\b0\
\f0\fs28\li2500 -{\b removeContentsFrom}:{\i aCltn}\fs16\
\
\f0\fs28\li2200 This method is equivalent to {\f2 removeAll:}, and is provided for compatibility with Stepstone ICpak101.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 removeContentsOf:\f0\b0\
\f0\fs28\li2500 -{\b removeContentsOf}:{\i aCltn}\fs16\
\
\f0\fs28\li2200 This method is equivalent to {\f2 removeAll:}, and is provided for compatibility with Stepstone ICpak101.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 intersection:\f0\b0\
\f0\fs28\li2500 -{\b intersection}:{\i bag}\fs16\
\
\f0\fs28\li2200 Returns a new Collection which is the intersection of the receiver and {\i bag}.  The new Collection contains only those elements that were in both the receiver and {\i bag}.  The argument {\i bag} need not be an actual {\b Set} or {\b Bag} instance, as long as it implements {\f2 find:} as Sets do.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 union:\f0\b0\
\f0\fs28\li2500 -{\b union}:{\i bag}\fs16\
\
\f0\fs28\li2200 Returns a new Collection which is the union of the receiver and {\i bag}.  The new Collection returned has all the elements from both the receiver and {\i bag}.  The argument {\i bag} need not be an actual {\b Set} or {\b Bag} instance, as long as it implements {\f2 eachElement:} as Sets and Bags do.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 difference:\f0\b0\
\f0\fs28\li2500 -{\b difference}:{\i bag}\fs16\
\
\f0\fs28\li2200 Returns a new Collection which is the difference of the receiver and {\i bag}.  The new Collection returned has only those elements in the receiver that are not in {\i bag}.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 asSet\f0\b0\
\f0\fs28\li2500 -{\b asSet}\fs16\
\
\f0\fs28\li2200 Creates a {\b Set} instance and adds the contents of the object to the set.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 asOrdCltn\f0\b0\
\f0\fs28\li2500 -{\b asOrdCltn}\fs16\
\
\f0\fs28\li2200 Creates a {\b OrdCltn} instance and adds the contents of the object to the set.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 detect:\f0\b0\
\f0\fs28\li2500 -{\b detect}:{\i aBlock}\fs16\
\
\f0\fs28\li2200 This message returns the first element in the receiver for which {\i aBlock} evaluates to something that is non-nil .  For example, the following :\fs16\
\
\f2\fs24\li2800 [ aCltn detect: \{ :each | [each isEqual:anObject] \} ];\
\f0\fs16\
\f0\fs28\li2200 Returns {\b nil} if there's no element for which {\i aBlock} evaluates to something that non-nil.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 detect:ifNone:\f0\b0\
\f0\fs28\li2500 -{\b detect}:{\i aBlock}{\b ifNone}:{\i noneBlock}\fs16\
\
\f0\fs28\li2200 This message returns the first element in the receiver for which {\i aBlock} evaluates to something that is non-nil.\fs16\
\
\f0\fs28\li2200 Evaluates {\i noneBlock} if there's no element for which {\i aBlock} evaluates to something that is non-nil, and returns the return value of that block.  For example,\fs16\
\
\f2\fs24\li2800 [ aCltn detect: \{ :e | [e isEqual:anObject]\} ifNone: \{anObject\} ];\
\f0\fs16\
\fs16\
\
\f1\b\fs28\li2200 select:\f0\b0\
\f0\fs28\li2500 -{\b select}:{\i testBlock}\fs16\
\
\f0\fs28\li2200 This message will return a subset of the receiver containing all elements for which {\i testBlock} evaluates to an Object that is non-nil.  For example,\fs16\
\
\f2\fs24\li2800 [ aCltn select: \{ :each | [each isEqual:anObject] \} ];\
\f0\fs16\
\f0\fs28\li2200 Returns a new empty instance of the same class as the receiver, if there's no element for which {\i testBlock} evaluates to something that is non-nil. \fs16\
\
\fs16\
\
\f1\b\fs28\li2200 reject:\f0\b0\
\f0\fs28\li2500 -{\b reject}:{\i testBlock}\fs16\
\
\f0\fs28\li2200 Complement of {\f2 select:}\fs16\
\
\f0\fs28\li2200 This message will return a subset of the receiver containing all elements for which {\i testBlock} evaluates to nil.  For example,\fs16\
\
\f2\fs24\li2800 [ aCltn reject: \{ :each | [each isEqual:anObject] \} ];\
\f0\fs16\
\f0\fs28\li2200 Returns a new empty instance of the same class as the receiver, if there's no element for which {\i testBlock} evaluates to nil.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 collect:\f0\b0\
\f0\fs28\li2500 -{\b collect}:{\i transformBlock}\fs16\
\
\f0\fs28\li2200 This message creates and returns a new collection of the same size and type as the receiver. The elements are the result of performing {\i transformBlock} on each element in the receiver (elements for which the Block would return {\b nil} are filtered out).\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 count:\f0\b0\
\f0\fs28\li2500 - (unsigned){\b count}:{\i aBlock}\fs16\
\
\f0\fs28\li2200 Evaluate {\i aBlock} with each of the receiver's elements as the argument.  Return the number that answered a non-{\b nil} value.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 elementsPerform:\f0\b0\
\f0\fs28\li2500 -{\b elementsPerform}:(SEL){\i aSelector}\fs16\
\
\f0\fs28\li2200 Send {\i aSelector} to all objects in the collection, starting from the object at offset {\i 0}.  For Stepstone compatibility.  Producer uses this.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 elementsPerform:with:\f0\b0\
\f0\fs28\li2500 -{\b elementsPerform}:(SEL){\i aSelector}{\b with}:{\i anObject}\fs16\
\
\f0\fs28\li2200 Send {\i aSelector} to all objects in the collection, starting from the object at offset {\i 0}.  For Stepstone compatibility.  Producer uses this.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 elementsPerform:with:with:\f0\b0\
\f0\fs28\li2500 -{\b elementsPerform}:(SEL){\i aSelector}{\b with}:{\i anObject}{\b with}:{\i otherObject}\fs16\
\
\f0\fs28\li2200 Send {\i aSelector} to all objects in the collection, starting from the object at offset {\i 0}.  For Stepstone compatibility.  Producer uses this.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 elementsPerform:with:with:with:\f0\b0\
\f0\fs28\li2500 -{\b elementsPerform}:(SEL){\i aSelector}{\b with}:{\i anObject}{\b with}:{\i otherObject}{\b with}:{\i thirdObj}\fs16\
\
\f0\fs28\li2200 Send {\i aSelector} to all objects in the collection, starting from the object at offset {\i 0}.  For Stepstone compatibility.  ICpak201 uses this.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 do:\f0\b0\
\f0\fs28\li2500 -{\b do}:{\i aBlock}\fs16\
\
\f0\fs28\li2200 Evaluates {\i aBlock} for each element in the collection and returns {\b self}.  {\i aBlock} must be a block taking one object (element) as argument; the return value of the block is ignored by this method.\fs16\
\
\f0\fs28\li2200 Often, the Block would, as a side-effect, modify a variable, as in:\fs16\
\
\f2\fs24\li2800 int count = 0;\
[contents do: \{ :what | if (what == anObject) count++; \}];\
\f0\fs16\
\fs16\
\
\f1\b\fs28\li2200 do:until:\f0\b0\
\f0\fs28\li2500 -{\b do}:{\i aBlock}{\b until}:(BOOL*){\i flag}\fs16\
\
\f0\fs28\li2200 Evaluates {\i aBlock} for each element in the collection, or until the variable pointed to by {\i flag} becomes true, and returns {\b self}.  {\i aBlock} must be a block taking one object (element) as argument; the return value of the block is ignored by this method.\fs16\
\
\f0\fs28\li2200 Typically the Block will modify the variable {\i flag} when some condition holds:\fs16\
\
\f2\fs24\li2800 BOOL found = NO;\
[contents do:\{ :what | if (what == findObject) found=YES;\} until:&found];\
if (found) \{ ... \}\
\f0\fs16\
\fs16\
\
\f1\b\fs28\li2200 find:\f0\b0\
\f0\fs28\li2500 -{\b find}:{\i anObject}\fs16\
\
\f0\fs28\li2200 Returns any element in the receiver which {\f2 isEqual:} to {\i anObject}.  Otherwise, returns {\b nil}.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 contains:\f0\b0\
\f0\fs28\li2500 - (BOOL){\b contains}:{\i anObject}\fs16\
\
\f0\fs28\li2200 Returns YES if the receiver contains {\i anObject}.  Otherwise, returns NO.  Implementation is in terms of the receiver's {\f2 find:} method (which uses {\f2 isEqual:} and {\f2 hash} to decide whether the object is contained in the Bag).\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 includes:\f0\b0\
\f0\fs28\li2500 - (BOOL){\b includes}:{\i anObject}\fs16\
\
\f0\fs28\li2200 This method is equivalent to {\f2 contains:}.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 occurrencesOf:\f0\b0\
\f0\fs28\li2500 - (unsigned){\b occurrencesOf}:{\i anObject}\fs16\
\
\f0\fs28\li2200 Returns the multiplicity of {\i anObject} in the receiver, i.e. the number of Objects that are equal (in the sense of {\f2 isEqual} to {\i anObject}), otherwise returns 0.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 printOn:\f0\b0\
\f0\fs28\li2500 -{\b printOn}:(IOD){\i aFile}\fs16\
\
\f0\fs28\li2200 Prints a list of the objects in the Bag by sending each individual object a {\f2 printOn:} message.  Returns the receiver.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 fileOutOn:\f0\b0\
\f0\fs28\li2500 -{\b fileOutOn}:{\i aFiler}\fs16\
\
\f0\fs28\li2200 Writes out non-nil objects in the Set on {\i aFiler}.  Returns the receiver.\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 fileInFrom:\f0\b0\
\f0\fs28\li2500 -{\b fileInFrom}:{\i aFiler}\fs16\
\
\f0\fs28\li2200 Reads in objects from {\i aFiler}.  Returns the receiver, which is a Bag that is not yet usable (until the Bag gets the {\f2 awakeFrom:} message).\fs16\
\
\fs16\
\
\f1\b\fs28\li2200 awakeFrom:\f0\b0\
\f0\fs28\li2500 -{\b awakeFrom}:{\i aFiler}\fs16\
\
\f0\fs28\li2200 Rehashes the contents of the Bag, which was previously read from {\i aFiler} by the {\i fileInFrom:} method.  The hash-values of the objects are possibly process or architecture dependent, so they are not stored on the filer.  Rather, {\f2 awakeFrom:} recomputes the values.\fs16\
\
\fs16\
\
\
}
